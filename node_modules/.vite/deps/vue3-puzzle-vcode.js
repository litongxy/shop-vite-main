import "./chunk-Y7B7GIIZ.js";
import {
  Teleport,
  computed,
  createBaseVNode,
  createBlock,
  defineComponent,
  normalizeClass,
  normalizeStyle,
  onMounted,
  onUnmounted,
  openBlock,
  reactive,
  ref,
  toDisplayString,
  unref,
  watch,
  withModifiers
} from "./chunk-QLSCPXTK.js";
import "./chunk-A4QZX3JM.js";

// node_modules/.pnpm/vue3-puzzle-vcode@1.1.7/node_modules/vue3-puzzle-vcode/dist/vue3-puzzle-vcode.es.js
import "/Users/litongb/shop-vite-main1/node_modules/.pnpm/vue3-puzzle-vcode@1.1.7/node_modules/vue3-puzzle-vcode/dist/main.css";
var he = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAELklEQVRYR+2YW2wUZRTH//9vtlCoF9IoIklT3PqgPGi326hoetuaGEhIr9SgCYkkgt2WGOQVCca+GavWdr0GjD4YhG3RB3hply1LQA1tEQIxEXapGI2pEkys9LIzx2ylYWfY6e5sF0oi+7hzzvl+3/9855xvhrjNf7zN+XAHcL4Z+n8o6JWTeYt++W25S596AIZy6TB+n3yo+Nchlk8vmIIVowdXU9c3Q1gDSilBlQwjgBAYFGDvdF58/4milqvZwDpOcXWsb5Uh8hmBqkwXFMhlCN8aX5LXNbRy/T+Z+iXsHAFWRXs3QGQPyLucLDJrK5DgUXdTsxPfjAEro8E3Ce50EtxsKxPTwCPH3U2jTmJkBJgWTnAMxDeGMEoa0xQ+LJQnCD4HYFkCyAC3RdwN3U7gMkpxRTTYrMD91sCJIgCxV5R6O1Jcfy7VwonqLoj9/CqB2kF341qncGkBvRe+ureAWpRgoalCBecMFzcdK24YymZRJz5zprgq1tsJwXYL3CVZGvdGHmwZc7JQtra2gE+f712ep2QUYP714DJhaJrXLqXZQszlZwtYdSHoB9ljVk/ePVrSZFL0ZkAlxzQBVseCT8WhZhRThtFB8plk9Zi/qCi8cv0fNxvKFrDy4oF11NXXIFy2EII4iBcG3Y03VLZT8OqRd5aFPduvOEpxRayvXolxAKB2g6NgEhobBlc1HHYKY7WvHf5wtVAPgegIlbbZ9seUZ7AyFnwewi9pGoUyDmhrB931kfnC1ZwOeKlLP8GZJi6QLSFP2yep4toXSbT3ZQAfX3O6omt8Nhd9r/aHQAUMOQywYBZo5uZD2ThQ2rbPCjlnH6yI9rUryE5DU75ctJaake46Be4DuDjF8dFBNA94/AdtiySVxIlpMlTS8td801o70vMigM9huTda2lhcKHVHPO2HZv/P6LIwX7hk/+qzPSvUJGMkrg8AQYTkroRdXMlE+HH/twsG6BsOdJHYZlaO/lBZ6weOiiSXqs3Gqj0TeAxx+T75DIpgwjC0onD51pQD4JaluPrkR/cpFT9DcoVp84LOgTL/DjtBbglgou+puHwB8lEznPxJw1XSX77VtgizBvQNBw4RMqB7xt4Lc3c8lQKJaQHoO4R8ydz0/7MWoCXk8c85MrMC9J3qaafw/WtQlwXST+F3BnAeYB4obgJ1BJIuG+YtiKAjVOZ/Pd1ZdwzoG+4uBtSPpjaRbhXLcwF3hzytb2TilgVgT5BkYybBrTYC+Rvg5nRpdTRJrIs8+VPXPQXj2i4ItxC4O2NQQUQnN4U9rRcz9nH64p4ceM2lziX5Y4s3KHCdUHwE77ecMkMEp6BwhIa2Z6DslZRvfulgHafYLuCas58WLp2aLCFUga70qxOFU6dPFL2W1feYeaU43Y5z/TxnCuYabMEuC043ckdBp4pZ7f8FE5psOI1g6fwAAAAASUVORK5CYII=";
var fe = ["width", "height"];
var ve = ["width", "height"];
var ge = ["width", "height"];
var pe = createBaseVNode("div", { class: "loading-gif_" }, [
  createBaseVNode("span"),
  createBaseVNode("span"),
  createBaseVNode("span"),
  createBaseVNode("span"),
  createBaseVNode("span")
], -1);
var me = [
  pe
];
var we = { class: "auth-control_" };
var Xe = { class: "range-text" };
var ye = createBaseVNode("div", null, null, -1);
var xe = createBaseVNode("div", null, null, -1);
var Se = createBaseVNode("div", null, null, -1);
var Te = [
  ye,
  xe,
  Se
];
var Me = defineComponent({
  __name: "App",
  props: {
    type: { type: String, default: "modal" },
    // 模式 modal,inside
    canvasWidth: { type: Number, default: 310 },
    // 主canvas的宽
    canvasHeight: { type: Number, default: 160 },
    // 主canvas的高
    show: { type: Boolean, default: false },
    // 是否出现，由父级控制
    puzzleScale: { type: Number, default: 1 },
    // 拼图块的大小缩放比例
    sliderSize: { type: Number, default: 50 },
    // 滑块的大小
    range: { type: Number, default: 10 },
    // 允许的偏差值
    zIndex: { type: Number, default: 999 },
    // 层级
    imgs: {
      type: Array,
      default: null
    },
    successText: {
      type: String,
      default: "验证通过！"
    },
    failText: {
      type: String,
      default: "验证失败，请重试"
    },
    sliderText: {
      type: String,
      default: "拖动滑块完成拼图"
    },
    className: {
      type: String,
      default: ""
    }
  },
  emits: ["success", "fail", "close", "reset"],
  setup(c, { expose: V, emit: M }) {
    const a = c;
    onMounted(() => {
      document.addEventListener("mousemove", B, false), document.addEventListener("mouseup", C, false), document.addEventListener("touchmove", B, { passive: false }), document.addEventListener("touchend", C, false), e.isInside = a.type === "inside", a.show && (!e.isInside && document.body.classList.add("vue-puzzle-overflow"), T());
    }), onUnmounted(() => {
      e.timer1 && clearTimeout(e.timer1), document.removeEventListener("mousemove", B, false), document.removeEventListener("mouseup", C, false), document.removeEventListener("touchmove", B, false), document.removeEventListener("touchend", C, false);
    });
    const H = ref(), R = ref(), L = ref(), k = ref(), e = reactive({
      isInside: false,
      mouseDown: false,
      startWidth: 50,
      startX: 0,
      newX: 0,
      pinX: 0,
      pinY: 0,
      loading: false,
      isCanSlide: false,
      error: false,
      infoBoxShow: false,
      infoText: "",
      infoBoxFail: false,
      timer1: void 0,
      closeDown: false,
      isSuccess: false,
      imgIndex: -1,
      isSubmting: false
    });
    watch(
      () => a.show,
      (n) => {
        n ? (!e.isInside && document.body.classList.add("vue-puzzle-overflow"), T()) : (e.isSubmting = false, e.isSuccess = false, e.infoBoxShow = false, document.body.classList.remove("vue-puzzle-overflow"));
      }
    ), watch(() => a.type, (n) => {
      n === "inside" ? (e.isInside = true, document.body.classList.remove("vue-puzzle-overflow")) : e.isInside = false;
    });
    const S = computed(() => {
      const n = e.startWidth + e.newX - e.startX;
      return n < h.value ? h.value : n > a.canvasWidth ? a.canvasWidth : n;
    }), d = computed(() => Math.round(Math.max(Math.min(a.puzzleScale, 2), 0.2) * 52.5 + 6)), h = computed(() => Math.max(
      Math.min(Math.round(a.sliderSize), Math.round(a.canvasWidth * 0.5)),
      10
    )), q = computed(() => a.zIndex !== 999 ? `z-index:${a.zIndex}` : ""), j = () => {
      !e.mouseDown && !e.isSubmting && (e.timer1 && clearTimeout(e.timer1), M("close"));
    }, P = () => {
      e.isInside || (e.closeDown = true);
    }, F = () => {
      e.closeDown && j(), e.closeDown = false;
    }, O = (n) => {
      var i;
      e.isCanSlide && (e.mouseDown = true, e.startWidth = ((i = H.value) == null ? void 0 : i.clientWidth) || 0, e.newX = n.clientX !== void 0 ? n.clientX : n.changedTouches[0].clientX, e.startX = n.clientX !== void 0 ? n.clientX : n.changedTouches[0].clientX);
    }, B = (n) => {
      e.mouseDown && (n.preventDefault(), e.newX = n.clientX !== void 0 ? n.clientX : n.changedTouches[0].clientX);
    }, C = () => {
      e.mouseDown && (e.mouseDown = false, ee());
    }, E = (n = false) => {
      var Z;
      if (e.loading && !n)
        return;
      e.loading = true, e.isCanSlide = false;
      const i = R.value, r = L.value, u = k.value, s = i == null ? void 0 : i.getContext("2d", { willReadFrequently: true }), t = r == null ? void 0 : r.getContext("2d"), v = u == null ? void 0 : u.getContext("2d");
      if (!s || !t || !v) {
        console.error("not found ctx / ctx2 / ctx3");
        return;
      }
      const ne = navigator.userAgent.indexOf("Firefox") >= 0 && navigator.userAgent.indexOf("Windows") >= 0, p = document.createElement("img");
      if (s.fillStyle = "rgba(255,255,255,1)", v.fillStyle = "rgba(255,255,255,1)", s.clearRect(0, 0, a.canvasWidth, a.canvasHeight), t.clearRect(0, 0, a.canvasWidth, a.canvasHeight), e.pinX = l(
        d.value + 20,
        a.canvasWidth - d.value - 10
      ), e.pinY = l(20, a.canvasHeight - d.value - 10), p.crossOrigin = "anonymous", p.onload = () => {
        const [g, z, W, D] = K(p), Q = Math.random(), U = Math.random(), N = Math.random(), se = Math.random(), Y = Q < 0.33 ? -1 : Q < 0.66 ? 0 : 1, X = U < 0.33 ? -1 : U < 0.66 ? 0 : 1, y = N < 0.33 ? -1 : N < 0.66 ? 0 : 1;
        let m = se < 0.6 ? 1 : 0;
        Y === X && X === y && y === m && m === 0 && (m = 1), s.save(), b(s, Y, X, y, m), s.closePath(), ne ? (s.clip(), s.save(), s.shadowOffsetX = 0, s.shadowOffsetY = 0, s.shadowColor = "#000", s.shadowBlur = 3, s.fill(), s.restore()) : (s.shadowOffsetX = 0, s.shadowOffsetY = 0, s.shadowColor = "#000", s.shadowBlur = 3, s.fill(), s.clip()), s.drawImage(p, g, z, W, D), v.fillRect(0, 0, a.canvasWidth, a.canvasHeight), v.drawImage(p, g, z, W, D), s.globalCompositeOperation = "source-atop", b(s, Y, X, y, m), s.arc(
          e.pinX + Math.ceil(d.value / 2),
          e.pinY + Math.ceil(d.value / 2),
          d.value * 1.2,
          0,
          Math.PI * 2,
          true
        ), s.closePath(), s.shadowColor = "rgba(255, 255, 255, .8)", s.shadowOffsetX = -1, s.shadowOffsetY = -1, s.shadowBlur = Math.min(Math.ceil(8 * a.puzzleScale), 12), s.fillStyle = "#ffffaa", s.fill();
        const ie = s.getImageData(
          e.pinX - 3,
          // 为了阴影 是从-3px开始截取，判定的时候要+3px
          e.pinY - 20,
          e.pinX + d.value + 5,
          e.pinY + d.value + 5
        );
        t.putImageData(ie, 0, e.pinY - 20), s.restore(), s.clearRect(0, 0, a.canvasWidth, a.canvasHeight), s.save(), b(s, Y, X, y, m), s.globalAlpha = 0.8, s.fillStyle = "#ffffff", s.fill(), s.restore(), s.save(), s.globalCompositeOperation = "source-atop", b(s, Y, X, y, m), s.arc(
          e.pinX + Math.ceil(d.value / 2),
          e.pinY + Math.ceil(d.value / 2),
          d.value * 1.2,
          0,
          Math.PI * 2,
          true
        ), s.shadowColor = "#000", s.shadowOffsetX = 2, s.shadowOffsetY = 2, s.shadowBlur = 16, s.fill(), s.restore(), s.save(), s.globalCompositeOperation = "destination-over", s.drawImage(p, g, z, W, D), s.restore(), e.loading = false, e.isCanSlide = true;
      }, p.onerror = () => {
        E(true);
      }, !n && ((Z = a.imgs) != null && Z.length)) {
        let g = l(0, a.imgs.length - 1);
        g === e.imgIndex && (g === a.imgs.length - 1 ? g = 0 : g++), e.imgIndex = g, p.src = a.imgs[g];
      } else
        p.src = _();
    }, l = (n, i) => Math.ceil(Math.random() * (i - n) + n), K = (n) => {
      const i = n.width / n.height, r = a.canvasWidth / a.canvasHeight;
      let u = 0, s = 0, t = 0, v = 0;
      return i > r ? (v = a.canvasHeight, t = i * v, s = 0, u = (a.canvasWidth - t) / 2) : (t = a.canvasWidth, v = t / i, u = 0, s = (a.canvasHeight - v) / 2), [u, s, t, v];
    }, b = (n, i, r, u, s) => {
      const t = Math.ceil(15 * a.puzzleScale);
      n.beginPath(), n.moveTo(e.pinX, e.pinY), n.lineTo(e.pinX + t, e.pinY), n.arcTo(
        e.pinX + t,
        e.pinY + i * t / 2,
        e.pinX + t + t / 2,
        e.pinY + i * t / 2,
        t / 2
      ), n.arcTo(
        e.pinX + t + t,
        e.pinY + i * t / 2,
        e.pinX + t + t,
        e.pinY,
        t / 2
      ), n.lineTo(e.pinX + t + t + t, e.pinY), n.lineTo(e.pinX + t + t + t, e.pinY + t), n.arcTo(
        e.pinX + t + t + t + r * t / 2,
        e.pinY + t,
        e.pinX + t + t + t + r * t / 2,
        e.pinY + t + t / 2,
        t / 2
      ), n.arcTo(
        e.pinX + t + t + t + r * t / 2,
        e.pinY + t + t,
        e.pinX + t + t + t,
        e.pinY + t + t,
        t / 2
      ), n.lineTo(e.pinX + t + t + t, e.pinY + t + t + t), n.lineTo(e.pinX + t + t, e.pinY + t + t + t), n.arcTo(
        e.pinX + t + t,
        e.pinY + t + t + t + u * t / 2,
        e.pinX + t + t / 2,
        e.pinY + t + t + t + u * t / 2,
        t / 2
      ), n.arcTo(
        e.pinX + t,
        e.pinY + t + t + t + u * t / 2,
        e.pinX + t,
        e.pinY + t + t + t,
        t / 2
      ), n.lineTo(e.pinX, e.pinY + t + t + t), n.lineTo(e.pinX, e.pinY + t + t), n.arcTo(
        e.pinX + s * t / 2,
        e.pinY + t + t,
        e.pinX + s * t / 2,
        e.pinY + t + t / 2,
        t / 2
      ), n.arcTo(
        e.pinX + s * t / 2,
        e.pinY + t,
        e.pinX,
        e.pinY + t,
        t / 2
      ), n.lineTo(e.pinX, e.pinY);
    }, _ = () => {
      const n = document.createElement("canvas"), i = n.getContext("2d");
      if (!i)
        return console.error("not found ctx"), "";
      n.width = a.canvasWidth, n.height = a.canvasHeight, i.fillStyle = `rgb(${l(100, 255)},${l(
        100,
        255
      )},${l(100, 255)})`, i.fillRect(0, 0, a.canvasWidth, a.canvasHeight);
      for (let r = 0; r < 12; r++)
        if (i.fillStyle = `rgb(${l(100, 255)},${l(
          100,
          255
        )},${l(100, 255)})`, i.strokeStyle = `rgb(${l(100, 255)},${l(
          100,
          255
        )},${l(100, 255)})`, l(0, 2) > 1)
          i.save(), i.rotate(l(-90, 90) * Math.PI / 180), i.fillRect(
            l(-20, n.width - 20),
            l(-20, n.height - 20),
            l(10, n.width / 2 + 10),
            l(10, n.height / 2 + 10)
          ), i.restore();
        else {
          i.beginPath();
          const u = l(-Math.PI, Math.PI);
          i.arc(
            l(0, n.width),
            l(0, n.height),
            l(10, n.height / 2 + 10),
            u,
            u + Math.PI * 1.5
          ), i.closePath(), i.fill();
        }
      return n.toDataURL("image/png");
    }, ee = () => {
      e.isSubmting = true;
      const n = S.value - h.value - (d.value - h.value) * ((S.value - h.value) / (a.canvasWidth - h.value)), i = e.pinX - 3 - n;
      Math.abs(i) < a.range ? (e.infoText = a.successText, e.infoBoxFail = false, e.infoBoxShow = true, e.isCanSlide = false, e.isSuccess = true, e.timer1 && clearTimeout(e.timer1), e.timer1 = setTimeout(() => {
        e.isSubmting = false, M("success", i, { deviation: i, offsetX: n, pinX: e.pinX - 3 });
      }, 800)) : (e.infoText = a.failText, e.infoBoxFail = true, e.infoBoxShow = true, e.isCanSlide = false, M("fail", i, { deviation: i, offsetX: n, pinX: e.pinX - 3 }), e.timer1 && clearTimeout(e.timer1), e.timer1 = setTimeout(() => {
        e.isSubmting = false, T();
      }, 800));
    }, te = () => {
      e.infoBoxFail = false, e.infoBoxShow = false, e.isCanSlide = false, e.isSuccess = false, e.startWidth = h.value, e.startX = 0, e.newX = 0;
    }, T = (n) => {
      e.isSubmting || (te(), E(), n && M("reset"));
    };
    return V({ reset: T }), (n, i) => (openBlock(), createBlock(Teleport, {
      to: "body",
      disabled: e.isInside
    }, [
      createBaseVNode("div", {
        class: normalizeClass(["vue-puzzle-vcode", { inside_: e.isInside, show_: c.show }, c.className]),
        style: normalizeStyle(unref(q)),
        onMousedown: P,
        onMouseup: F,
        onTouchstartPassive: P,
        onTouchend: F
      }, [
        createBaseVNode("div", {
          class: "vue-auth-box_",
          onMousedown: i[3] || (i[3] = withModifiers(() => {
          }, ["stop"])),
          onTouchstart: i[4] || (i[4] = withModifiers(() => {
          }, ["stop"]))
        }, [
          createBaseVNode("div", {
            class: "auth-body_",
            style: normalizeStyle(`width:${c.canvasWidth}px;height: ${c.canvasHeight}px`)
          }, [
            createBaseVNode("canvas", {
              ref_key: "canvas1",
              ref: R,
              class: "auth-canvas1_",
              width: c.canvasWidth,
              height: c.canvasHeight
            }, null, 8, fe),
            createBaseVNode("canvas", {
              ref_key: "canvas3",
              ref: k,
              class: normalizeClass(["auth-canvas3_", { show: e.isSuccess }]),
              width: c.canvasWidth,
              height: c.canvasHeight
            }, null, 10, ve),
            createBaseVNode("canvas", {
              ref_key: "canvas2",
              ref: L,
              class: "auth-canvas2_",
              width: unref(d),
              height: c.canvasHeight,
              style: normalizeStyle(`width:${unref(d)}px;height:${c.canvasHeight}px;transform:translateX(${unref(S) - unref(h) - (unref(d) - unref(h)) * ((unref(S) - unref(h)) / (c.canvasWidth - unref(h)))}px)`)
            }, null, 12, ge),
            createBaseVNode("div", {
              class: normalizeClass(["loading-box_", { hide_: !e.loading }])
            }, me, 2),
            createBaseVNode("div", {
              class: normalizeClass([
                "info-box_",
                { show: e.infoBoxShow },
                { fail: e.infoBoxFail }
              ])
            }, toDisplayString(e.infoText), 3),
            createBaseVNode("div", {
              class: normalizeClass(["flash_", { show: e.isSuccess }]),
              style: normalizeStyle(`transform: translateX(${e.isSuccess ? `${c.canvasWidth + c.canvasHeight * 0.578}px` : `-${c.canvasHeight * 0.578}px`}) skew(-30deg, 0);`)
            }, null, 6),
            createBaseVNode("img", {
              class: "reset_",
              onClick: i[0] || (i[0] = (r) => T(true)),
              src: he
            })
          ], 4),
          createBaseVNode("div", we, [
            createBaseVNode("div", {
              class: "range-box",
              style: normalizeStyle(`height:${unref(h)}px;width:${c.canvasWidth}px`)
            }, [
              createBaseVNode("div", Xe, toDisplayString(c.sliderText), 1),
              createBaseVNode("div", {
                class: "range-slider",
                ref_key: "rangeSlider",
                ref: H,
                style: normalizeStyle(`width:${unref(S)}px`)
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(["range-btn", { isDown: e.mouseDown }]),
                  style: normalizeStyle(`width:${unref(h)}px`),
                  onMousedown: i[1] || (i[1] = (r) => O(r)),
                  onTouchstart: i[2] || (i[2] = (r) => O(r))
                }, Te, 38)
              ], 4)
            ], 4)
          ])
        ], 32)
      ], 38)
    ], 8, ["disabled"]));
  }
});
export {
  Me as default
};
//# sourceMappingURL=vue3-puzzle-vcode.js.map

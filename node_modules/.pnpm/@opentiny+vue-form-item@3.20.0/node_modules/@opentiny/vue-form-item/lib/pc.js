function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
import { createVNode } from "vue";
import { defineComponent, $prefix, $props, setup as _setup, h, isVue2, parseVnode, hooks, stringifyCssClass, deduplicateCssClass } from "@opentiny/vue-common";
import { renderless, api } from "@opentiny/vue-renderless/form-item/vue";
import LabelWrap from "./label-wrap";
import Tooltip from "@opentiny/vue-tooltip";
import { iconError } from "@opentiny/vue-icon";
var $constants = {
  FORM_NAME: "Form",
  FORM_ITEM_NAME: "FormItem"
};
var _sfc_main = /* @__PURE__ */ defineComponent({
  name: $prefix + "FormItem",
  componentName: "FormItem",
  components: {
    LabelWrap,
    Tooltip,
    IconError: iconError()
  },
  props: _extends({}, $props, {
    _constants: {
      type: Object,
      default: function _default() {
        return $constants;
      }
    },
    appendToBody: {
      type: Boolean,
      default: void 0
    },
    error: String,
    for: String,
    inlineMessage: {
      type: Boolean,
      default: void 0
    },
    messageType: String,
    label: String,
    labelWidth: String,
    manual: Boolean,
    popperOptions: {
      type: Object,
      default: function _default2() {
        return {};
      }
    },
    prop: String,
    required: {
      type: Boolean,
      default: void 0
    },
    rules: [Object, Array],
    showMessage: {
      type: Boolean,
      default: true
    },
    size: String,
    validateDisabled: Boolean,
    validateDebounce: Boolean,
    validatePosition: String,
    validateStatus: String,
    validateType: String,
    validateIcon: {
      type: Object,
      default: null
    },
    ellipsis: {
      type: Boolean,
      default: false
    },
    vertical: {
      type: Boolean,
      default: false
    },
    extra: String
  }),
  setup: function setup(props, context) {
    return _setup({
      props,
      context,
      renderless,
      api
    });
  },
  render: function render() {
    var _state$formInstance, _state$formInstance2, _state$formInstance3, _state$formInstance4, _this = this, _class, _class2, _class3, _class4, _class5;
    var state = this.state, required = this.required, slots = this.slots, label = this.label, scopedSlots = this.scopedSlots, showMessage = this.showMessage, inlineMessage = this.inlineMessage, ellipsis = this.ellipsis, vertical = this.vertical, handleLabelMouseenter = this.handleLabelMouseenter, handleMouseleave = this.handleMouseleave;
    var validateIcon = state.validateIcon, isErrorInline = state.isErrorInline, isErrorBlock = state.isErrorBlock, tooltipType = state.tooltipType;
    var isMobile = state.mode === "mobile";
    var classPrefix = isMobile ? "tiny-mobile-" : "tiny-";
    var labelSlot = slots.label ? slots.label() : null;
    var defaultSlots = slots.default ? slots.default() : null;
    var errorSlot = scopedSlots.error && scopedSlots.error(state.validateMessage);
    var formItemClass = classPrefix + "form-item--" + (state.sizeClass ? state.sizeClass : "default");
    var isShowError = state.validateState === "error" && showMessage && state.form.showMessage;
    var validateTag = (_state$formInstance = state.formInstance) == null ? void 0 : _state$formInstance.validateTag;
    var wrapFragment = (_state$formInstance2 = state.formInstance) == null ? void 0 : _state$formInstance2.wrapFragment;
    var validateMessage;
    var formAppendToBody = (_state$formInstance3 = state.formInstance) == null ? void 0 : _state$formInstance3.appendToBody;
    var appendToBody = typeof this.appendToBody === "boolean" ? this.appendToBody : typeof formAppendToBody === "boolean" ? formAppendToBody : true;
    var validatePosition = this.validatePosition || ((_state$formInstance4 = state.formInstance) == null ? void 0 : _state$formInstance4.validatePosition) || "top-end";
    var popperOptions = _extends({}, state.formInstance.popperOptions, this.popperOptions, {
      forceAbsolute: !appendToBody,
      onUpdate: function onUpdate(options) {
        var popper = options.instance._popper;
        var translate3d = popper.style.transform;
        var matchTranslate = translate3d.match(/translate3d\((\w+)px, (\w+)px, (\w+)px\)/);
        if (!Array.isArray(matchTranslate)) {
          return;
        }
        var _matchTranslate$slice = matchTranslate.slice(1), x = _matchTranslate$slice[0], y = _matchTranslate$slice[1], z = _matchTranslate$slice[2];
        popper.style.transform = "translate3d(" + x + "px, " + parseInt(y, 10) + "px, " + z + "px)";
      }
    });
    var validateIconNode = validateIcon ? h(validateIcon, {
      class: "tooltip-validate-icon"
    }) : null;
    var ItemContent = defaultSlots ? defaultSlots.map(function(vnode) {
      if (isVue2 && !vnode.componentOptions && !validateTag)
        return vnode;
      var item = parseVnode(vnode);
      item.props = item.props || {};
      var _item = item, type = _item.type;
      item.dynamicProps = item.dynamicProps || [];
      if (!item.dynamicProps.includes("size")) {
        item.dynamicProps.push("size");
      }
      Object.assign(item.props, {
        size: state.formItemSize,
        mini: state.formItemSize === "mini" || Boolean(item.props.mini)
      });
      if (type && type.name && type.name.toLowerCase().endsWith("button")) {
        return item;
      }
      var propsData = item.props;
      if (propsData) {
        if (!state.isRequired) {
          state.validationRequired = propsData.validation && !!propsData.validation.required;
        }
        if (propsData.validation) {
          return item;
        }
      }
      if (isMobile) {
        return h("div", {
          class: classPrefix + "form-item__value",
          style: state.valueStyle
        }, [item]);
      }
      if (!isVue2) {
        if (item.type === hooks.Fragment) {
          if (wrapFragment) {
            item = h(wrapFragment, [item]);
          }
        } else if (item.type === hooks.Text) {
          item = h("span", [item]);
        }
      }
      var data;
      if (isVue2) {
        if (!item.data) {
          item.data = {};
        }
        data = item.data;
      } else {
        if (!item.props) {
          item.props = {};
        }
        data = item.props;
      }
      var mergeClass = "tiny-tooltip " + stringifyCssClass(data.class);
      data.class = deduplicateCssClass(mergeClass);
      return item;
    }) : null;
    state.isMultiple = (ItemContent == null ? void 0 : ItemContent.length) > 1;
    var getFormItemContnet = function getFormItemContnet2() {
      if (isMobile) {
        var _validatePosition = _this.validatePosition || state.formInstance.validatePosition || "right";
        validateMessage = state.validateMessage ? _validatePosition === "right" ? createVNode("div", {
          "class": "tiny-mobile-input-form__error align-right"
        }, [state.validateMessage]) : createVNode("div", {
          "class": "tiny-mobile-input-form__error align-left"
        }, [state.validateMessage]) : null;
        return ItemContent;
      }
      return ItemContent;
    };
    var FormItemContnet = ItemContent ? getFormItemContnet() : null;
    var ErrorContent = isShowError && state.getValidateType === "text" ? errorSlot || h("div", {
      class: (_class = {}, _class[classPrefix + "form-item__error"] = true, _class[classPrefix + "form-item__error--inline"] = isErrorInline, _class[classPrefix + "form-item__error--block"] = isErrorBlock, _class),
      attrs: {
        title: [state.validateMessage]
      }
    }, [validateIcon ? h(validateIcon, {
      class: "validate-icon"
    }) : null, createVNode("span", {
      "class": classPrefix + "form-item__validate-message"
    }, [state.validateMessage])]) : null;
    var LabelContent = h("label-wrap", {
      props: {
        isAutoWidth: state.labelStyle && state.labelStyle.width === "auto",
        updateAll: state.form.labelWidth === "auto",
        isMobile: state.mode === "mobile"
      }
    }, [labelSlot || label ? h("label", {
      class: (_class2 = {}, _class2[classPrefix + "form-item__label"] = true, _class2["is-ellipsis"] = isMobile && ellipsis, _class2),
      style: state.labelStyle,
      attrs: {
        for: state.labelFor
      },
      on: {
        mouseenter: handleLabelMouseenter,
        mouseleave: handleMouseleave
      }
    }, labelSlot || label + state.form.labelSuffix) : null]);
    var ExtraTip = this.extra ? h("div", {
      class: (_class3 = {}, _class3[classPrefix + "form-item__extra-tip"] = true, _class3)
    }, this.extra) : null;
    return h("div", {
      class: (_class4 = {}, _class4[classPrefix + "form-item"] = true, _class4[classPrefix + "form-item--feedback"] = state.formInstance && state.formInstance.statusIcon, _class4["is-error"] = state.validateState === "error", _class4["is-text"] = state.getValidateType === "text", _class4["is-validating"] = state.validateState === "validating", _class4["is-success"] = state.validateState === "success", _class4["is-required"] = state.isRequired || required, _class4["is-no-asterisk"] = state.hideRequiredAsterisk, _class4[formItemClass] = true, _class4)
    }, [!isMobile ? LabelContent : null, this.showMessage && !isMobile && h("tooltip", {
      props: {
        popperClass: classPrefix + "form__valid",
        arrowOffset: 0,
        adjustArrow: true,
        type: tooltipType,
        disabled: state.getValidateType !== "tip",
        placement: validatePosition,
        manual: true,
        appendToBody,
        popperOptions,
        modelValue: isShowError ? state.canShowTip : false,
        zIndex: "relative",
        renderContent: function renderContent() {
          var tooltipContent;
          if (errorSlot) {
            tooltipContent = [errorSlot];
          } else {
            tooltipContent = [validateIconNode, createVNode("span", {
              "class": classPrefix + "form-item__validate-message"
            }, [state.validateMessage])];
          }
          return tooltipContent;
        }
      },
      on: {
        "update:modelValue": function updateModelValue(value) {
          state.canShowTip = value;
        }
      },
      ref: "tooltip"
    }), h("div", {
      class: (_class5 = {}, _class5[classPrefix + "form-item__content"] = true, _class5["is-vertical"] = isMobile && vertical, _class5),
      style: !isMobile && state.contentStyle,
      ref: "content"
    }, [isMobile ? LabelContent : null, FormItemContnet, isMobile ? validateMessage : null, h("transition", {
      attrs: {
        name: classPrefix + "zoom-in-top"
      }
    }, [ErrorContent]), isMobile ? null : ExtraTip])]);
  }
});
export {
  _sfc_main as default
};

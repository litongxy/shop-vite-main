import { createVNode, resolveComponent, openBlock, createBlock, withCtx, renderSlot, createElementBlock, normalizeStyle, normalizeClass } from 'vue';
import { renderless as renderless$1, api as api$1 } from '@opentiny/vue-renderless/tabs/vue';
import { $props, defineComponent, $prefix, setup, h, props } from '@opentiny/vue-common';
import { t } from '@opentiny/vue-locale';
import { renderless, api } from '@opentiny/vue-renderless/tab-nav/vue';
import Dropdown from '@opentiny/vue-dropdown';
import DropdownMenu from '@opentiny/vue-dropdown-menu';
import DropdownItem from '@opentiny/vue-dropdown-item';
import Tooltip from '@opentiny/vue-tooltip';
import { iconChevronLeft, iconChevronRight, iconClose, iconPlus } from '@opentiny/vue-icon';
import { renderless as renderless$2, api as api$2 } from '@opentiny/vue-renderless/tab-bar/vue';
import '@opentiny/vue-theme/tabs/index.css';

function _createForOfIteratorHelperLoose(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (t)
    return (t = t.call(r)).next.bind(t);
  if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
    t && (r = t);
    var o = 0;
    return function() {
      return o >= r.length ? { done: true } : { done: false, value: r[o++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r)
      return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++)
    n[e] = r[e];
  return n;
}
var _export_sfc = function _export_sfc2(sfc, props) {
  var target = sfc.__vccOpts || sfc;
  for (var _iterator = _createForOfIteratorHelperLoose(props), _step; !(_step = _iterator()).done; ) {
    var _step$value = _step.value, key = _step$value[0], val = _step$value[1];
    target[key] = val;
  }
  return target;
};

function _extends$1() {
  return _extends$1 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends$1.apply(null, arguments);
}
var tabNavPcProps = _extends$1({}, $props, {
  panes: {
    type: Array,
    default: function _default() {
      return [];
    }
  },
  currentName: String,
  editable: Boolean,
  overflowTitle: Boolean,
  onTabClick: {
    type: Function,
    default: function _default2() {
    }
  },
  onTabRemove: {
    type: Function,
    default: function _default3() {
    }
  },
  tabStyle: String,
  stretch: Boolean,
  showMoreTabs: Boolean,
  showPanesCount: Number,
  popperClass: String,
  popperAppendToBody: {
    type: Boolean,
    default: true
  },
  dropConfig: {
    type: Object,
    default: function _default4() {
      return null;
    }
  },
  titleWidth: {
    type: String,
    default: "256px"
  },
  // tiny 新增
  tooltipConfig: [String, Object],
  panelMaxHeight: String,
  panelWidth: String
});
_extends$1({}, $props, {
  panes: {
    type: Array,
    default: function _default5() {
      return [];
    }
  },
  currentName: String,
  activeColor: {
    type: String,
    default: ""
  },
  onTabClick: {
    type: Function,
    default: function _default6() {
    }
  },
  onTabRemove: {
    type: Function,
    default: function _default7() {
    }
  },
  showExpandTabs: Boolean,
  expandPanesWidth: {
    type: String,
    default: ""
  },
  expandTabsTitle: {
    type: String,
    default: "请选择"
  },
  expandTabsMode: {
    type: String,
    default: "columns"
  },
  stretch: {
    type: Boolean,
    default: false
  }
});
var tabBarProps = _extends$1({}, $props, {
  tabs: Array
});

function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t2 = arguments[e];
      for (var r in t2)
        ({}).hasOwnProperty.call(t2, r) && (n[r] = t2[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
var _sfc_main$3 = defineComponent({
  name: $prefix + "TabDropdownItem",
  components: {
    TinyDropdownItem: DropdownItem
  },
  props: _extends({}, $props, {
    itemClick: {
      type: Function
    }
  })
});
function _sfc_render$1(_ctx, _cache, $props2, $setup, $data, $options) {
  var _component_tiny_dropdown_item = resolveComponent("tiny-dropdown-item");
  return openBlock(), createBlock(_component_tiny_dropdown_item, {
    onClick: _ctx.itemClick
  }, {
    default: withCtx(function() {
      return [renderSlot(_ctx.$slots, "default")];
    }),
    _: 3
    /* FORWARDED */
  }, 8, ["onClick"]);
}
var TabDropdownItem = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$1]]);
var _sfc_main$2 = /* @__PURE__ */ defineComponent({
  name: $prefix + "TabBar",
  props: tabBarProps,
  setup: function setup$1(props2, context) {
    return setup({
      props: props2,
      context,
      renderless: renderless$2,
      api: api$2,
      mono: true
    });
  }
});
function _sfc_render(_ctx, _cache, $props2, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    "div",
    {
      style: normalizeStyle(_ctx.state.barStyle),
      class: normalizeClass(["is-" + _ctx.state.rootTabs.position, _ctx.state.separator ? "" : "tiny-tabs__active-bar"])
    },
    null,
    6
    /* CLASS, STYLE */
  );
}
var TabBar = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render]]);
var _sfc_main$1 = /* @__PURE__ */ defineComponent({
  name: $prefix + "TabNav",
  components: {
    TabBar,
    Dropdown,
    DropdownMenu,
    TabDropdownItem,
    Tooltip,
    IconChevronLeft: iconChevronLeft(),
    IconChevronRight: iconChevronRight(),
    IconClose: iconClose()
  },
  props: tabNavPcProps,
  inject: ["moreIcon"],
  setup: function setup2(props2, context) {
    return setup({
      props: props2,
      context,
      renderless: renderless,
      api: api,
      mono: true
    });
  },
  render: function render() {
    var state = this.state, tabStyle = this.tabStyle, editable = this.editable, stretch = this.stretch, showPanesCount = this.showPanesCount, onTabClick = this.onTabClick, onTabRemove = this.onTabRemove, scrollNext = this.scrollNext, scrollPrev = this.scrollPrev, changeTab = this.changeTab, setFocus = this.setFocus, removeFocus = this.removeFocus, showMoreTabs = this.showMoreTabs, popperClass = this.popperClass, overflowTitle = this.overflowTitle, titleWidth = this.titleWidth, handleTitleMouseenter = this.handleTitleMouseenter, handleTitleMouseleave = this.handleTitleMouseleave, moreIcon = this.moreIcon, tooltipConfig = this.tooltipConfig, panelMaxHeight = this.panelMaxHeight, panelWidth = this.panelWidth;
    var panes = this.panes;
    var spans = [createVNode("span", {
      "class": ["tiny-tabs__nav-prev", state.scrollable.prev ? "" : "is-disabled"],
      "onClick": scrollPrev
    }, [createVNode(resolveComponent("IconChevronLeft"), null, null)]), !showMoreTabs ? createVNode("span", {
      "class": ["tiny-tabs__nav-next", state.scrollable.next ? "" : "is-disabled"],
      "onClick": scrollNext
    }, [createVNode(resolveComponent("IconChevronRight"), null, null)]) : null];
    var scrollBtn = state.scrollable ? spans : null;
    var moreTabs = null;
    if (showMoreTabs && state.scrollable) {
      var reference = function reference2() {
        return moreIcon ? createVNode("span", {
          "class": "tiny-tabs__more-icon"
        }, [moreIcon() || t("ui.tabs.moreItem")]) : createVNode("span", {
          "class": "tiny-tabs__more"
        }, [t("ui.tabs.moreItem")]);
      };
      var dropdowpList = panes.slice(showPanesCount);
      var isShowDropDown = showPanesCount !== -1 && Boolean(dropdowpList.length);
      var menuSlot = function menuSlot2() {
        return isShowDropDown ? dropdowpList.map(function(pane, index) {
          var tabName = pane.name || pane.state.index || index;
          var tabLabelContent = pane.$slots.title || pane.title;
          pane.state.index = "" + (index + showPanesCount);
          return h(TabDropdownItem, {
            class: "tiny-tabs__more-item",
            attrs: {
              itemClick: function itemClick(e) {
                removeFocus();
                onTabClick(pane, tabName, e);
              }
            }
          }, [typeof tabLabelContent === "function" ? tabLabelContent() : tabLabelContent]);
        }) : null;
      };
      var dropdownSlot = function dropdownSlot2() {
        return isShowDropDown ? h(DropdownMenu, {
          attrs: {
            popperClass: "tiny-tabs-dropdown tiny-tabs__more-dropdown" + (popperClass ? " " + popperClass : ""),
            placement: "bottom-start",
            style: {
              maxHeight: panelMaxHeight,
              width: panelWidth
            }
          },
          scopedSlots: {
            default: menuSlot
          }
        }) : null;
      };
      moreTabs = createVNode("div", {
        "class": "tiny-tabs__more-container",
        "ref": "more"
      }, [isShowDropDown ? h(Dropdown, {
        attrs: {
          trigger: "hover"
        },
        scopedSlots: {
          default: reference,
          dropdown: dropdownSlot
        }
      }) : reference()]);
    }
    var tabs = panes.map(function(pane, index) {
      var _class;
      var tabName = pane.name || pane.state.index || index;
      var withClose = pane.state.isClosable || editable;
      pane.state.index = "" + index;
      var btnClose = withClose ? createVNode("span", {
        "class": "tiny-tabs__icon-close"
      }, [createVNode(resolveComponent("IconClose"), {
        "onClick": function onClick(e) {
          onTabRemove(pane, e);
        }
      }, null)]) : null;
      var getTabTitle = function getTabTitle2(title) {
        return h("span", {
          class: {
            "tiny-tabs__item-title": true
          },
          style: {
            "max-width": titleWidth
          },
          on: {
            mouseenter: function mouseenter(e) {
              handleTitleMouseenter(e, title);
            },
            mouseleave: function mouseleave(e) {
              handleTitleMouseleave(e);
            }
          }
        }, [title]);
      };
      var tipComp = function tipComp2() {
        return tooltipConfig === "title" ? h("span", {
          class: "tiny-tabs__item__title",
          attrs: {
            title: pane.title
          }
        }, [pane.title]) : h(Tooltip, {
          class: "tiny-tabs__item__title",
          props: _extends({
            content: pane.title
          }, tooltipConfig)
        }, [h("span", {}, [pane.title])]);
      };
      var toolTipComp = function toolTipComp2() {
        return tooltipConfig ? tipComp() : h("span", {
          class: "tiny-tabs__item__title"
        }, [pane.title]);
      };
      var itemsSeparator = createVNode("span", {
        "class": "tiny-tabs__item-separator"
      }, null);
      var tabLabelContent = pane.$slots.title ? pane.$slots.title() : toolTipComp();
      var tabindex = pane.state.active ? 0 : -1;
      return h("div", {
        ref: "tabs-" + tabName,
        key: "tab-" + tabName + "-" + index,
        class: (_class = {
          "tiny-tabs__item": true,
          "tiny-tabs__item-separator-space": state.separator
        }, _class["is-" + state.rootTabs.position] = true, _class["is-active"] = pane.state.active, _class["is-disabled"] = pane.disabled, _class["is-closable"] = withClose, _class["is-focus"] = state.isFocus, _class),
        attrs: {
          id: "tab-" + tabName,
          "aria-controls": "pane-" + tabName,
          "data-index": index + 1,
          role: "tab",
          "aria-selected": pane.state.active,
          tabindex,
          refInFor: true
        },
        on: {
          focus: function focus() {
            setFocus();
          },
          blur: function blur() {
            removeFocus();
          },
          click: function click(e) {
            removeFocus();
            onTabClick(pane, tabName, e);
          },
          keydown: function keydown(e) {
            if (withClose && (e.keyCode === 46 || e.keyCode === 8)) {
              onTabRemove(pane, e);
            }
          }
        }
      }, [overflowTitle ? getTabTitle(tabLabelContent) : tabLabelContent, btnClose, (state.separator || tabStyle === "button-card") && itemsSeparator]);
    });
    var paddingRight = this.$refs.more ? this.$refs.more.offsetWidth + "px" : "46px";
    return createVNode("div", {
      "style": showMoreTabs ? {
        paddingRight
      } : {},
      "class": ["tiny-tabs__nav-wrap", !state.separator && "tiny-tabs__nav-wrap-not-separator", state.scrollable ? "is-scrollable" : "", showMoreTabs ? "is-show-more" : "", "is-" + state.rootTabs.position]
    }, [[scrollBtn, moreTabs], createVNode("div", {
      "class": ["tiny-tabs__nav-scroll"],
      "ref": "navScroll"
    }, [createVNode("div", {
      "class": ["tiny-tabs__nav", "is-" + state.rootTabs.position, stretch && ["top", "bottom"].includes(state.rootTabs.position) ? "is-stretch" : "", !tabStyle ? "is-show-active-bar" : ""],
      "ref": "nav",
      "style": state.navStyle,
      "role": "tablist",
      "on-keydown": changeTab
    }, [!tabStyle ? createVNode(TabBar, {
      "ref": "tabBar",
      "tabs": panes
    }, null) : null, tabs])]), overflowTitle ? createVNode(Tooltip, {
      "ref": "tooltip",
      "modelValue": state.tooltipVisible,
      "onUpdate:modelValue": function onUpdateModelValue($event) {
        return state.tooltipVisible = $event;
      },
      "manual": true,
      "effect": "light",
      "content": state.tooltipContent,
      "placement": "top"
    }, null) : null]);
  }
});
var _sfc_main = /* @__PURE__ */ defineComponent({
  emits: ["add", "click", "close", "edit", "update:modelValue", "tab-nav-update", "tab-drag-start", "tab-drag-over", "tab-drag-end"],
  props: [].concat(props, ["tabStyle", "activeName", "withClose", "withAdd", "size", "modelValue", "editable", "position", "beforeLeave", "stretch", "showMoreTabs", "popperClass", "popperAppendToBody", "dropConfig", "tooltipConfig", "separator", "beforeClose", "overflowTitle", "titleWidth", "moreShowAll", "panelMaxHeight", "panelWidth"]),
  components: {
    TabNav: _sfc_main$1,
    IconPlus: iconPlus()
  },
  provide: function provide() {
    return {
      moreIcon: this.$slots.moreIcon
    };
  },
  setup: function setup3(props2, context) {
    return setup({
      props: props2,
      context,
      renderless: renderless$1,
      api: api$1
    });
  },
  render: function render2() {
    var _this = this, _class2;
    var state = this.state, tabStyle = this.tabStyle, handleTabClick = this.handleTabClick, handleTabRemove = this.handleTabRemove, handleTabAdd = this.handleTabAdd, handleTabDragStart = this.handleTabDragStart, handleTabDragOver = this.handleTabDragOver, handleTabDragEnd = this.handleTabDragEnd, editable = this.editable, withAdd = this.withAdd, position = this.position, size = this.size, stretch = this.stretch, showMoreTabs = this.showMoreTabs, popperClass = this.popperClass, popperAppendToBody = this.popperAppendToBody, dropConfig = this.dropConfig, tooltipConfig = this.tooltipConfig, overflowTitle = this.overflowTitle, titleWidth = this.titleWidth, panelMaxHeight = this.panelMaxHeight, panelWidth = this.panelWidth;
    var newButton = editable || withAdd ? createVNode("span", {
      "class": "tiny-tabs__new-tab",
      "onClick": handleTabAdd,
      "tabindex": "0",
      "onKeydown": function onKeydown(ev) {
        if (ev.keyCode === 13) {
          handleTabAdd();
        }
      }
    }, [createVNode(resolveComponent("icon-plus"), null, null)]) : null;
    var navData = {
      props: {
        currentName: state.currentName,
        panes: state.panes,
        onTabClick: handleTabClick,
        onTabRemove: handleTabRemove,
        showPanesCount: state.showPanesCount,
        editable,
        tabStyle,
        size,
        stretch,
        showMoreTabs,
        popperClass,
        popperAppendToBody,
        dropConfig,
        tooltipConfig,
        overflowTitle,
        titleWidth,
        separator: state.separator,
        panelMaxHeight,
        panelWidth
      },
      on: {
        "tab-drag-start": handleTabDragStart,
        "tab-drag-over": handleTabDragOver,
        "tab-drag-end": handleTabDragEnd
      },
      ref: "nav"
    };
    var TabNavComponent = h(_sfc_main$1, _extends({}, navData));
    this.$nextTick(function() {
      _this.$refs.nav && _this.$refs.nav.$forceUpdate();
    });
    var header = createVNode("div", {
      "class": ["tiny-tabs__header", "is-" + position]
    }, [TabNavComponent, newButton]);
    var panels = createVNode("div", {
      "class": "tiny-tabs__content"
    }, [this.slots.default && this.slots.default()]);
    return createVNode("div", {
      "class": (_class2 = {
        "tiny-tabs": true,
        "tiny-tabs--card": tabStyle === "card"
      }, _class2["tiny-tabs--" + (!state.separator ? position : "top")] = true, _class2["tiny-tabs--border-card"] = tabStyle === "border-card", _class2["tiny-tabs--button-card"] = tabStyle === "button-card", _class2["tiny-tabs--small"] = size === "small", _class2["tiny-tabs--large"] = size === "large", _class2)
    }, [position !== "bottom" ? [header, panels] : [panels, header]]);
  }
});

export { _sfc_main as default };

import Core from '@opentiny/vue-huicharts-core';
import * as echarts from 'echarts';
import { $prefix } from '@opentiny/vue-common';
import { openBlock, createElementBlock, createElementVNode, normalizeStyle, renderSlot } from 'vue';

function _createForOfIteratorHelperLoose(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (t)
    return (t = t.call(r)).next.bind(t);
  if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
    t && (r = t);
    var o = 0;
    return function() {
      return o >= r.length ? { done: true } : { done: false, value: r[o++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r)
      return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++)
    n[e] = r[e];
  return n;
}
var _export_sfc = function _export_sfc2(sfc, props) {
  var target = sfc.__vccOpts || sfc;
  for (var _iterator = _createForOfIteratorHelperLoose(props), _step; !(_step = _iterator()).done; ) {
    var _step$value = _step.value, key = _step$value[0], val = _step$value[1];
    target[key] = val;
  }
  return target;
};

function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
var AMapCoordSys = /* @__PURE__ */ function() {
  function AMapCoordSys2(amap, api) {
    this._amap = amap;
    this.dimensions = ["lng", "lat"];
    this._mapOffset = [0, 0];
    this._api = api;
  }
  AMapCoordSys2.create = function create(ecModel, api) {
    var tinySys;
    var root = api.getDom();
    ecModel.eachComponent("amap", function(tinyModel) {
      var viewportRoot = api.getZr().painter.getViewportRoot();
      if (typeof window.AMap === "undefined") {
        throw new TypeError("AMap api is not loaded");
      }
      if (tinySys) {
        throw new Error("Only one amap component can exist");
      }
      if (!tinyModel.__amap) {
        var amapRoot = root.querySelector(".ec-extension-amap");
        if (amapRoot) {
          viewportRoot.style.left = "0px";
          viewportRoot.style.top = "0px";
          root.removeChild(amapRoot);
        }
        amapRoot = document.createElement("div");
        amapRoot.style.cssText = "width:100%;height:100%";
        amapRoot.classList.add("ec-extension-amap");
        root.appendChild(amapRoot);
        var options = tinyModel.get() || {};
        options = tinyModel.__options = echarts.util.clone(options);
        var amap = tinyModel.__amap = new window.AMap.Map(amapRoot, options);
        var layer = tinyModel.__layer = new window.AMap.CustomLayer(viewportRoot);
        layer.setMap(amap);
      }
      var tinyApm = tinyModel.getAMap();
      var tinyOut = tinyModel.getLayer();
      tinyOut.hide();
      var tinyZoom = tinyApm.getZoom();
      var tinyCenter = tinyApm.getCenter();
      tinySys = new AMapCoordSys2(tinyApm, api);
      tinySys.setMapOffset(tinyModel.__mapOffset || [0, 0]);
      tinySys.setZoom(tinyZoom);
      tinySys.setCenter([tinyCenter.lng, tinyCenter.lat]);
      tinyModel.coordinateSystem = tinySys;
      tinyOut.show();
    });
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.get("coordinateSystem") === "amap") {
        seriesModel.coordinateSystem = tinySys;
      }
    });
  };
  var _proto = AMapCoordSys2.prototype;
  _proto.setZoom = function setZoom(zoom) {
    this._zoom = zoom;
  };
  _proto.setCenter = function setCenter(center) {
    this._center = this._amap.lnglatToPixel(center);
  };
  _proto.setMapOffset = function setMapOffset(mapOffset) {
    this._mapOffset = mapOffset;
  };
  _proto.getAMap = function getAMap() {
    return this._amap;
  };
  _proto.dataToPoint = function dataToPoint(data2) {
    var point = new window.AMap.LngLat(data2[0], data2[1]);
    var px = this._amap.lngLatToContainer(point);
    var mapOffset = this._mapOffset;
    return [px.x - mapOffset[0], px.y - mapOffset[1]];
  };
  _proto.pointToData = function pointToData(pt) {
    var mapOffset = this._mapOffset;
    pt = this._amap.containerToLngLat({
      x: pt[0] + mapOffset[0],
      y: pt[1] + mapOffset[1]
    });
    return [pt.lng, pt.lat];
  };
  _proto.getViewRect = function getViewRect() {
    var api = this._api;
    return new echarts.graphic.BoundingRect(0, 0, api.getWidth(), api.getHeight());
  };
  _proto.getRoamTransform = function getRoamTransform() {
    return echarts.matrix.create();
  };
  return AMapCoordSys2;
}();
var equal = function equal2(x, y) {
  return x && y && x[0] === y[0] && x[1] === y[1];
};
function extendComponentModel() {
  echarts.extendComponentModel({
    type: "amap",
    getAMap: function getAMap() {
      return this.__amap;
    },
    getLayer: function getLayer() {
      return this.__layer;
    },
    getMapOptions: function getMapOptions() {
      return this.__options;
    },
    setCenterAndZoom: function setCenterAndZoom(center, zoom) {
      this.huiChartOption.center = center;
      this.huiChartOption.zoom = zoom;
    },
    centerOrZoomChanged: function centerOrZoomChanged(center, zoom) {
      var option = this.huiChartOption;
      return !(equal(center, option.center) && zoom === option.zoom);
    },
    defaultOption: {
      center: [116.397475, 39.908695],
      zoom: 4
    }
  });
}
var setLaterFunc = function setLaterFunc2(ctx) {
  ctx.later = function() {
    ctx.lock = false;
    if (ctx.args) {
      ctx.wrapperFn.apply(ctx.context, ctx.args);
      ctx.args = false;
    }
  };
};
var setWrapperFunc = function setWrapperFunc2(ctx) {
  ctx.wrapperFn = function() {
    if (ctx.lock) {
      ctx.args = arguments;
    } else {
      ctx.fn.apply(ctx.context, arguments);
      setTimeout(ctx.later, ctx.time);
      ctx.lock = true;
    }
  };
};
var throttle = function throttle2(fn, time, context) {
  var ctx = {
    fn,
    time,
    context,
    lock: void 0,
    args: void 0,
    wrapperFn: void 0,
    later: void 0
  };
  setLaterFunc(ctx);
  setWrapperFunc(ctx);
  return ctx.wrapperFn;
};
var backupListener = function backupListener2(_ref) {
  var _vm = _ref._vm, throttledResizeHandler = _ref.throttledResizeHandler, zoomEndHandler = _ref.zoomEndHandler;
  _vm._oldZoomEndHandler = zoomEndHandler;
  _vm._oldResizeHandler = throttledResizeHandler;
};
var addListener = function addListener2(_ref2) {
  var aMapModel = _ref2.aMapModel, amap = _ref2.amap, throttledResizeHandler = _ref2.throttledResizeHandler, zoomEndHandler = _ref2.zoomEndHandler;
  amap.on("zoomend", zoomEndHandler);
  amap.on("moveend", zoomEndHandler);
  amap.on("complete", zoomEndHandler);
  aMapModel.get("resizeEnable") && amap.on("resize", throttledResizeHandler);
};
var removeListener = function removeListener2(_ref3) {
  var _vm = _ref3._vm, aMapModel = _ref3.aMapModel, amap = _ref3.amap;
  amap.off("zoomend", _vm._oldZoomEndHandler);
  amap.off("moveend", _vm._oldZoomEndHandler);
  amap.off("complete", _vm._oldZoomEndHandler);
  aMapModel.get("resizeEnable") && amap.off("resize", _vm._oldResizeHandler);
};
var getResizeHandler = function getResizeHandler2(_ref4) {
  var _vm = _ref4._vm, api = _ref4.api, moveHandler = _ref4.moveHandler;
  return function(e) {
    echarts.getInstanceByDom(api.getDom()).resize();
    moveHandler.call(_vm, e);
  };
};
var getZoomEndHandler = function getZoomEndHandler2(_ref5) {
  var api = _ref5.api, rendering = _ref5.rendering;
  return function() {
    if (rendering) {
      return;
    }
    api.dispatchAction({
      type: "amapRoam"
    });
  };
};
var getMoveHandler = function getMoveHandler2(_ref6) {
  var aMapModel = _ref6.aMapModel, api = _ref6.api, coordSys = _ref6.coordSys, rendering = _ref6.rendering, viewportRoot = _ref6.viewportRoot;
  return function() {
    if (rendering) {
      return;
    }
    var offsetEl = viewportRoot.parentNode.parentNode.parentNode;
    var mapOffset = [-parseInt(offsetEl.style.left, 10) || 0, -parseInt(offsetEl.style.top, 10) || 0];
    aMapModel.__mapOffset = mapOffset;
    coordSys.setMapOffset(mapOffset);
    viewportRoot.style.left = mapOffset[0] + "px";
    viewportRoot.style.top = mapOffset[1] + "px";
    api.dispatchAction({
      type: "amapRoam"
    });
  };
};
function extendComponentView() {
  echarts.extendComponentView({
    type: "amap",
    render: function render(aMapModel, ecModel, api) {
      var rendering = true;
      var amap = aMapModel.getAMap();
      var viewportRoot = api.getZr().painter.getViewportRoot();
      var coordSys = aMapModel.coordinateSystem;
      var moveHandler = getMoveHandler({
        aMapModel,
        api,
        coordSys,
        rendering,
        viewportRoot
      });
      var zoomEndHandler = getZoomEndHandler({
        api,
        rendering
      });
      var resizeHandler = getResizeHandler({
        _vm: this,
        api,
        moveHandler
      });
      var throttledResizeHandler = throttle(resizeHandler, 300, amap);
      removeListener({
        _vm: this,
        aMapModel,
        amap
      });
      addListener({
        aMapModel,
        amap,
        throttledResizeHandler,
        zoomEndHandler
      });
      backupListener({
        _vm: this,
        throttledResizeHandler,
        zoomEndHandler
      });
      rendering = false;
    }
  });
}
function registerAmap() {
  echarts.registerCoordinateSystem("amap", AMapCoordSys);
  extendComponentModel();
  extendComponentView();
  echarts.registerAction({
    type: "amapRoam",
    event: "amapRoam",
    update: "updateLayout"
  }, function(payload, ecModel) {
    ecModel.eachComponent("amap", function(aMapModel) {
      var amap = aMapModel.getAMap();
      var center = amap.getCenter();
      aMapModel.setCenterAndZoom([center.lng, center.lat], amap.getZoom());
    });
  });
}
var _sfc_main = {
  name: $prefix + "ChartAutonaviMap",
  mixins: [Core],
  data: function data() {
    return {
      iChartName: "AutonaviMapChart"
    };
  },
  mounted: function mounted() {
    registerAmap();
  },
  methods: {
    updateChart: function updateChart() {
      var _this = this;
      if (this.options && Object.keys(this.options).length) {
        this.huiChartOption = _extends({}, this.options, this.settings);
        if (!this.tooltipVisible) {
          this.huiChartOption.tooltip = {
            show: false
          };
        }
        if (!this.legendVisible) {
          this.huiChartOption.legend = {
            show: false
          };
        }
        return;
      }
      var echartsSettings = ["grid", "dataZoom", "visualMap", "toolbox", "title", "legend", "xAxis", "yAxis", "radar", "axisPointer", "brush", "geo", "timeline", "graphic", "backgroundColor", "textStyle"];
      this.huiChartOption = _extends({}, this.settings, {
        tooltip: this.tooltipVisible ? this.tooltip : {
          show: false
        },
        series: this.series
      });
      echartsSettings.forEach(function(prop) {
        if (_this[prop]) {
          _this.huiChartOption[prop] = _this[prop];
        }
      });
      if (!this.legendVisible) {
        this.huiChartOption.legend = {
          show: false
        };
      }
    }
  }
};
var _hoisted_1 = {
  class: "hui-chart chart-box"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1, [createElementVNode(
    "div",
    {
      ref: "chartRef",
      style: normalizeStyle({
        width: _ctx.width,
        height: _ctx.height
      })
    },
    null,
    4
    /* STYLE */
  ), renderSlot(_ctx.$slots, "default")]);
}
var AutonaviMap = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
AutonaviMap.install = function(Vue) {
  Vue.component(AutonaviMap.name, AutonaviMap);
};

export { AutonaviMap, AutonaviMap as default };

"use strict";
Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
const Quill = require("quill");
const Delta = Quill.import("delta");
const Tooltip = Quill.import("ui/tooltip");
const _MathliveTooltip = class _MathliveTooltip extends Tooltip {
  constructor(quill, boundsContainer) {
    super(quill, boundsContainer);
    this.mathliveDom = document.createElement("math-field");
    this.mathliveDom.classList.add("ql-math-field");
    this.root.appendChild(this.mathliveDom);
    this.root.classList.add("math-field-tooltip");
    this.listen();
  }
  listen() {
    this.mathliveDom.addEventListener("blur", (event) => {
      this.hide();
    });
    this.root.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        this.save();
      } else if (event.key === "Escape") {
        event.preventDefault();
        this.cancel();
      }
    });
  }
  cancel() {
    this.hide();
    this.restoreFocus();
  }
  edit(value) {
    this.editValue = value;
    this.root.classList.remove("ql-hidden");
    this.root.classList.add("ql-editing");
    this.mathliveDom.setValue(value || "");
    const range = this.quill.getSelection();
    const bounds = range ? this.quill.getBounds(range) : null;
    if (bounds != null) {
      this.position(bounds);
    }
    this.show();
    this.mathliveDom.focus();
  }
  restoreFocus() {
    this.mathliveDom.blur();
    this.quill.focus({ preventScroll: true });
  }
  save() {
    const range = this.quill.getSelection(true);
    const inputValue = this.mathliveDom.value;
    if (!inputValue) return;
    const index = range ? range.index : this.quill.getLength() - 1;
    const delta = new Delta().retain(index).delete(this.editValue ? 1 : (range == null ? void 0 : range.length) || 0).insert({ mathlive: { value: inputValue, mode: "dialog" } });
    this.quill.updateContents(delta, Quill.sources.USER);
    this.quill.setSelection(index + 1, Quill.sources.SILENT);
    this.hide();
  }
  position(reference) {
    const adjustedReference = { ...reference };
    adjustedReference.left = reference.left + this.root.offsetWidth / 2 - reference.width / 2;
    return super.position(adjustedReference);
  }
};
_MathliveTooltip.TEMPLATE = ``;
let MathliveTooltip = _MathliveTooltip;
exports.default = MathliveTooltip;
//# sourceMappingURL=tooltip.cjs.js.map

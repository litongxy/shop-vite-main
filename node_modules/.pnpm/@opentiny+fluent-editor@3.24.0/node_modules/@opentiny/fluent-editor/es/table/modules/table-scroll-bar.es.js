import { SCROLL_BAR_PANEL_HEIGHT } from "../table-config.es.js";
import { css } from "../utils/index.es.js";
class TableScrollBar {
  // 表格是否溢出开关，判断开关值后只改变样式一次，不重复修改
  constructor(table, quill, dom) {
    if (!table) {
      return;
    }
    this.table = table;
    this.quill = quill;
    this.modulesContainer = dom;
    this.domNode = null;
    this.oldRootScrollTop = this.quill.root.scrollTop;
    this.prev = 0;
    const betterTableModule = this.quill.getModule("better-table");
    const tableColumnTool = betterTableModule.columnTool;
    this.columnToolDomNode = tableColumnTool.domNode;
    this.columnCtrlPanel = tableColumnTool.columnCtrlPanel;
    this.leftMask = tableColumnTool.leftMask;
    this.updateScrollBar();
    if (this.quill.root === this.quill.scrollingContainer) {
      this.quill.root.addEventListener("scroll", this.handleQuillRootScroll.bind(this));
    }
  }
  handleQuillRootScroll() {
    if (!this.domNode) {
      return;
    }
    const curTableRect = this.table.getBoundingClientRect();
    const curContainerRect = this.quill.root.parentNode.getBoundingClientRect();
    const tableTop = curTableRect.top + SCROLL_BAR_PANEL_HEIGHT;
    const tableBottom = curTableRect.top + curTableRect.height - 1;
    const containerBottom = curContainerRect.top + curContainerRect.height;
    if (containerBottom < tableBottom && containerBottom > tableTop) {
      if (!this.isTableOverflow) {
        this.isTableOverflow = true;
        css(this.domNode, {
          display: "block",
          top: `${this.containerRect.height - SCROLL_BAR_PANEL_HEIGHT}px`,
          marginTop: "0px"
        });
      }
    } else if (containerBottom <= tableTop) {
      this.isTableOverflow = false;
      this.domNode.style.display = "none";
    } else {
      this.setScrollBarToBottom();
      css(this.domNode, { marginTop: `${this.oldRootScrollTop - this.quill.root.scrollTop}px` });
    }
  }
  setScrollBarToBottom() {
    if (this.isTableOverflow) {
      this.isTableOverflow = false;
      const barPos = this.tableRect.top + this.tableRect.height - this.containerRect.top - 1;
      css(this.domNode, { display: "block", top: `${barPos}px` });
    }
  }
  resetTableHeight(table) {
    if (this.domNode) {
      this.tableRect.height = table.getBoundingClientRect().height;
      this.isTableOverflow = !this.isTableOverflow;
      this.handleQuillRootScroll();
    }
  }
  setScrollBarMove(pos, isMouse) {
    const currentBarLeft = Number.parseInt(getComputedStyle(this.scrollBar).left, 10);
    let left = isMouse ? pos - this.prev + currentBarLeft : currentBarLeft + pos;
    this.showMask(left);
    left = this.getLimitedDistance(left);
    const scale = this.tableViewRect.width / this.tableRect.width;
    const move = left / scale;
    const columnCtrlPanelLeft = this.tableViewRect.left - this.containerRect.left - move;
    css(this.scrollBar, { left: `${left}px` });
    css(this.columnCtrlPanel, { left: `${columnCtrlPanelLeft}px` });
    this.table.parentNode.scrollLeft = move;
    if (isMouse) {
      this.prev = pos;
    }
    const tableSelection = this.quill.getModule("better-table").tableSelection;
    if (tableSelection && tableSelection.selectedTds.length) {
      tableSelection.refreshHelpLinesPosition();
    }
  }
  handleScrollBarMouseDown(mouseDownEvent) {
    mouseDownEvent.preventDefault();
    this.prev = mouseDownEvent.clientX;
    this.subscriber = (mouseMoveEvent) => {
      mouseMoveEvent.preventDefault();
      mouseMoveEvent.stopPropagation();
      this.setScrollBarMove(mouseMoveEvent.clientX, true);
    };
    this.quill.root.parentNode.addEventListener("mousemove", this.subscriber, false);
    document.addEventListener("mouseup", this.handleScrollBarMouseup.bind(this), false);
  }
  handleScrollBarMouseup(event) {
    event.preventDefault();
    this.quill.root.parentNode.removeEventListener("mousemove", this.subscriber);
    document.removeEventListener("mouseup", this.handleScrollBarMouseup.bind(this), false);
  }
  handleWheel(event) {
    if (event.shiftKey) {
      const { deltaY } = event;
      this.setScrollBarMove(deltaY, false);
    }
  }
  showMask(distance) {
    if (distance >= Math.floor(this.maxBarLeft)) {
      css(this.leftMask, { display: "block" });
    } else if (distance <= 0) {
      css(this.leftMask, { display: "none" });
    } else {
      css(this.leftMask, { display: "block" });
    }
  }
  getLimitedDistance(distance) {
    if (distance >= Math.floor(this.maxBarLeft)) {
      distance = this.maxBarLeft;
    } else if (distance <= 0) {
      distance = 0;
    }
    return distance;
  }
  updateScrollBar() {
    var _a;
    if (!((_a = this.table) == null ? void 0 : _a.parentNode)) {
      return;
    }
    const tableRect = this.table.getBoundingClientRect();
    const tableViewRect = this.table.parentNode.getBoundingClientRect();
    const tableMoveDistance = tableRect.width - tableViewRect.width;
    this.tableRect = tableRect;
    this.tableViewRect = tableViewRect;
    this.tableMoveDistance = tableMoveDistance;
    this.oldRootScrollTop = this.quill.root.scrollTop;
    if (tableMoveDistance > 0) {
      this.createScrollBar();
    } else {
      this.destroyScrollBar();
    }
  }
  createScrollBar() {
    const parent = this.quill.root.parentNode;
    const containerRect = parent.getBoundingClientRect();
    this.containerRect = containerRect;
    css(this.columnCtrlPanel, {
      left: `${this.tableViewRect.left - containerRect.left - this.table.parentNode.scrollLeft}px`
    });
    if (this.domNode) {
      this.domNode.remove();
    }
    this.domNode = document.createElement("div");
    this.domNode.classList.add("qlbt-table-scroll-bar-panel");
    this.scrollBar = document.createElement("div");
    this.scrollBar.classList.add("qlbt-table-scroll-bar");
    this.scrollBar.addEventListener("mousedown", this.handleScrollBarMouseDown.bind(this), false);
    const scale = this.tableViewRect.width / this.tableRect.width;
    const barWidth = this.tableViewRect.width - this.tableMoveDistance * scale;
    css(this.scrollBar, { width: `${barWidth}px` });
    this.domNode.appendChild(this.scrollBar);
    const tableScrollLeft = this.table.parentNode.scrollLeft;
    this.maxBarLeft = this.tableMoveDistance * scale;
    if (tableScrollLeft) {
      const barLeft = tableScrollLeft * scale;
      this.showMask(barLeft);
      css(this.scrollBar, { left: `${this.getLimitedDistance(barLeft)}px` });
    }
    const barPos = this.tableRect.top + this.tableRect.height - containerRect.top - 1;
    this.isTableOverflow = containerRect.top + containerRect.height < this.tableRect.top + this.tableRect.height;
    this.modulesContainer.appendChild(this.domNode);
    css(this.domNode, { top: `${Math.min(containerRect.height - SCROLL_BAR_PANEL_HEIGHT, barPos)}px` });
    document.addEventListener("wheel", this.handleWheel.bind(this));
  }
  destroyScrollBar() {
    css(this.leftMask, { display: "none" });
    this.columnCtrlPanel.removeAttribute("style");
    this.maxBarLeft = null;
    this.destroy();
  }
  destroy() {
    if (this.domNode) {
      this.domNode.remove();
    }
    this.quill.root.removeEventListener("scroll", this.handleQuillRootScroll.bind(this));
    document.removeEventListener("wheel", this.handleWheel.bind(this));
  }
}
export {
  TableScrollBar as default
};
//# sourceMappingURL=table-scroll-bar.es.js.map

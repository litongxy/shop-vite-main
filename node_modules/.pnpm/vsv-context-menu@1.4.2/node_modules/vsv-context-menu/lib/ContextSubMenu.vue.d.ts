import { PropType, Ref } from 'vue';
import { MenuOptions, MenuItem, MenuPopDirection, MenuItemContext } from './ContextMenuDefine';
import { GlobalHasSlot, GlobalRenderSlot } from './ContextMenu.vue';
import { solveNumberOrStringSize } from './ContextMenuUtils';

export interface SubMenuContext {
    isTopLevel: () => boolean;
    closeSelfAndActiveParent: () => boolean;
    openCurrentItemSubMenu: () => boolean;
    closeCurrentSubMenu: () => void;
    moveCurrentItemFirst: () => void;
    moveCurrentItemLast: () => void;
    moveCurrentItemDown: () => void;
    moveCurrentItemUp: () => void;
    focusCurrentItem: () => void;
    triggerCurrentItemClick: (e: KeyboardEvent | MouseEvent) => void;
}
export interface SubMenuParentContext {
    container: HTMLElement;
    zIndex: number;
    adjustPadding: {
        x: number;
        y: number;
    };
    getParentWidth: () => number;
    getParentHeight: () => number;
    getParentX: () => number;
    getParentY: () => number;
    getParentAbsX: () => number;
    getParentAbsY: () => number;
    getPositon: () => [number, number];
    getZoom: () => number;
    addOpenedSubMenu: (closeFn: () => void) => void;
    closeOtherSubMenu: () => void;
    closeOtherSubMenuWithTimeOut: () => void;
    checkCloseOtherSubMenuTimeOut: () => boolean;
    addChildMenuItem: (item: MenuItemContext, index?: number) => void;
    removeChildMenuItem: (item: MenuItemContext) => void;
    markActiveMenuItem: (item: MenuItemContext, updateState?: boolean) => void;
    markThisOpenedByKeyBoard: () => void;
    isOpenedByKeyBoardFlag: () => boolean;
    isMenuItemDataCollectedFlag: () => boolean;
    getSubMenuInstanceContext: () => SubMenuContext | null;
    getParentContext: () => SubMenuParentContext | null;
    getElement: () => HTMLElement | null;
}
/**
 * Submenu container
 */
declare const _default: import('vue').DefineComponent<{
    /**
     * Items from options
     */
    items: {
        type: PropType<MenuItem[]>;
        default: null;
    };
    /**
     * Max width for this submenu
     */
    maxWidth: {
        type: (StringConstructor | NumberConstructor)[];
        default: number;
    };
    /**
     * Min width for this submenu
     */
    minWidth: {
        type: (StringConstructor | NumberConstructor)[];
        default: number;
    };
    /**
     * Specifies should submenu adjust it position
     * when the menu exceeds the screen. The default is true
     */
    adjustPosition: {
        type: BooleanConstructor;
        default: boolean;
    };
    /**
     * Menu direction
     */
    direction: {
        type: PropType<MenuPopDirection>;
        default: string;
    };
}, {
    globalHasSlot: GlobalHasSlot;
    globalRenderSlot: GlobalRenderSlot;
    onScroll: (down: boolean) => void;
    onSubMenuBodyClick: () => void;
    onMouseWhell: (e: WheelEvent) => void;
    onMouseWhellMx: (e: WheelEvent) => void;
    solveNumberOrStringSize: typeof solveNumberOrStringSize;
    getSubmenuRoot: () => HTMLElement | undefined;
    getMenu: () => HTMLElement | undefined;
    getChildItem: (index: number) => MenuItemContext | undefined;
    getMenuDimensions(): {
        width: number;
        height: number;
    };
    getScrollValue: () => number;
    setScrollValue: (v: number) => void;
    getScrollHeight: () => number;
    getMaxHeight: () => number;
    getPosition: () => {
        x: number;
        y: number;
    };
    setPosition: (x: number, y: number) => void;
    submenuRoot: Ref<HTMLElement | undefined>;
    menu: Ref<HTMLElement | undefined>;
    scroll: Ref<HTMLElement | undefined>;
    options: Ref<MenuOptions>;
    zIndex: number;
    constOptions: {
        defaultDirection: string;
        defaultMinWidth: number;
        defaultMaxWidth: number;
        defaultZindex: number;
        defaultZoom: number;
        defaultAdjustPadding: {
            x: number;
            y: number;
        };
    };
    scrollValue: Ref<number>;
    upScrollButton: Ref<HTMLElement | undefined>;
    overflow: Ref<boolean>;
    position: Ref<{
        x: number;
        y: number;
    }>;
    scrollHeight: Ref<number>;
    maxHeight: Ref<number>;
}, unknown, {}, {}, import('vue').ComponentOptionsMixin, import('vue').ComponentOptionsMixin, {}, string, import('vue').PublicProps, Readonly<import('vue').ExtractPropTypes<{
    /**
     * Items from options
     */
    items: {
        type: PropType<MenuItem[]>;
        default: null;
    };
    /**
     * Max width for this submenu
     */
    maxWidth: {
        type: (StringConstructor | NumberConstructor)[];
        default: number;
    };
    /**
     * Min width for this submenu
     */
    minWidth: {
        type: (StringConstructor | NumberConstructor)[];
        default: number;
    };
    /**
     * Specifies should submenu adjust it position
     * when the menu exceeds the screen. The default is true
     */
    adjustPosition: {
        type: BooleanConstructor;
        default: boolean;
    };
    /**
     * Menu direction
     */
    direction: {
        type: PropType<MenuPopDirection>;
        default: string;
    };
}>>, {
    direction: MenuPopDirection;
    maxWidth: string | number;
    minWidth: string | number;
    items: MenuItem[];
    adjustPosition: boolean;
}, {}>;
export default _default;

import hooks from './adapter';
import { appProperties, getElementStatusClass } from './adapter';
import { defineAsyncComponent, directive, emitter, h, Teleport, KeepAlive } from './adapter';
import { parseVnode, isEmptyVnode, useRouter, isVnode } from './adapter';
import { stringifyCssClass, stringifyCssClassObject, stringifyCssClassArray, deduplicateCssClass } from './csscls';
import { defineComponent, isVue2, isVue3 } from './adapter';
import { useBreakpoint } from './breakpoint';
import { useDefer } from './usedefer';
export declare const useInstanceSlots: () => void;
export declare const useRelation: ({ relationKey, relationContainer, onChange, childrenKey, delivery }?: {
    relationKey: any;
    relationContainer: any;
    onChange: any;
    childrenKey: any;
    delivery: any;
}) => {
    children: any;
    index: any;
    delivery: any;
};
export { stringifyCssClass, stringifyCssClassObject, stringifyCssClassArray, deduplicateCssClass };
export { useBreakpoint, useDefer };
export { version } from '../package.json';
export { defineComponent, isVue2, isVue3, appProperties };
export declare const $prefix = "Tiny";
export declare const $props: {
    tiny_mode: StringConstructor;
    tiny_mode_root: BooleanConstructor;
    tiny_template: (ObjectConstructor | FunctionConstructor)[];
    tiny_renderless: FunctionConstructor;
    tiny_theme: StringConstructor;
    tiny_chart_theme: ObjectConstructor;
};
export declare const props: Array<'tiny_mode' | 'tiny_mode_root' | 'tiny_template' | 'tiny_renderless' | '_constants' | 'tiny_theme' | 'tiny_chart_theme'>;
export declare const resolveMode: (props: any, context: any) => any;
export declare const resolveTheme: (props: any, context: any) => any;
export declare const $setup: ({ props, context, template, extend }: {
    props: any;
    context: any;
    template: any;
    extend?: {} | undefined;
}) => () => hooks.VNode<hooks.RendererNode, hooks.RendererElement, {
    [key: string]: any;
}>;
export declare const design: {
    configKey: symbol;
    configInstance: null;
};
export declare const provideDesignConfig: (designConfig: any) => void;
declare const createComponent: ({ component, propsData, el }: {
    component: any;
    propsData: any;
    el: any;
}) => any;
interface DesignConfig {
    components?: any;
    name?: string;
    version?: string;
}
interface CustomDesignConfig {
    designConfig: null | DesignConfig;
    twMerge: (str: string) => string;
}
export declare const customDesignConfig: CustomDesignConfig;
export declare const mergeClass: (...cssClasses: any[]) => string;
export declare const setup: ({ props, context, renderless, api, extendOptions, mono, classes }: {
    props: any;
    context: any;
    renderless: any;
    api: any;
    extendOptions?: {} | undefined;
    mono?: boolean | undefined;
    classes?: {} | undefined;
}) => {
    t: (this: any, path: any, options?: any) => any;
    vm: any;
    f: (props: any, attrs?: {}) => {};
    a: (attrs: any, filters: any, include: any) => {};
    d: (props: any) => void;
    dp: (props: any) => void;
    gcls: (key: any) => any;
    m: (...cssClasses: any[]) => string;
};
export declare function svg({ name, component }: {
    name?: string | undefined;
    component: any;
}): (propData?: any) => hooks.Raw<hooks.DefineComponent<{}, () => hooks.VNode<hooks.RendererNode, hooks.RendererElement, {
    [key: string]: any;
}>, {}, {}, {}, hooks.ComponentOptionsMixin, hooks.ComponentOptionsMixin, {}, string, hooks.PublicProps, Readonly<hooks.ExtractPropTypes<{}>>, {}, {}>>;
/**
 * 将用户传入的 $attrs中的属性， 与 filters 中传入的属性做对比。
 * 如果include ,  且属性在filters中， 则返回。
 * 如果 !include, 且属性不匹配filters， 则返回。
 * 在模板中，都是通过 v-bind="a($attrs,[])" 来使用该函数 。
 * @mark 由于现在组件都移除了 inheritAttrs。 加在外层的 v-bind="a()"" 都可以去掉了， 否则会出现双份效果。
 *
 * @param attrs : Object
 * @param filters : string[]
 * @param include : boolean
 *
 * @example Button-pc中： v-bind="a($attrs, ['class', 'style', 'title', 'id'], true)"
 * @exampleResult 把用户使用<tiny-button ...id\class> 等属性，会传递给该位置的dom。
 *
 * @example Area-pc中： v-bind="a($attrs, ['^on[A-Z]'])"
 * @exampleResult 把用户使用<tiny-area ...on> 等事件, 不会传递给内部的select上， 但是class,style等，会传递给select上。
 */
export declare const filterAttrs: (attrs: any, filters: any, include: any) => {};
export declare let setupComponent: {};
export declare const initComponent: () => void;
export declare const $install: (component: any) => void;
export type { PropType, ExtractPropTypes, DefineComponent, ComponentPublicInstance, SetupContext, ComputedRef } from './adapter';
export { h, hooks, directive, parseVnode, isEmptyVnode, useRouter, emitter, createComponent, defineAsyncComponent, getElementStatusClass, Teleport, KeepAlive, isVnode };
declare const _default: {
    h: (component: any, propsData?: any, childData?: any) => hooks.VNode<hooks.RendererNode, hooks.RendererElement, {
        [key: string]: any;
    }>;
    directive: (directives: any) => any;
    parseVnode: (vnode: any) => any;
    isEmptyVnode: (vnode: any) => boolean;
    useRouter: (instance?: hooks.ComponentInternalInstance | null) => {
        route: any;
        router: any;
    };
    emitter: () => {
        emit(eventName: any): void;
        on: (event: any, callback: any, once?: boolean) => void;
        once(event: any, callback: any): void;
        off(event: any, callback: any): void;
    };
    createComponent: ({ component, propsData, el }: {
        component: any;
        propsData: any;
        el: any;
    }) => any;
    defineAsyncComponent: typeof hooks.defineAsyncComponent;
    filterAttrs: (attrs: any, filters: any, include: any) => {};
    initComponent: () => void;
    setupComponent: {};
    svg: typeof svg;
    $prefix: string;
    $props: {
        tiny_mode: StringConstructor;
        tiny_mode_root: BooleanConstructor;
        tiny_template: (ObjectConstructor | FunctionConstructor)[];
        tiny_renderless: FunctionConstructor;
        tiny_theme: StringConstructor;
        tiny_chart_theme: ObjectConstructor;
    };
    props: ("tiny_mode" | "tiny_mode_root" | "tiny_template" | "tiny_renderless" | "_constants" | "tiny_theme" | "tiny_chart_theme")[];
    $setup: ({ props, context, template, extend }: {
        props: any;
        context: any;
        template: any;
        extend?: {} | undefined;
    }) => () => hooks.VNode<hooks.RendererNode, hooks.RendererElement, {
        [key: string]: any;
    }>;
    setup: ({ props, context, renderless, api, extendOptions, mono, classes }: {
        props: any;
        context: any;
        renderless: any;
        api: any;
        extendOptions?: {} | undefined;
        mono?: boolean | undefined;
        classes?: {} | undefined;
    }) => {
        t: (this: any, path: any, options?: any) => any;
        vm: any;
        f: (props: any, attrs?: {}) => {};
        a: (attrs: any, filters: any, include: any) => {};
        d: (props: any) => void;
        dp: (props: any) => void;
        gcls: (key: any) => any;
        m: (...cssClasses: any[]) => string;
    };
    hooks: typeof hooks;
    getElementStatusClass: (className: any, status: any) => string | undefined;
    $install: (component: any) => void;
    isVnode: typeof hooks.isVNode;
};
export default _default;

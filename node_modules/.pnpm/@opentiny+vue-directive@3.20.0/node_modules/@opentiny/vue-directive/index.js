import Tooltip from "@opentiny/vue-tooltip";
import { hooks, createComponent, h } from "@opentiny/vue-common";
var MISTAKE_VALUE = 2;
var globalTooltip = {
  value: null
};
var tooltipContent = hooks.ref("");
var isEllipsis = function isEllipsis2(currentTarget) {
  return (currentTarget == null ? void 0 : currentTarget.textContent) && (currentTarget.scrollWidth > currentTarget.clientWidth || currentTarget.scrollHeight - currentTarget.clientHeight > MISTAKE_VALUE);
};
var isAlwaysShowTip = function isAlwaysShowTip2(currentTarget) {
  var _currentTarget$boundi;
  return Boolean(currentTarget == null ? void 0 : (_currentTarget$boundi = currentTarget.boundingValue) == null ? void 0 : _currentTarget$boundi.always);
};
var isDarkTheme = function isDarkTheme2(currentTarget) {
  var _currentTarget$boundi2;
  return Boolean((currentTarget == null ? void 0 : (_currentTarget$boundi2 = currentTarget.boundingValue) == null ? void 0 : _currentTarget$boundi2.effect) === "dark");
};
var getPlacement = function getPlacement2(currentTarget) {
  var _currentTarget$boundi3;
  return ((_currentTarget$boundi3 = currentTarget.boundingValue) == null ? void 0 : _currentTarget$boundi3.placement) || "top";
};
var mouseenterHandler = function mouseenterHandler2(e) {
  var currentTarget = e.currentTarget;
  if (!currentTarget.boundingValue) {
    return;
  }
  if (isAlwaysShowTip(currentTarget) || isEllipsis(currentTarget)) {
    var _currentTarget$boundi5, _tooltip$state$popper;
    if (!globalTooltip.value) {
      var _currentTarget$boundi4;
      tooltipContent.value = ((_currentTarget$boundi4 = currentTarget.boundingValue) == null ? void 0 : _currentTarget$boundi4.content) || currentTarget.textContent;
      globalTooltip.value = createComponent({
        el: document.createElement("div"),
        propsData: {
          renderContent: function renderContent() {
            return h("span", {
              class: "tiny-directive-tip__content"
            }, tooltipContent.value);
          },
          placement: getPlacement(currentTarget),
          effect: isDarkTheme(currentTarget) ? "dark" : "light"
        },
        component: Tooltip
      });
    }
    var tooltip = globalTooltip.value;
    var popperElm = tooltip.state.popperElm;
    tooltipContent.value = ((_currentTarget$boundi5 = currentTarget.boundingValue) == null ? void 0 : _currentTarget$boundi5.content) || currentTarget.textContent;
    tooltip.state.referenceElm = currentTarget;
    tooltip.state.currentPlacement = getPlacement(currentTarget);
    if (popperElm) {
      popperElm.classList.replace("is-" + (isDarkTheme(currentTarget) ? "light" : "dark"), "is-" + (isDarkTheme(currentTarget) ? "dark" : "light"));
    }
    tooltip.show();
    if ((_tooltip$state$popper = tooltip.state.popperJS) != null && _tooltip$state$popper._options) {
      tooltip.state.popperJS._options.placement = getPlacement(currentTarget);
    }
    tooltip.updatePopper();
  }
};
var mouseleaveHandler = function mouseleaveHandler2() {
  globalTooltip.value && globalTooltip.value.hide();
};
var bind = function bind2(el, _ref) {
  var _el$boundingValue;
  var value = _ref.value;
  var resultValue = value === void 0 ? {} : value;
  el.boundingValue = resultValue;
  if (resultValue && !((_el$boundingValue = el.boundingValue) != null && _el$boundingValue.listened)) {
    el.addEventListener("mouseenter", mouseenterHandler);
    el.addEventListener("mouseleave", mouseleaveHandler);
    el.boundingValue.listened = true;
  }
};
var unbind = function unbind2(el) {
  var _el$boundingValue2;
  if ((_el$boundingValue2 = el.boundingValue) != null && _el$boundingValue2.listened) {
    el.removeEventListener("mouseenter", mouseenterHandler);
    el.removeEventListener("mouseleave", mouseleaveHandler);
  }
};
var autoTip = {
  bind,
  unbind,
  update: bind,
  beforeMount: bind,
  unmounted: unbind,
  updated: bind
};
function walk(el, filter) {
  var walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT);
  var matchNodes = [];
  while (walker.nextNode()) {
    var node = walker.currentNode;
    filter(node) && matchNodes.push(node);
  }
  return matchNodes;
}
function editNodes(el, nodes, query) {
  nodes.forEach(function(node) {
    var content = node.textContent;
    var start = content.toLowerCase().indexOf(query.toLowerCase());
    var startText = content.substring(0, start);
    var endText = content.substring(start + query.length);
    node.textContent = startText;
    var span = document.createElement("span");
    span.classList.add("tiny-hl-query-node");
    span.textContent = query;
    var end = document.createTextNode(endText);
    node.after(span, end);
  });
  if (nodes.length) {
    edit(el, query);
  }
}
function restoreNodes(nodes) {
  var parents = /* @__PURE__ */ new Set();
  nodes.forEach(function(node) {
    var _node$parentElement;
    return parents.add((_node$parentElement = node.parentElement) == null ? void 0 : _node$parentElement.parentElement);
  });
  parents.forEach(function(node) {
    node.innerText = node.textContent;
  });
}
function edit(el, query) {
  if (query) {
    var matchNodes = walk(el, function(node) {
      if (node.parentElement.classList.contains("tiny-hl-query-node")) {
        return false;
      }
      var content = node.textContent || "";
      return content.toLowerCase().includes(query.toLowerCase());
    });
    editNodes(el, matchNodes, query);
  }
}
function restore(el) {
  var matchNodes = walk(el, function(node) {
    return node.parentElement.classList.contains("tiny-hl-query-node");
  });
  restoreNodes(matchNodes);
}
var mounted = function mounted2(el, binding) {
  el.classList.toggle("tiny-hl-query", true);
  var query = binding.value;
  edit(el, query);
};
var beforeUpdate = function beforeUpdate2(el) {
  restore(el);
};
var updated = function updated2(el, binding) {
  var query = binding.value;
  edit(el, query);
};
var highlightQuery = {
  mounted,
  beforeUpdate,
  updated,
  // vue2周期
  inserted: mounted,
  update: beforeUpdate,
  componentUpdated: updated
};
export {
  autoTip as AutoTip,
  highlightQuery as HighlightQuery
};

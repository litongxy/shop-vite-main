import { defineComponent, props, directive, setup, emitter, h, isVue3, $prefix, $props, $setup } from '@opentiny/vue-common';
import { renderless, api } from '@opentiny/vue-renderless/flowchart/vue';
import Clickoutside from '@opentiny/vue-renderless/common/deps/clickoutside';
import { IconYes, IconClose, iconNotStartedMini, iconNotStarted, iconOnGoingMini, iconOnGoing, iconExceptionMiniO, iconExceptionO, iconDoneMini, iconDone } from '@opentiny/vue-icon';
import Popover from '@opentiny/vue-popover';
import { renderless as renderless$1, api as api$1 } from '@opentiny/vue-renderless/flowchart/node';
import { openBlock, createElementBlock, normalizeClass, normalizeStyle, createElementVNode, createBlock, resolveDynamicComponent, Fragment, renderList, toDisplayString, createCommentVNode } from 'vue';
import ResizeObserver from '@opentiny/vue-renderless/common/deps/ResizeObserver';
import '@opentiny/vue-theme/flowchart/index.css';

var _sfc_main$2 = defineComponent({
  emits: ["click-node", "click-link", "click-blank"],
  props: [].concat(props, ["data", "config"]),
  directives: directive({
    Clickoutside
  }),
  setup: function setup$1(props2, context) {
    return setup({
      props: props2,
      context,
      renderless,
      api,
      extendOptions: {
        emitter
      }
    });
  },
  render: function render() {
    var slots = this.slots, state = this.state, clearHoverAfterLink = this.clearHoverAfterLink, clickNode = this.clickNode, config = this.config, getVars = this.getVars, omitText = this.omitText;
    var afterData = state.afterData, dropdowns = state.dropdowns, refreshKey = state.refreshKey, wrapperStyle = state.wrapperStyle;
    var afterNodes = afterData.afterNodes, allItem = afterData.allItem;
    var nodes = afterNodes.map(function(afterNode) {
      var ret = getVars(afterNode, config);
      var background = ret.background, borderColor = ret.borderColor, half = ret.half, isCompleteFn = ret.isCompleteFn, isFailFn = ret.isFailFn, isOngoingFn = ret.isOngoingFn, statusName = ret.statusName, white = ret.white;
      var halfIconWrapperSize = half(config.iconWrapperSize);
      var wrapperStyle2 = "left:" + afterNode.x + "px;top:" + afterNode.y + "px;width:" + config.iconWrapperSize + "px;height:" + config.iconWrapperSize + "px;transform:translate(-" + halfIconWrapperSize + "px,-" + halfIconWrapperSize + "px);background:" + config.background + ";";
      var halfIconSize = half(config.iconSize);
      var iconWrapperPadding = halfIconWrapperSize - halfIconSize;
      var iconStyle = "width:" + config.iconSize + "px;height:" + config.iconSize + "px;border-radius:" + halfIconSize + "px;border-color:" + borderColor + ";transform:translate(" + iconWrapperPadding + "px," + iconWrapperPadding + "px);background:" + background + ";";
      var svgFill = isCompleteFn() ? borderColor : isFailFn() ? white : "";
      var svgStyle = "font-size:" + config.iconSvgSize + "px;fill:" + svgFill + ";";
      var iconComp = isCompleteFn() ? IconYes() : isFailFn() ? IconClose() : null;
      var labelWidth = config.labelWidth || afterData.widths[1] - config.labelSpacing;
      var labelHeight = config.labelHeight || afterData.heights[1] - config.labelSpacing;
      var halfLabelWidth = half(labelWidth);
      var labelTransform = config.anchor === "center" ? "translateX(" + (halfIconWrapperSize - halfLabelWidth) + "px)" : "";
      var labelStyle = "width:" + labelWidth + "px;height:" + labelHeight + "px;transform:" + labelTransform + ";";
      var baseStyle = "text-align:" + (config.anchor === "center" ? "center" : "left") + ";";
      var titleStyle = baseStyle + ("color:" + (isOngoingFn() ? config.colors[config.statusOngoing] : "") + ";");
      var dateStyle = baseStyle + ("color:" + config.labelDateColor + ";");
      var valid = function valid2(arr) {
        return Array.isArray(arr) && arr.length > config.listThreshold;
      };
      var showItem = slots.content && valid(afterNode.raw.info.items);
      var itemStyle = "width:" + config.listWidth + "px;height:" + config.iconWrapperSize + "px;background:" + config.background + ";";
      var params = {
        afterNode,
        node: afterNode.raw,
        config,
        allItem,
        dropdowns,
        showPop: dropdowns[afterNode.raw.name]
      };
      var iconVnode, lableVnodes;
      if (slots.icon) {
        iconVnode = slots.icon(params);
      } else {
        iconVnode = h("div", {
          class: "tiny-flow-chart__node-icon " + statusName,
          style: iconStyle
        }, [iconComp ? h(iconComp, {
          class: "tiny-flow-chart__node-svg",
          style: svgStyle
        }) : null]);
      }
      if (slots.label) {
        lableVnodes = [slots.label(params)];
      } else {
        var property = {
          class: "label-item label-title",
          style: titleStyle
        };
        var t = omitText(afterNode.raw.info.label, config.font, labelWidth);
        if (t.o) {
          property.attrs = {
            title: afterNode.raw.info.label
          };
        }
        lableVnodes = [h("div", property, t.t), h("div", {
          class: "label-item label-date",
          style: dateStyle
        }, afterNode.raw.info.date)];
      }
      return h("div", {
        class: "tiny-flow-chart__node-icon-wrapper",
        style: wrapperStyle2,
        on: {
          mousemove: clearHoverAfterLink,
          click: function click(e) {
            return clickNode(params, e);
          }
        }
      }, [iconVnode, h("div", {
        class: "tiny-flow-chart__node-label",
        style: labelStyle
      }, lableVnodes), showItem ? h("div", {
        class: "tiny-flow-chart__node-item",
        style: itemStyle
      }, [slots.content(params)]) : null]);
    });
    return h("div", {
      class: "tiny-flow-chart",
      style: wrapperStyle,
      key: refreshKey,
      directives: [{
        name: "clickoutside",
        expression: "clearDropdown"
      }]
    }, [h("canvas", {
      class: "tiny-flow-chart__canvas",
      attrs: {
        width: config.width,
        height: config.height
      },
      ref: "canvas"
    })].concat(nodes));
  }
});

var getRenderLabel = function getRenderLabel2(_ref) {
  var omitText = _ref.omitText, font = _ref.font, width = _ref.width, padding = _ref.padding, popoverProps = _ref.popoverProps;
  return function(label, type) {
    if (!label)
      return null;
    var t = omitText(label, font, width - padding[1]);
    var fontClass = type === "main" ? "font-semibold text-color-text-primary" : "text-color-text-secondary";
    var labelClass = "w-full text-center whitespace-nowrap overflow-hidden text-ellipsis " + padding[0] + " " + fontClass;
    var lableVnode = h("div", {
      slot: "reference",
      class: labelClass
    }, label);
    if (!t.o)
      return lableVnode;
    var def = h("span", label);
    var childNodes = isVue3 ? {
      default: function _default() {
        return def;
      },
      reference: function reference() {
        return lableVnode;
      }
    } : [def, lableVnode];
    return h(Popover, popoverProps, childNodes);
  };
};
var renderShapeChildren = function renderShapeChildren2(_ref2) {
  var renderInner = _ref2.renderInner, raw = _ref2.raw, renderLabel = _ref2.renderLabel, main = _ref2.main, auxi = _ref2.auxi;
  var shapeVnodeChildren = null;
  if (typeof renderInner === "function") {
    shapeVnodeChildren = [renderInner(h, raw)];
  } else {
    var mainVnode = renderLabel(main, "main");
    var auxiVnode = renderLabel(auxi, "auxi");
    shapeVnodeChildren = [mainVnode, auxiVnode];
  }
  return shapeVnodeChildren;
};
var renderShapeVnode = function renderShapeVnode2(args) {
  var renderOuter = args.renderOuter, raw = args.raw, colors = args.colors, status = args.status, statusOngoing = args.statusOngoing, ongoingBackgroundColor = args.ongoingBackgroundColor;
  var shape = args.shape, statusFail = args.statusFail, error = args.error, shapeVnodeChildren = args.shapeVnodeChildren, popoverProps = args.popoverProps;
  var shapeVnode = null;
  if (typeof renderOuter === "function") {
    shapeVnode = renderOuter(h, raw);
  } else {
    var borderColor = "border-color:" + colors[status] + ";";
    var backgroundColor = status === statusOngoing ? "background-color:" + ongoingBackgroundColor + ";" : "";
    var cls = ["w-full h-full border-0.5 sm:border border-solid flex flex-col items-center cursor-pointer", shape === "circle" ? "rounded-full justify-center" : "", shape === "rectangle" ? "rounded justify-evenly" : ""];
    var styl = borderColor + backgroundColor;
    if (status === statusFail && error) {
      var def = h("span", error);
      var ref = h("div", {
        class: cls,
        style: styl,
        slot: "reference"
      }, shapeVnodeChildren);
      var childNodes = isVue3 ? {
        default: function _default() {
          return def;
        },
        reference: function reference() {
          return ref;
        }
      } : [def, ref];
      popoverProps.class = "w-full h-full block";
      shapeVnode = h(Popover, popoverProps, childNodes);
    } else {
      shapeVnode = h("div", {
        class: cls,
        style: styl,
        slot: "reference"
      }, shapeVnodeChildren);
    }
  }
  return shapeVnode;
};
var renderCondVnodes = function renderCondVnodes2(_ref3) {
  var isDot = _ref3.isDot, afterLinks = _ref3.afterLinks, afterConfig = _ref3.afterConfig, config = _ref3.config;
  if (!isDot)
    return [];
  var cfg = afterConfig || config || {};
  var condClass = cfg.condClass, renderCond = cfg.renderCond;
  return afterLinks.filter(function(_ref4) {
    var cond = _ref4.cond;
    return cond;
  }).map(function(afterLink) {
    var rect = afterLink.rect, raw = afterLink.raw;
    var clazz = "absolute flex justify-center items-center";
    var style = "left:" + rect.x + "px;top:" + rect.y + "px;width:" + rect.w + "px;height:" + rect.h + "px;";
    return h("div", {
      class: clazz,
      style
    }, [renderCond ? renderCond(h, afterLink, cfg) : h("div", {
      attrs: {
        title: raw.info.other.title
      },
      class: condClass || ""
    }, raw.info.other.title)]);
  });
};
var renderGroupVnodes = function renderGroupVnodes2(_ref5) {
  var afterGroups = _ref5.afterGroups, clickGroup = _ref5.clickGroup;
  if (!afterGroups)
    return [];
  return afterGroups.map(function(afterGroup) {
    var _afterGroup$raw = afterGroup.raw, title = _afterGroup$raw.title, titleClass = _afterGroup$raw.titleClass;
    var vnode = null;
    if (title) {
      var titlePosition = afterGroup.raw.titlePosition;
      var width = afterGroup.width, height = afterGroup.height;
      var p0 = afterGroup.coords[0];
      var p3 = afterGroup.coords[3];
      var pos = {
        x: 0,
        y: p3.y + 8
      };
      var centerClass = "";
      if (!titlePosition || titlePosition === "top-left") {
        pos.x = p0.x + 8;
      } else {
        pos.x = p3.x - width / 2;
        centerClass = "flex justify-center items-center";
      }
      vnode = h("div", {
        class: "absolute " + centerClass,
        style: {
          left: pos.x + "px",
          top: pos.y + "px",
          width: width + "px",
          height: height + "px"
        },
        on: {
          click: function click(e) {
            return clickGroup(afterGroup, e);
          }
        }
      }, [h("div", {
        class: "truncate",
        attrs: {
          title
        }
      }, [h("span", {
        class: titleClass
      }, title)])]);
    }
    return vnode;
  });
};
var _sfc_main$1 = defineComponent({
  emits: ["click-node", "click-link", "click-blank", "click-group"],
  props: [].concat(props, ["data", "config"]),
  setup: function setup$1(props2, context) {
    return setup({
      props: props2,
      context,
      renderless,
      api,
      extendOptions: {
        emitter
      }
    });
  },
  render: function render() {
    var state = this.state, omitText = this.omitText, config = this.config, clickNode = this.clickNode, clickGroup = this.clickGroup;
    var afterData = state.afterData, wrapperStyle = state.wrapperStyle, refreshKey = state.refreshKey;
    var graph = afterData.graph, afterNodes = afterData.afterNodes, afterLinks = afterData.afterLinks, afterGroups = afterData.afterGroups, afterConfig = afterData.afterConfig;
    var font = config.font, popoverPlacement = config.popoverPlacement, colors = config.colors, statusOngoing = config.statusOngoing, statusFail = config.statusFail, ongoingBackgroundColor = config.ongoingBackgroundColor;
    var ratio = graph.thin ? graph.thinValue : 1;
    var padding = ["px-1.5", 12];
    var isDot = config.type === "dot";
    var condVnodes = renderCondVnodes({
      isDot,
      afterLinks,
      afterConfig,
      config
    });
    var groupVnodes = renderGroupVnodes({
      afterGroups,
      clickGroup
    });
    return h("div", {
      attrs: {
        "data-tag": "tiny-flow-chart"
      },
      class: "relative",
      style: wrapperStyle,
      key: refreshKey
    }, [h("canvas", {
      attrs: {
        "data-tag": "tiny-flow-chart__canvas",
        width: graph.width * ratio,
        height: graph.height * ratio
      },
      class: graph.thin ? "scale-50 -translate-x-1/4 -translate-y-1/4" : "absolute top-0 left-0",
      ref: "canvas"
    })].concat(afterNodes.map(function(afterNode) {
      var x = afterNode.x, y = afterNode.y, width = afterNode.width, height = afterNode.height, raw = afterNode.raw;
      var info = raw.info, renderInner = raw.renderInner;
      var renderOuter = raw.renderOuter || config.renderOuter;
      var other = info.other, shape = info.shape, status = info.status;
      var main = other.main, auxi = other.auxi, error = other.error;
      var popoverProps = {
        props: {
          trigger: "hover",
          placement: popoverPlacement
        },
        class: "w-full block"
      };
      var renderLabel = getRenderLabel({
        omitText,
        font,
        width,
        padding,
        popoverProps
      });
      var shapeVnodeChildren = renderShapeChildren({
        renderInner,
        raw,
        renderLabel,
        main,
        auxi
      });
      var args = {
        renderOuter,
        raw,
        colors,
        status,
        statusOngoing,
        ongoingBackgroundColor
      };
      Object.assign(args, {
        shape,
        statusFail,
        error,
        shapeVnodeChildren,
        popoverProps
      });
      var shapeVnode = renderShapeVnode(args);
      var wrapperProps = {
        attrs: {
          "data-tag": "tiny-flow-chart__node"
        },
        style: "left:" + x + "px;top:" + y + "px;width:" + width + "px;height:" + height + "px;",
        class: ["absolute", {
          "flex justify-center items-center": isDot
        }],
        on: {
          click: function click(e) {
            return clickNode({
              afterNode
            }, e);
          }
        }
      };
      var outerClass = ["absolute w-6 h-6", {
        "sm:w-4 sm:h-4": config.nodeSize === "mini",
        "sm:w-8 sm:h-8": config.nodeSize === "medium"
      }];
      return h("div", wrapperProps, [isDot ? h("div", {
        class: outerClass
      }, [shapeVnode]) : shapeVnode]);
    }), condVnodes, groupVnodes));
  }
});

function _createForOfIteratorHelperLoose(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (t)
    return (t = t.call(r)).next.bind(t);
  if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
    t && (r = t);
    var o = 0;
    return function() {
      return o >= r.length ? { done: true } : { done: false, value: r[o++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r)
      return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++)
    n[e] = r[e];
  return n;
}
var _export_sfc = function _export_sfc2(sfc, props) {
  var target = sfc.__vccOpts || sfc;
  for (var _iterator = _createForOfIteratorHelperLoose(props), _step; !(_step = _iterator()).done; ) {
    var _step$value = _step.value, key = _step$value[0], val = _step$value[1];
    target[key] = val;
  }
  return target;
};

function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
var template = function template2(mode) {
  var _process$env;
  var tinyMode = typeof process === "object" ? (_process$env = process.env) == null ? void 0 : _process$env.TINY_MODE : null;
  if ("pc" === (tinyMode || mode)) {
    return _sfc_main$2;
  }
  if ("mobile-first" === (tinyMode || mode)) {
    return _sfc_main$1;
  }
  return _sfc_main$2;
};
var $constants = {};
var createNode = function createNode2(name, status, label, date, items, row, col, other) {
  var info = {
    status,
    label,
    date,
    items,
    row,
    col,
    other
  };
  return {
    name,
    info
  };
};
var createLink = function createLink2(from, to, p, status, style, other) {
  var info = {
    status,
    style: style || "solid",
    other
  };
  return {
    from,
    to,
    p,
    info
  };
};
var createItem = function createItem2(key, name, role, status, comment, date, other) {
  return {
    key,
    name,
    role,
    status,
    comment,
    date,
    other
  };
};
var createConfig = function createConfig2() {
  return {
    width: 1024,
    height: 420,
    rows: 8,
    cols: 8,
    status: {
      1: "complete",
      2: "ongoing",
      3: "pending",
      4: "fail"
    },
    colors: {
      1: "#1890ff",
      2: "#096dd9",
      3: "#d9d9d9",
      4: "#f5222d"
    },
    background: "#fff",
    statusComplete: 1,
    statusOngoing: 2,
    statusFail: 4,
    anchor: "center",
    iconWrapperSize: 24,
    iconSize: 20,
    iconSvgSize: 14,
    labelSpacing: 8,
    labelWidth: 80,
    labelHeight: 60,
    labelDateColor: "#999",
    listWidth: 62,
    listThreshold: 1,
    listIconSize: 20,
    listBorderColor: "#d9d9d9",
    listIconColor: "#999",
    headUrl: "",
    headSize: 20,
    drawLink: null,
    styleLink: null,
    styleHoverLink: null,
    hoverHit: 3,
    checkItemStatus: null,
    font: '12px "Microsoft YaHei"',
    delay: 10,
    adjustPos: null,
    radius: 4,
    thin: true
  };
};
var Flowchart = defineComponent({
  name: $prefix + "Flowchart",
  props: _extends({}, $props, {
    _constants: {
      type: Object,
      default: function _default() {
        return $constants;
      }
    },
    data: Object,
    config: Object
  }),
  setup: function setup(props2, context) {
    return $setup({
      props: props2,
      context,
      template
    });
  }
});
var icons = {
  "not-started": {
    mini: iconNotStartedMini,
    other: iconNotStarted
  },
  "ongoing": {
    mini: iconOnGoingMini,
    other: iconOnGoing
  },
  "fail": {
    mini: iconExceptionMiniO,
    other: iconExceptionO
  },
  "completed": {
    mini: iconDoneMini,
    other: iconDone
  }
};
var _sfc_main = defineComponent({
  props: [].concat(props, ["node", "config", "titleClass"]),
  setup: function setup2(props2, context) {
    return setup({
      props: props2,
      context,
      renderless: renderless$1,
      api: api$1,
      mono: true,
      extendOptions: {
        icons
      }
    });
  }
});
var _hoisted_1 = ["title"];
function _sfc_render(_ctx, _cache, $props2, $setup2, $data, $options) {
  return openBlock(), createElementBlock(
    "div",
    {
      "data-tag": "tiny-flowchart-node",
      key: _ctx.state.nodeName,
      class: normalizeClass(["layout-" + _ctx.state.nodeLayout, "size-" + _ctx.state.nodeSize, "status-" + _ctx.state.nodeStatus, "absolute z-20 h-6", {
        "sm:h-4": _ctx.state.sizeMini,
        "sm:h-8": _ctx.state.sizeMedium
      }]),
      style: normalizeStyle({
        width: _ctx.state.nodeWidth + "px"
      })
    },
    [createElementVNode(
      "div",
      {
        ref: "icon",
        class: normalizeClass(["w-4 h-4 absolute z-0 rounded-full flex items-center justify-center", "translate-x-1 translate-y-1 text-base cursor-pointer", {
          "sm:w-2 sm:h-2": _ctx.state.icon.size === "mini",
          "sm:w-6 sm:h-6": _ctx.state.icon.size === "medium"
        }])
      },
      [(openBlock(), createBlock(resolveDynamicComponent(_ctx.state.icon.svg()), {
        "custom-class": ["w-4 h-4 inline-block", {
          "sm:w-2 sm:h-2": _ctx.state.icon.size === "mini",
          "sm:w-6 sm:h-6": _ctx.state.icon.size === "medium"
        }]
      }, null, 8, ["custom-class"]))],
      2
      /* CLASS */
    ), createElementVNode(
      "div",
      {
        ref: "title",
        class: normalizeClass(_ctx.m("absolute z-0 translate-x-1", _ctx.state.layUpdown ? "top-6" : "left-6 translate-y-1", _ctx.state.layUpdown ? {
          "sm:top-4": _ctx.state.sizeMini,
          "sm:top-8": _ctx.state.sizeMedium
        } : {
          "sm:left-4": _ctx.state.sizeMini,
          "sm:left-8": _ctx.state.sizeMedium
        }, _ctx.titleClass || "")),
        style: normalizeStyle({
          maxWidth: _ctx.state.titleMaxWidth + "px",
          left: _ctx.state.layUpdown ? "-" + _ctx.state.posLeft + "px" : ""
        })
      },
      [(openBlock(), createElementBlock(
        Fragment,
        null,
        renderList(["title", "subtitle", "auxi"], function(key) {
          return openBlock(), createElementBlock(
            Fragment,
            null,
            [_ctx.state[key].show ? (openBlock(), createElementBlock("div", {
              key,
              title: _ctx.state[key].text,
              class: normalizeClass(["truncate", _ctx.state.layUpdown ? "text-center" : "text-left", key === "title" && _ctx.state.sizeMedium ? "text-sm" : "text-xs", _ctx.state.isSmall ? {
                "leading-5": key === "title",
                "leading-4": key !== "title"
              } : {
                "leading-6": key === "title" && _ctx.state.sizeMedium,
                "leading-5": key !== "title" && _ctx.state.sizeMedium || key === "title" && _ctx.state.sizeSmall,
                "leading-4": key !== "title" && _ctx.state.sizeSmall || _ctx.state.sizeMini
              }, {
                "text-color-icon-focus": _ctx.state.statOngoing,
                "text-color-text-primary": key === "title" && _ctx.state.statCompleted,
                "text-color-error": key === "title" && _ctx.state.statFail,
                "text-color-icon-secondary": key === "title" && _ctx.state.statNotStarted,
                "text-color-icon-placeholder": key !== "title" && !_ctx.state.statOngoing
              }])
            }, toDisplayString(_ctx.state[key].text), 11, _hoisted_1)) : createCommentVNode("v-if", true)],
            64
            /* STABLE_FRAGMENT */
          );
        }),
        64
        /* STABLE_FRAGMENT */
      ))],
      6
      /* CLASS, STYLE */
    )],
    6
    /* CLASS, STYLE */
  );
}
var Node = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
var resizeMixin = function resizeMixin2(_ref) {
  var apiPrefix = _ref.apiPrefix, refName = _ref.refName, nodeWrapperSize = _ref.nodeWrapperSize;
  apiPrefix = apiPrefix || "rszmx";
  refName = refName || "chart";
  nodeWrapperSize = nodeWrapperSize || 32;
  var observer = apiPrefix + "ResizeObserver";
  var observed = apiPrefix + "ResizeObserved";
  return {
    mounted: function mounted() {
      var _this = this;
      this.$nextTick(function() {
        var observedElement = _this.$el.parentNode;
        if (observedElement) {
          _this[observer] = new ResizeObserver(function() {
            window.requestAnimationFrame(function() {
              if (_this.$refs[refName]) {
                _this.$refs[refName].refresh({
                  graphWidth: observedElement.offsetWidth,
                  adjustX: -nodeWrapperSize / 2
                });
              }
            });
          });
          _this[observer].observe(observedElement);
          _this[observed] = observedElement;
        }
      });
    },
    beforeUnmount: function beforeUnmount() {
      if (this[observer]) {
        this[observer].unobserve(this[observed]);
        this[observer].disconnect();
        this[observer] = null;
        this[observed] = null;
      }
    }
  };
};
var resizeMixin$1 = resizeMixin;
var version = "3.20.0";
Flowchart.install = function(Vue) {
  Vue.component(Flowchart.name, Flowchart);
};
Flowchart.version = version;
Flowchart.createNode = createNode;
Flowchart.createLink = createLink;
Flowchart.createItem = createItem;
Flowchart.createConfig = createConfig;
Flowchart.Node = Node;
Flowchart.resizeMixin = resizeMixin$1;

export { Flowchart as default };

import cloneDeep from '../../util/cloneDeep.js';
import defendXSS from '../../util/defendXSS.js';
import chartToken from './chartToken.js';

/**
 * Copyright (c) 2024 - present OpenTiny HUICharts Authors.
 * Copyright (c) 2024 - present Huawei Cloud Computing Technologies Co., Ltd.
 *
 * Use of this source code is governed by an MIT-style license.
 *
 * THE OPEN SOURCE SOFTWARE IN THIS PRODUCT IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
 * BUT WITHOUT ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS FOR
 * A PARTICULAR PURPOSE. SEE THE APPLICABLE LICENSES FOR MORE DETAILS.
 *
 */

// 给图例和x轴赋值
function handleData(baseOpt, legendData, xAxisData) {
  if (!baseOpt.legend.data) {
    baseOpt.legend.data = legendData;
  }
  baseOpt.xAxis.forEach(function (item) {
    item.data = xAxisData;
  });
}
function onlyOnePoint(baseOption) {
  baseOption.series.forEach(function (itemObj) {
    if (itemObj.data.length === 1) {
      itemObj.showSymbol = true;
    }
  });
}
function defaultFormatter(params) {
  var htmlString = '';
  // 只选取前半部分真实的series数据
  params = params.slice(0, params.length / 2);
  params.forEach(function (item, index) {
    if (index === 0) {
      htmlString += "<div style=\"margin-bottom:4px;\">" + defendXSS(item.name) + "</div>";
    }
    htmlString += "<div>\n                            <span style=\"display:inline-block;width:10px;height:10px;border-radius:5px;background-color:" + defendXSS(item.color) + ";\"></span>\n                            <span style=\"margin-left:5px;>\n                                <span style=\"display:inline-block; margin-right:8px;min-width:60px;\">" + defendXSS(item.seriesName) + "</span>\n                                <span style=\"font-weight:bold\">" + defendXSS(item.value) + "</span>\n                            </span>\n                        </div>";
  });
  return htmlString;
}
function isNullValue(value) {
  return value === '' || value === undefined || value === null;
}

// 实现离散数据的markLine变色功能
function addDiscreteVisualMap(baseOption, iChartOption, actualSeriesIndex, seriesIndex, discreteVisualMap) {
  var area = iChartOption.area;
  var visualMap = baseOption.visualMap;
  // 如果是面积图不做处理
  if (area) return;
  if (visualMap && visualMap.lenth !== 0) {
    var newVisualMapItem = visualMap[seriesIndex] ? cloneDeep(visualMap[seriesIndex]) : null;
    if (newVisualMapItem) {
      newVisualMapItem.seriesIndex = actualSeriesIndex;
      discreteVisualMap.push(newVisualMapItem);
    }
  }
}

// 针对离散数据, 创建同名Series, 显示离散数据的单个点
function discrete(iChartOption, baseOption) {
  // 创建同名Series
  if (iChartOption.discrete) {
    // 记录实际的真实数据产生的sereis的
    var actualSeriesIndex = baseOption.series.length - 1;
    var discreteSeries = [];
    var discreteVisualMap = [];
    baseOption.series.forEach(function (series, seriesIndex) {
      var newSeries = cloneDeep(series);
      newSeries.symbol = 'circle';
      newSeries.symbolSize = chartToken.symbolSizeSM;
      newSeries.itemStyle.borderWidth = chartToken.borderZero;
      newSeries.showSymbol = true;
      newSeries.showAllSymbol = true;
      newSeries.emphasis = {
        itemStyle: {
          opacity: 0
        }
      };
      var discreteData = [];
      for (var index = 0; index < newSeries.data.length; index++) {
        var pre = newSeries.data[index - 1];
        var next = newSeries.data[index];
        var cur = newSeries.data[index + 1];
        if (!isNullValue(pre) || !isNullValue(cur)) {
          discreteData.push(null);
        } else {
          discreteData.push(next);
        }
      }
      newSeries.data = discreteData;
      actualSeriesIndex++;
      addDiscreteVisualMap(baseOption, iChartOption, actualSeriesIndex, seriesIndex, discreteVisualMap);
      discreteSeries.push(newSeries);
    });
    baseOption.series = [].concat(baseOption.series, discreteSeries);
    baseOption.visualMap = [].concat(baseOption.visualMap, discreteVisualMap);
    // 覆盖tipHtml，过滤同名Series
    var tipFormatter = baseOption.tooltip.formatter;
    baseOption.tooltip.formatter = function (params, ticket, callback) {
      if (tipFormatter) {
        return tipFormatter(params.slice(0, params.length / 2), ticket, callback);
      } else {
        return defaultFormatter(params);
      }
    };
  }
}
export { defaultFormatter, discrete, handleData, onlyOnePoint };

import { opacity, direction, singlecolor, singleWarnColor, singleMin2G, singleMin5G, singleMax } from './CommonConstant.js';

/**
 * Copyright (c) 2024 - present OpenTiny HUICharts Authors.
 * Copyright (c) 2024 - present Huawei Cloud Computing Technologies Co., Ltd.
 *
 * Use of this source code is governed by an MIT-style license.
 *
 * THE OPEN SOURCE SOFTWARE IN THIS PRODUCT IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
 * BUT WITHOUT ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS FOR
 * A PARTICULAR PURPOSE. SEE THE APPLICABLE LICENSES FOR MORE DETAILS.
 *
 */

var setAttribute = function setAttribute(dom, attribute) {
  for (var i in attribute) {
    if (Object.hasOwnProperty.call(attribute, i)) {
      dom.setAttribute(i, attribute[i]);
    }
  }
};
var setStyle = function setStyle(dom, styles) {
  for (var i in styles) {
    if (Object.hasOwnProperty.call(styles, i)) {
      dom.style[i] = styles[i];
    }
  }
};
var onImageLoad = function onImageLoad(imageList, callback) {
  var onloadNum = 0;
  var loadEvent = function loadEvent() {
    onloadNum++;
    if (onloadNum === Object.keys(imageList).length) {
      callback();
    }
  };
  for (var item in imageList) {
    if (Object.hasOwnProperty.call(imageList, item)) {
      imageList[item]['image'].addEventListener('load', loadEvent);
    }
  }
};
var pxToNumber = function pxToNumber(pxText) {
  return pxText.split('px')[0] - 0;
};
var createDom = function createDom(type) {
  if (type === void 0) {
    type = 'div';
  }
  return document.createElement(type);
};
var insertDom = function insertDom(container, attribute, styles, type) {
  var dom = createDom(type);
  setAttribute(dom, attribute);
  setStyle(dom, styles);
  container.appendChild(dom);
  return dom;
};
var getStyle = function getStyle(dom, cssName) {
  return window.getComputedStyle(dom)[cssName];
};
var getCssNumber = function getCssNumber(dom, cssName) {
  return pxToNumber(getStyle(dom, cssName));
};

// 将角度控制在0-360区间内
var degPositive = function degPositive(angle) {
  var deg;
  if (angle >= 0 && angle <= 360) {
    deg = angle;
  } else if (angle > 360) {
    deg = angle % 360;
  } else {
    deg = 360 + angle % 360;
  }
  return deg;
};

// 提取一段字符串中的数值和小数点部分
function extractNumbersAndDots(str) {
  return str.match(/[\d.]+/g)[0];
}

// 获取文本的非数值部分
var getUnitText = function getUnitText(text) {
  var valString = extractNumbersAndDots(text).toString();
  var unit = text.slice(valString.length);
  return unit;
};

// 补全默认值
var setDefault = function setDefault(userOption, defaultOption) {
  for (var key in defaultOption) {
    if (userOption[key] === undefined || userOption[key] === null) {
      userOption[key] = defaultOption[key];
    }
  }
};

// 判断某个值是否在区间内
var judgeValue = function judgeValue(value, min, max) {
  var flag = true;
  if (parseFloat(value) <= parseFloat(max) && parseFloat(value) >= parseFloat(min)) {
    flag = true;
  } else {
    flag = false;
  }
  return flag;
};
var _loopData = function loopData(data, newData) {
  data.forEach(function (item, index) {
    newData.push(item);
    if (item.children && item.children.length) {
      _loopData(item.children, newData);
    }
  });
};

// 树形数组平铺
var arrFlat = function arrFlat(data) {
  var newData = [];
  _loopData(data, newData);
  return newData;
};

// 判断数据的disabled，给外层容器挂上类名
var isDataDisabled = function isDataDisabled(data, container, option) {
  var disabledData = data.filter(function (item) {
    return item.disabled === true;
  });
  // overAll视图下，不展示disabled状态
  if (disabledData.length && !option.overAll) {
    container.classList.add('disabled');
  } else {
    container.classList.remove('disabled');
  }
};

// 刷新node、line、tag，需要判断mac一致则更新
var compareRefresh = function compareRefresh(data, branchs, _ref, that) {
  var centerArr = _ref.centerArr,
    target = _ref.target;
  var flatData = arrFlat(data);
  branchs.forEach(function (item) {
    flatData.forEach(function (dataItem) {
      item[centerArr].forEach(function (val) {
        if (val.data.mac === dataItem.mac) {
          val.refreshData(dataItem);
        }
      });
      item.leafsArr.forEach(function (val) {
        if (val.data.mac === dataItem.mac) {
          val[target].refreshData(dataItem);
        }
      });
    });
  });
  isDataDisabled(flatData, that.container, that.option);
};

// 遍历平铺数据，发现有没有disabled属性，有则设置透明度
var judgeDisabled = function judgeDisabled(option, domArr, isLeaf, dataItem, isNode) {
  var data = option.data,
    overAll = option.overAll;
  if (overAll) {
    // 全网视口不用置灰
    return;
  }
  var hasDisabled = false;
  var tagDisabled = false;
  var flatData = arrFlat(data);
  if (!isLeaf) {
    if (!isNode) {
      flatData.forEach(function (item) {
        if (item.disabled) {
          // 有一个disabled，非叶子节点tag、line全部置灰
          hasDisabled = true;
        }
      });
    } else {
      if (dataItem.disabled) {
        // 非叶子节点的node是否置灰由自己决定
        hasDisabled = true;
      }
    }
  } else if (isLeaf) {
    flatData.forEach(function (item) {
      if (item.disabled) {
        // 有一个disabled，叶子节点的tag、line全部置灰
        tagDisabled = true;
      }
    });
    if (dataItem.disabled) {
      // 叶子节点的node是否置灰由自己决定
      hasDisabled = true;
    }
  }
  domArr.forEach(function (item) {
    setStyle(item, {
      opacity: hasDisabled ? opacity : 1
    });
  });
  if (isLeaf && tagDisabled) {
    // 叶子节点需要置灰tag
    setStyle(domArr[1], {
      opacity: opacity
    });
  }
};

// 下钻/取消下钻，移动选中dom到视口中心
var moveToCenter = function moveToCenter(_ref2, that, isNode) {
  var activeMac = _ref2.activeMac,
    leafTrigger = _ref2.leafTrigger,
    drag = _ref2.drag,
    chartContainer = _ref2.chartContainer;
  if (activeMac && that.data.mac === activeMac) {
    if (that.option.overAll) {
      // 全网，使画布在视口中心(业务场景有可能需要将对应dom居中，待调整)
      drag.moveTargetToCenter(chartContainer);
    } else {
      // 家庭，使点击的dom在视口中心(点击的是叶子节点，叶子节点居中，否则是叶子节点的外层容器居中)
      if (isNode) {
        drag.moveTargetToCenter(leafTrigger ? that.wrapper : that.wrapper.parentNode.parentNode);
      } else {
        drag.moveTargetToCenter(leafTrigger ? that.node.returnWrapper() : that.node.returnWrapper().parentNode.parentNode);
      }
    }
  }
};

// 主网关信号强度判断
var getRootTextColor = function getRootTextColor(data) {
  return judgeValue(data.rxPower, data.rxPowerMin, data.rxPowerMax) ? singlecolor : singleWarnColor;
};

// sta信号强度判断
var getLeafTextColor = function getLeafTextColor(data) {
  var _data$connectInterfac;
  return judgeValue(data.signalStrength, ((_data$connectInterfac = data.connectInterface) == null ? void 0 : _data$connectInterfac.indexOf('2.4G')) !== -1 ? singleMin2G : singleMin5G, singleMax) ? singlecolor : singleWarnColor;
};

// 从网关信号强度判断
var getAPTextColor = function getAPTextColor(data) {
  var _data$connectInterfac2;
  var single;
  var singleTextColor;
  if (((_data$connectInterfac2 = data.connectInterface) == null ? void 0 : _data$connectInterfac2.indexOf('SSID')) !== -1) {
    single = data.signalStrength;
    singleTextColor = getLeafTextColor(data);
  } else {
    single = data.rxPower;
    singleTextColor = getRootTextColor(data);
  }
  return {
    single: single,
    singleTextColor: singleTextColor
  };
};

// 根据设备类型获取信号强度字段和色值
var getSingle = function getSingle(data, type) {
  var single;
  var singleTextColor;
  switch (type) {
    case 'root':
      single = data.rxPower;
      singleTextColor = getRootTextColor(data);
      break;
    case 'leaf':
      single = data.signalStrength;
      singleTextColor = getLeafTextColor(data);
      break;
    case 'ap':
      single = getAPTextColor(data).single;
      singleTextColor = getAPTextColor(data).singleTextColor;
      break;
  }
  return {
    single: single,
    singleTextColor: singleTextColor
  };
};

// 根据角度确定箭头/tag 朝向
var setDirection = function setDirection(deg) {
  var flag;
  var left = direction.left,
    right = direction.right;
  if (deg >= 90 && deg < 270) {
    flag = left;
  } else {
    flag = right;
  }
  return flag;
};

// 计算一段字符的像素长度
var getTextWidth = function getTextWidth(text, fontSize) {
  if (fontSize === void 0) {
    fontSize = 12;
  }
  var result = 0;
  var ele = document.createElement('span');
  // 字符串中带有换行符时，会被自动转换成<br/>标签，若需要考虑这种情况，可以替换成空格，以获取正确的宽度
  ele.innerText = text;
  // 不同的大小和不同的字体都会导致渲染出来的字符串宽度变化，可以传入尽可能完备的样式信息
  ele.setAttribute('style', "font-size: " + fontSize + "px");
  document.documentElement.append(ele);
  result = ele.offsetWidth;
  document.documentElement.removeChild(ele);
  return result;
};

// 计算等腰三角形的对边边长
var getSideLength = function getSideLength(arc, r) {
  return Math.sin(arc / 2 / 180 * Math.PI) * r * 2;
};

// 计算等腰三角形的腰长
var getWaistLength = function getWaistLength(arc, sideLength) {
  return sideLength / 2 / Math.sin(arc / 2 / 180 * Math.PI);
};

// 弧度转角度
function radiansToDegrees(radian) {
  return 180 * radian / Math.PI;
}

// 计算等腰三角形的夹角
var getTriangleAngle = function getTriangleAngle(sideLength, r) {
  return radiansToDegrees(Math.asin(sideLength / 2 / r)) * 2;
};

// 获取两个dom的距离
var getDistance = function getDistance(dom1, dom2) {
  var _dom1$getBoundingClie = dom1.getBoundingClientRect(),
    x1 = _dom1$getBoundingClie.x,
    y1 = _dom1$getBoundingClie.y,
    width1 = _dom1$getBoundingClie.width,
    height1 = _dom1$getBoundingClie.height;
  var _dom2$getBoundingClie = dom2.getBoundingClientRect(),
    x2 = _dom2$getBoundingClie.x,
    y2 = _dom2$getBoundingClie.y,
    width2 = _dom2$getBoundingClie.width,
    height2 = _dom2$getBoundingClie.height;
  var center1 = {
    x: x1 + width1 / 2,
    y: y1 + height1 / 2
  };
  var center2 = {
    x: x2 + width2 / 2,
    y: y2 + height2 / 2
  };
  var distance = Math.sqrt(Math.pow(center2.x - center1.x, 2) + Math.pow(center2.y - center1.y, 2));
  return distance;
};

// 获取指向类名的全部节点（传入Array类型）围成区间的大小范围
var getAreaScope = function getAreaScope(nodeArr) {
  var scope = {
    left: nodeArr[0].getBoundingClientRect().left,
    right: nodeArr[0].getBoundingClientRect().right,
    top: nodeArr[0].getBoundingClientRect().top,
    bottom: nodeArr[0].getBoundingClientRect().bottom
  };
  nodeArr.forEach(function (node) {
    var _node$getBoundingClie = node.getBoundingClientRect(),
      left = _node$getBoundingClie.left,
      right = _node$getBoundingClie.right,
      top = _node$getBoundingClie.top,
      bottom = _node$getBoundingClie.bottom;
    if (left < scope.left) {
      scope.left = left;
    }
    if (right > scope.right) {
      scope.right = right;
    }
    if (top < scope.top) {
      scope.top = top;
    }
    if (bottom > scope.bottom) {
      scope.bottom = bottom;
    }
  });
  return {
    width: scope.right - scope.left,
    height: scope.bottom - scope.top
  };
};

// 悬浮提示框的边界判断
var boundaryJudge = function boundaryJudge(e, container, toolTip) {
  var distance = 20;
  var x = e.clientX + distance;
  var y = e.clientY + distance;
  var _container$getBoundin = container.getBoundingClientRect(),
    containerWidth = _container$getBoundin.width,
    containerHeight = _container$getBoundin.height,
    containerLeft = _container$getBoundin.x,
    containerTop = _container$getBoundin.y;
  var _toolTip$getBoundingC = toolTip.getBoundingClientRect(),
    toolTipWidth = _toolTip$getBoundingC.width,
    toolTipHeight = _toolTip$getBoundingC.height;
  if (x + toolTipWidth > containerLeft + containerWidth) {
    // 超过右边界
    x = e.clientX - toolTipWidth - distance / 2;
  }
  if (y + toolTipHeight > containerTop + containerHeight) {
    // 超过下边界
    y = e.clientY - toolTipHeight - distance / 2;
  }
  return {
    x: x,
    y: y
  };
};
export { arrFlat, boundaryJudge, compareRefresh, createDom, degPositive, extractNumbersAndDots, getAreaScope, getCssNumber, getDistance, getSideLength, getSingle, getStyle, getTextWidth, getTriangleAngle, getUnitText, getWaistLength, insertDom, isDataDisabled, judgeDisabled, judgeValue, moveToCenter, onImageLoad, pxToNumber, setAttribute, setDefault, setDirection, setStyle };

function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
import { degPositive, setDirection, insertDom, createDom, pxToNumber, getStyle, setStyle, judgeDisabled } from './util.js';
import { tagPosition, direction } from './CommonConstant.js';

/**
 * Copyright (c) 2024 - present OpenTiny HUICharts Authors.
 * Copyright (c) 2024 - present Huawei Cloud Computing Technologies Co., Ltd.
 *
 * Use of this source code is governed by an MIT-style license.
 *
 * THE OPEN SOURCE SOFTWARE IN THIS PRODUCT IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
 * BUT WITHOUT ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS FOR
 * A PARTICULAR PURPOSE. SEE THE APPLICABLE LICENSES FOR MORE DETAILS.
 *
 */
var TagManager = /*#__PURE__*/function () {
  function TagManager(container, data, option, deg, isCenter, drag) {
    this.wrapper = void 0;
    this.container = container;
    this.data = data;
    this.option = option;
    this.deg = degPositive(deg);
    this.isCenter = isCenter;
    this.direction = setDirection(this.deg);
    this.tagPositionVal = tagPosition; // tag当前的定位值
    this.drag = drag;
    this.mount();
  }
  var _proto = TagManager.prototype;
  _proto.mount = function mount() {
    this.dom = insertDom(this.container, {
      "class": 'sfc-tag-item'
    });
    this.wrapper = insertDom(this.dom);
    // 判断是否来自于主网关传递给子网关的tag
    this.isCenter && this.insertContent();
  };
  _proto.returnWrapper = function returnWrapper() {
    return this.wrapper || createDom();
  };
  _proto.setAngle = function setAngle() {
    var containerWidth = pxToNumber(getStyle(this.container, 'width')); // tag分组容器的宽度
    var tagItemWidth = pxToNumber(getStyle(this.wrapper, 'width')); // tagdom自身的宽度 
    var originPoint;
    var tagStyle = {};
    if (this.direction === direction['left']) {
      originPoint = containerWidth * ((this.tagPositionVal - 50) / 100) + tagItemWidth / 2;
      tagStyle = {
        right: this.tagPositionVal + "%",
        transformOrigin: originPoint + "px center",
        transform: "translate(50%,-50%) rotate(" + (this.deg - 180) + "deg)"
      };
    } else {
      originPoint = -1 * (containerWidth * ((this.tagPositionVal - 50) / 100) - tagItemWidth / 2);
      tagStyle = {
        left: this.tagPositionVal + "%",
        transformOrigin: originPoint + "px center",
        transform: "translate(-50%,-50%) rotate(" + this.deg + "deg)"
      };
    }
    setStyle(this.dom, _extends({}, tagStyle));
  };
  _proto.insertContent = function insertContent() {
    judgeDisabled(this.option, [this.dom]);
    var renderFun = this.data.render || this.option.render;
    if (renderFun) {
      renderFun({
        nodeContainer: createDom(),
        tagContainer: this.wrapper
      }, this.data, this.option, this.drag.scale);
    }
    // 重新计算tag的旋转角度和定位
    this.setAngle();
  }

  // 刷新数据的方法
  ;
  _proto.refreshData = function refreshData(data) {
    this.data = data;
    this.insertContent();
  };
  return TagManager;
}();
export { TagManager as default };

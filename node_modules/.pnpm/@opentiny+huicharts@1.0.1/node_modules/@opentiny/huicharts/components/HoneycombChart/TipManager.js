/**
 * Copyright (c) 2024 - present OpenTiny HUICharts Authors.
 * Copyright (c) 2024 - present Huawei Cloud Computing Technologies Co., Ltd.
 *
 * Use of this source code is governed by an MIT-style license.
 *
 * THE OPEN SOURCE SOFTWARE IN THIS PRODUCT IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
 * BUT WITHOUT ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS FOR
 * A PARTICULAR PURPOSE. SEE THE APPLICABLE LICENSES FOR MORE DETAILS.
 *
 */
var TipManager = /*#__PURE__*/function () {
  function TipManager(theme, tipHtml) {
    this.theme = theme;
    this.isShow = false;
    this.tipHtml = tipHtml;
    this.tooltipDom = null;
    this.setTipTimeOut = null;
  }
  var _proto = TipManager.prototype;
  _proto.init = function init(tipContainer) {
    var _this = this;
    this.tooltipDom = document.createElement('div');
    this.tooltipDom.classList.add('hc-tooltip');
    if (this.theme === 'dark') {
      this.tooltipDom.classList.add('dark');
    }
    this.tooltipDom.addEventListener('mouseenter', function (e) {
      if (_this.setTipTimeOut) {
        clearTimeout(_this.setTipTimeOut);
      }
    });
    this.tooltipDom.addEventListener('mouseleave', function (e) {
      _this.close(e);
    });
    tipContainer.appendChild(this.tooltipDom);
  };
  _proto.show = function show(event, node, tipContainer, chartContainer) {
    // 唯一到别的上面去要马上刷新
    if (this.setTipTimeOut) {
      clearTimeout(this.setTipTimeOut);
    }
    this.isShow = true;
    this.tooltipDom.innerHTML = '';
    this.tipHtml(this.tooltipDom, node);
    this.tooltipDom.style.display = 'block';
    this.setPosition(event, tipContainer, chartContainer);
  };
  _proto.close = function close(event) {
    var _this2 = this;
    this.setTipTimeOut = setTimeout(function () {
      _this2.isShow = false;
      _this2.tooltipDom.style.display = 'none';
    }, 200);
  };
  _proto.setPosition = function setPosition(event, tipContainer, chartContainer) {
    var tipRect = this.tooltipDom.getBoundingClientRect();
    var targetRect = event.target.getBoundingClientRect();
    var tipContainerRect = tipContainer.getBoundingClientRect();
    var chartContainerRect = chartContainer.getBoundingClientRect();
    var tipTop = targetRect.top - tipContainerRect.top - tipRect.height;
    var tipLeft = targetRect.left - tipContainerRect.left + targetRect.width;
    // 如果弹窗右侧超出容器，则向左进行位置修正
    var reviseH = tipContainerRect.left - chartContainerRect.left + tipLeft + tipRect.width - chartContainerRect.width;
    // 此处-5是为了能够给阴影留下一些显示位置
    if (reviseH > 0) {
      tipLeft = tipLeft - reviseH - 5;
    }
    // 如果弹窗顶部超出容器，则向下进行位置修正
    var reviseV = tipTop + (tipContainerRect.top - chartContainerRect.top);
    // 此处+5是为了能够给阴影留下一些显示位置
    if (reviseV < 0) {
      tipTop = tipTop - reviseV + 5;
    }
    this.tooltipDom.style.top = tipTop + 'px';
    this.tooltipDom.style.left = tipLeft + 'px';
  };
  return TipManager;
}();
export { TipManager as default };

function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
import cloneDeep$1 from "@opentiny/huicharts/util/cloneDeep";
import IntegrateChart from "@opentiny/huicharts";
import BaiduMapChart from "@opentiny/huicharts/components/BaiduMapChart";
import AutonaviMapChart from "@opentiny/huicharts/components/AutonaviMapChart";
import "@opentiny/vue-theme/chart-core/index.css";
var toString = Object.prototype.toString;
var hasOwn = Object.prototype.hasOwnProperty;
var getProto = Object.getPrototypeOf;
var fnToString = hasOwn.toString;
var ObjectFunctionString = fnToString.call(Object);
var class2type = {
  "[object Error]": "error",
  "[object Object]": "object",
  "[object RegExp]": "regExp",
  "[object Date]": "date",
  "[object Array]": "array",
  "[object Function]": "function",
  "[object String]": "string",
  "[object Number]": "number",
  "[object Boolean]": "boolean"
};
var isNull = function isNull2(x) {
  return x === null || x === void 0 || x === "undefined";
};
var typeOf$1 = function typeOf$12(obj) {
  return isNull(obj) ? String(obj) : class2type[toString.call(obj)] || "object";
};
var isObject = function isObject2(obj) {
  return typeOf$1(obj) === "object";
};
var isPlainObject = function isPlainObject2(obj) {
  if (!obj || toString.call(obj) !== "[object Object]") {
    return false;
  }
  var proto = getProto(obj);
  if (!proto) {
    return true;
  }
  var Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
};
var each = function each2(obj, handle) {
  if (typeof handle !== "function") {
    return;
  }
  for (var name in obj) {
    if (hasOwn.call(obj, name)) {
      if (handle(name, obj[name]) === false) {
        break;
      }
    }
  }
};
var extend$2;
var getObj = function getObj2(data2, names, isExceptRoot) {
  if (!data2 || !isPlainObject(data2) || !names || typeof names !== "string") {
    return;
  }
  names = names.split(".");
  var obj = data2;
  var len = names.length;
  if (len > 1) {
    var startIndex = isExceptRoot ? 1 : 0;
    for (var i = startIndex; i < len; i++) {
      obj = obj[names[i]];
      if (isNull(obj)) {
        return obj;
      }
    }
    return obj;
  } else {
    return obj[names[0]];
  }
};
var setObj = function setObj2(data2, names, value, isMerge) {
  if (!data2 || !isPlainObject(data2) || !names || typeof names !== "string") {
    return data2;
  }
  names = names.split(".");
  var obj = data2;
  var len = names.length;
  var item = names[0];
  if (len > 1) {
    len--;
    var tmpl = obj;
    var name, target;
    for (var i = 0; i < len; i++) {
      name = names[i];
      target = tmpl[name];
      if (target === null || !isPlainObject(target)) {
        tmpl[name] = {};
        target = tmpl[name];
      }
      tmpl = target;
    }
    item = names[len];
    isMerge ? isPlainObject(tmpl[item]) ? extend$2(true, tmpl[item], value) : tmpl[item] = value : tmpl[item] = value;
  } else {
    isMerge ? isPlainObject(obj[item]) ? extend$2(true, obj[item], value) : obj[item] = value : obj[item] = value;
  }
  return obj;
};
var copyField = function copyField2(data2, fields, isMerge, isExclude) {
  var _setValue = function setValue(obj, result, name, key, isMerge2) {
    var include = key.indexOf(name) === 0;
    var keySplit = key.split(name);
    var hasNextDot = keySplit[1] && keySplit[1].indexOf(".") === 0;
    if (name === key || include && hasNextDot) {
      if (name !== key) {
        each(getObj(obj, name), function(field) {
          _setValue(obj, result, name + "." + field, key);
        });
      }
    } else {
      if (!fields.includes(name)) {
        setObj(result, name, getObj(obj, name), isMerge2);
      }
    }
  };
  var innerCopyFields = function innerCopyFields2(obj, fields2, isMerge2, isExclude2) {
    var result = {};
    if (isExclude2) {
      each(obj, function(name) {
        return fields2.forEach(function(key) {
          return _setValue(obj, result, name, key, isMerge2);
        });
      });
    } else {
      fields2.forEach(function(field) {
        return setObj(result, field, getObj(obj, field), isMerge2);
      });
    }
    return result;
  };
  if (isPlainObject(data2)) {
    return Array.isArray(fields) ? innerCopyFields(data2, fields, isMerge, isExclude) : extend$2(isMerge !== false, {}, data2);
  }
  return data2;
};
var copyArray = function copyArray2(arr) {
  return Array.isArray(arr) ? arr.map(function(item) {
    return copyField(item);
  }) : arr;
};
var deepCopy$1 = function deepCopy$12(target, name, deep, copy, src) {
  var copyIsArray;
  if (deep && copy && (isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
    if (copyIsArray) {
      copyIsArray = false;
      target[name] = copyArray(copy);
    } else {
      var clone = src && isPlainObject(src) ? src : {};
      target[name] = extend$2(deep, clone, copy);
    }
  } else if (copy !== void 0) {
    try {
      target[name] = copy;
    } catch (e) {
    }
  }
};
extend$2 = function extend$22() {
  var args = arguments;
  var length = args.length;
  var target = args[0] || {};
  var i = 1;
  var deep = false;
  if (typeOf$1(target) === "boolean") {
    deep = target;
    target = args[i] || {};
    i++;
  }
  if (!isObject(target) && typeOf$1(target) !== "function") {
    target = {};
  }
  if (i === length) {
    target = this;
    i--;
  }
  for (; i < length; i++) {
    var _options = args[i];
    if (_options !== null && isObject(_options)) {
      var names = Object.keys(_options);
      for (var _i = 0, _names = names; _i < _names.length; _i++) {
        var name = _names[_i];
        var src = target[name];
        var copy = _options[name];
        if (target !== copy) {
          deepCopy$1(target, name, deep, copy, src);
        }
      }
    }
  }
  return target;
};
var ABBR = {
  th: 3,
  mi: 6,
  bi: 9,
  tr: 12
};
var abbrLabel = {
  th: "k",
  mi: "m",
  bi: "b",
  tr: "t"
};
var DEFAULT_OPTIONS = {
  zeroFormat: null,
  nullFormat: null,
  defaultFormat: "0,0",
  scalePercentBy100: true,
  abbrLabel
};
var TRILLION = 1e12, BILLION = 1e9, MILLION = 1e6, THOUSAND = 1e3;
var numIsNaN = function numIsNaN2(value) {
  return typeof value === "number" && isNaN(value);
};
var options = {};
var formats = {};
function getBoundedPrecision(value, maxDecimals, optionals) {
  var splitValue = value.toString().split("e-");
  var exponent = splitValue.length === 2 ? Number(splitValue[1]) : 0;
  splitValue = splitValue[0].split(".");
  exponent = splitValue.length === 2 ? splitValue[1].length + exponent : exponent;
  var minDecimals = maxDecimals - (optionals || 0);
  return Math.min(Math.max(exponent, minDecimals), maxDecimals);
}
function toFixed(value, maxDecimals, roundingFunction, optionals) {
  var boundedPrecision = getBoundedPrecision(value, maxDecimals, optionals);
  var power = Math.pow(10, boundedPrecision);
  var output = (roundingFunction(value * ("1e+" + boundedPrecision)) / power).toFixed(boundedPrecision);
  if (optionals > maxDecimals - boundedPrecision) {
    var optionalsRegExp = new RegExp("\\.?0{1," + (optionals - (maxDecimals - boundedPrecision)) + "}$");
    output = output.replace(optionalsRegExp, "");
  }
  return output;
}
function judgForFunc(num, abs, abbrForce) {
  var flag;
  if (num === 0) {
    flag = abs >= TRILLION && !abbrForce || abbrForce === "t";
  } else if (num === 1) {
    flag = abs < TRILLION && abs >= BILLION && !abbrForce || abbrForce === "b";
  } else if (num === 2) {
    flag = abs < BILLION && abs >= MILLION && !abbrForce || abbrForce === "m";
  } else if (num === 3) {
    flag = abs < MILLION && abs >= THOUSAND && !abbrForce || abbrForce === "k";
  }
  return flag;
}
var negativeSigned = function negativeSigned2(_ref) {
  var format3 = _ref.format, value = _ref.value;
  return ~format3.indexOf("+") ? format3.indexOf("+") : value < 0 ? format3.indexOf("-") : -1;
};
var updateAbbrV = function updateAbbrV2(params) {
  var abbr = params.abbr, abbrForce = params.abbrForce, format3 = params.format, value = params.value, abs = params.abs;
  abbrForce = format3.match(/a(k|m|b|t)?/);
  abbrForce = abbrForce ? abbrForce[1] : false;
  if (~format3.indexOf(" a")) {
    abbr = " ";
  }
  format3 = format3.replace(new RegExp(abbr + "a[kmbt]?"), "");
  if (judgForFunc(0, abs, abbrForce)) {
    abbr += options.abbrLabel.tr;
    value = value / TRILLION;
  } else if (judgForFunc(1, abs, abbrForce)) {
    abbr += options.abbrLabel.bi;
    value = value / BILLION;
  } else if (judgForFunc(2, abs, abbrForce)) {
    abbr += options.abbrLabel.mi;
    value = value / MILLION;
  } else if (judgForFunc(3, abs, abbrForce)) {
    abbr += options.abbrLabel.th;
    value = value / THOUSAND;
  }
  Object.assign(params, {
    abbr,
    abbrForce,
    format: format3,
    value,
    abs
  });
};
var handlePrecision = function handlePrecision2(params) {
  var roundingFunction = params.roundingFunction, value = params.value, format3 = params.format;
  var number = value.toString().split(".")[0];
  var precision = format3.split(".")[1];
  if (precision) {
    if (~precision.indexOf("[")) {
      precision = precision.replace("]", "");
      precision = precision.split("[");
      params.decimal = toFixed(value, precision[0].length + precision[1].length, roundingFunction, precision[1].length);
    } else {
      params.decimal = toFixed(value, precision.length, roundingFunction);
    }
    number = params.decimal.split(".")[0];
    params.decimal = ~params.decimal.indexOf(".") ? "." + params.decimal.split(".")[1] : "";
    if (params.optDec && Number(params.decimal.slice(1)) === 0) {
      params.decimal = "";
    }
  } else {
    number = toFixed(value, 0, roundingFunction);
  }
  return number;
};
function formatNumber(params) {
  var number = handlePrecision(params);
  var thousands = params.format.indexOf(",");
  var leadingCount = (params.format.split(".")[0].split(",")[0].match(/0/g) || []).length;
  if (params.abbr && !params.abbrForce && Number(number) >= 1e3 && params.abbr !== ABBR.trillion) {
    number = String(Number(number) / 1e3);
    params.abbr = ABBR.million;
  }
  if (~number.indexOf("-")) {
    number = number.slice(1);
    params.neg = true;
  }
  if (number.length < leadingCount) {
    for (var i = leadingCount - number.length; i > 0; i--) {
      number = "0" + number;
    }
  }
  if (thousands > -1) {
    number = number.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1,");
  }
  if (!params.format.indexOf(".")) {
    number = "";
  }
  return number;
}
function getOutStr(_ref2, number) {
  var decimal = _ref2.decimal, negFlag = _ref2.negFlag, neg = _ref2.neg, signed = _ref2.signed, abbr = _ref2.abbr;
  var outStr = number + decimal + (abbr || "");
  if (negFlag) {
    outStr = negFlag && neg ? "(" + outStr + ")" : outStr;
  } else {
    if (signed >= 0) {
      var symbol = neg ? "-" : "+";
      outStr = signed === 0 ? symbol + outStr : outStr + symbol;
    } else if (neg) {
      outStr = "-" + outStr;
    }
  }
  return outStr;
}
function numberToFormat(options2, value, format3, roundingFunction) {
  var params = {
    abs: Math.abs(value),
    negFlag: false,
    optDec: false,
    abbr: "",
    decimal: "",
    neg: false,
    abbrForce: void 0,
    signed: void 0,
    format: format3 || "",
    value: value || 0,
    roundingFunction
  };
  if (~format3.indexOf("(")) {
    params.negFlag = true;
    params.format = format3.replace(/[(|)]/g, "");
  } else if (~params.format.indexOf("+") || ~params.format.indexOf("-")) {
    params.signed = negativeSigned(params);
    params.format = format3.replace(/[+|-]/g, "");
  }
  if (~params.format.indexOf("a")) {
    updateAbbrV(params);
  }
  if (~params.format.indexOf("[.]")) {
    params.optDec = true;
    params.format = format3.replace("[.]", ".");
  }
  var number = formatNumber(params);
  return getOutStr(params, number);
}
function extend$1(target, sub) {
  Object.keys(sub).forEach(function(key) {
    target[key] = sub[key];
  });
}
var numerifyPercent = {
  regexp: /%/,
  format: function format(value, formatType, roundingFunction, numerify22) {
    var space = ~formatType.indexOf(" %") ? " " : "";
    var outStr = void 0;
    if (numerify22.options.scalePercentBy100) {
      value = value * 100;
    }
    formatType = formatType.replace(/\s?%/, "");
    outStr = numerify22._numberToFormat(value, formatType, roundingFunction);
    if (~outStr.indexOf(")")) {
      outStr = outStr.split("");
      outStr.splice(-1, 0, space + "%");
      outStr = outStr.join("");
    } else {
      outStr = outStr + space + "%";
    }
    return outStr;
  }
};
extend$1(options, DEFAULT_OPTIONS);
var numerify;
function format2(value, formatType, roundingFunc) {
  var zeroFormat = options.zeroFormat, nullFormat = options.nullFormat, defaultFormat = options.defaultFormat;
  formatType = formatType || defaultFormat;
  roundingFunc = roundingFunc || Math.round;
  var _ref3 = {}, output = _ref3.output, fmtFunc = _ref3.fmtFunc;
  if (value === 0 && zeroFormat !== null) {
    output = zeroFormat;
  } else if (value === null && nullFormat !== null) {
    output = nullFormat;
  } else {
    for (var key in formats) {
      if (formats[key] && formatType.match(formats[key].regexp)) {
        fmtFunc = formats[key].format;
        break;
      }
    }
    fmtFunc = fmtFunc || numberToFormat.bind(null, options);
    output = fmtFunc(value, formatType, roundingFunc, numerify);
  }
  return output;
}
numerify = function numerify2(input, formatType, roundingFunc) {
  var zeroFormat = options.zeroFormat, nullFormat = options.nullFormat;
  var value = Number(input) || null;
  if (typeof input === "undefined" || input === 0) {
    value = 0;
  } else if (numIsNaN(input) || input === null) {
    value = null;
  } else if (typeof input === "string") {
    value = Number(input);
    if (input === zeroFormat && zeroFormat) {
      value = 0;
    } else if (input === nullFormat && nullFormat || !input.replace(/[^0-9]+/g, "").length) {
      value = null;
    }
  }
  return format2(value, formatType, roundingFunc);
};
var _register = function _register2(name, format3) {
  formats[name] = format3;
};
var _unregister = function _unregister2(name) {
  formats[name] = null;
};
var _setOptions = function _setOptions2(opts) {
  extend$1(options, opts);
};
var _reset = function _reset2() {
  extend$1(options, DEFAULT_OPTIONS);
};
numerify.options = options;
numerify._numberToFormat = numberToFormat.bind(null, options);
numerify.register = _register;
numerify.unregister = _unregister;
numerify.setOptions = _setOptions;
numerify.reset = _reset;
numerify.register("percentage", numerifyPercent);
var _numerify = numerify;
var matchHtmlRegExp = /["'&<>/]/;
function escapeHtml(string) {
  var str = "" + string;
  var match = matchHtmlRegExp.exec(str);
  if (!match) {
    return str;
  }
  var escape;
  var html = "";
  var index;
  var lastIndex = 0;
  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        escape = "&quot;";
        break;
      case 38:
        escape = "&amp;";
        break;
      case 39:
        escape = "&#x27;";
        break;
      case 60:
        escape = "&lt;";
        break;
      case 62:
        escape = "&gt;";
        break;
      case 47:
        escape = "&#x2F;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }
    lastIndex = index + 1;
    html += escape;
  }
  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
}
var $prefix = "Tiny";
var getFormatted = function getFormatted2(value, type, digit, defaultVal) {
  if (defaultVal === void 0) {
    defaultVal = "-";
  }
  if (typeof value === "object" && !isNull(value)) {
    value = value.value;
  }
  if (isNaN(value)) {
    return defaultVal;
  }
  if (!type) {
    return value;
  }
  if (typeOf$1(type) === "function") {
    return type(value, _numerify);
  }
  digit = !isNaN(digit) ? ++digit : 0;
  var digitStr = ".[" + new Array(digit).join(0) + "]";
  var formatter = type;
  if (type === "KMB") {
    formatter = digit ? "0,0" + digitStr + "a" : "0,0a";
  } else if (type === "normal") {
    formatter = digit ? "0,0" + digitStr : "0,0";
  } else if (type === "percent") {
    formatter = digit ? "0,0" + digitStr + "%" : "0,0.[00]%";
  }
  return _numerify(value, formatter);
};
var cloneDeep = function cloneDeep2(data2) {
  if (isObject(data2)) {
    return extend(true, data2);
  }
  if (Array.isArray(data2)) {
    return copyArray(data2);
  }
  return data2;
};
var getStackMap = function getStackMap2(stack) {
  var result = {};
  Object.keys(stack).forEach(function(item) {
    stack[item].forEach(function(name) {
      result[name] = item;
    });
  });
  return result;
};
var _merge = function merge(source, other) {
  if (typeof source !== "object" || typeof other !== "object") {
    return other === void 0 ? source : other;
  }
  return Object.keys(_extends({}, source, other)).reduce(function(acc, key) {
    acc[key] = _merge(source[key], other[key]);
    return acc;
  }, Array.isArray(source) ? [] : {});
};
var mapPromise = {};
var getMapJSON = function getMapJSON2(_ref4) {
  var position = _ref4.position, positionJsonLink = _ref4.positionJsonLink, beforeRegisterMapOnce = _ref4.beforeRegisterMapOnce, _ref4$mapURLProfix = _ref4.mapURLProfix, mapURLProfix = _ref4$mapURLProfix === void 0 ? "" : _ref4$mapURLProfix;
  var link = positionJsonLink || "" + mapURLProfix + position + ".json";
  if (!mapPromise[link]) {
    mapPromise[link] = $get(link).then(function(res) {
      if (beforeRegisterMapOnce) {
        res = beforeRegisterMapOnce(res);
      }
      return res;
    });
  }
  return mapPromise[link];
};
var htmlHandler = function htmlHandler2(data2) {
  if (!data2 || !Array.isArray(data2)) {
    return data2;
  }
  return cloneDeep(data2).map(function(item) {
    if (typeof item === "string" && /<[a-z]+/i.test(item)) {
      return escapeHtml(item);
    }
    if (typeof item === "object") {
      for (var key in item) {
        if (typeof item[key] === "string" && /<[a-z]+/i.test(item[key])) {
          item[key] = escapeHtml(item[key]);
        }
      }
      return item;
    }
    return item;
  });
};
var isArr = Array.isArray;
function removeNullKeys(obj) {
  if (typeof obj !== "object" || obj === null) {
    return obj;
  }
  for (var key in obj) {
    if (obj[key] === null) {
      delete obj[key];
    } else {
      obj[key] = removeNullKeys(obj[key]);
    }
  }
  return obj;
}
var setExtend = function setExtend2(_ref5) {
  var huiChartOption = _ref5.huiChartOption, extend2 = _ref5.extend;
  var cloneOption = cloneDeep$1(huiChartOption);
  var mergeOption = removeNullKeys(cloneOption);
  if (!extend2) {
    return;
  }
  Object.keys(extend2).forEach(function(key) {
    var value = extend2[key];
    if (~key.indexOf(".")) {
      setObj(mergeOption, key, value);
    } else if (typeof value === "function") {
      mergeOption[key] = value(mergeOption[key]);
    } else if (isArr(mergeOption[key]) && isArr(value)) {
      var attrList = ["series", "yAxis", "xAxis", "color", "dataZoom", "legend", "toolbox", "grid", "graphic", "timeline", "visualMap", "brush"];
      if (~attrList.indexOf(key)) {
        if (key === "dataZoom") {
          mergeOption[key] = value;
        } else {
          mergeOption[key] = _merge(mergeOption[key], value);
        }
      }
    } else {
      if (isArr(mergeOption[key]) && isObject(mergeOption[key][0])) {
        mergeOption[key].forEach(function(huiChartOption2, i) {
          return mergeOption[key][i] = _extends({}, huiChartOption2, value);
        });
      } else if (isObject(mergeOption[key])) {
        var optionBase = mergeOption[key];
        mergeOption[key] = _extends({}, optionBase, value);
      } else {
        mergeOption[key] = value;
      }
    }
  });
  var series = mergeOption.series;
  if (series) {
    if (Array.isArray(series)) {
      mergeOption.series = series.map(function(item) {
        if (getObj(item, "type") === "line" && getObj(item, "label.show")) {
          item.showSymbol = true;
        }
        return item;
      });
    } else {
      mergeOption.series.label = _extends({
        show: false
      }, mergeOption.series.label);
    }
  }
  return mergeOption;
};
var SF = function SF2() {
  return {
    show: false
  };
};
var DEFAULT_THEME = {
  categoryAxis: {
    axisLine: SF(),
    axisTick: SF(),
    splitLine: SF()
  },
  valueAxis: {
    axisLine: SF()
  },
  line: {
    smooth: true
  },
  grid: {
    containLabel: true,
    left: 10,
    right: 10
  }
};
var DEFAULT_COLORS = ["#19d4ae", "#5ab1ef", "#fa6e86", "#ffb980", "#0067a6", "#c4b4e4", "#d87a80", "#9cbbff", "#d9d0c7", "#87a997", "#d49ea2", "#5b4947", "#7ba3a8"];
var HEAT_MAP_COLOR = ["#5990FD", "#2DA769", "#EEBA18", "#F43146"];
var _SAAS_DEFAULT_COLORS1 = ["#2070F3", "#00A874", "#745EF7", "#8BC2FF", "#1B3F86", "#FDC000", "#00A2B5"];
var _SAAS_DEFAULT_COLORS2 = ["#FC916E", "#1F55B5", "#2D94FF", "#82DBB1", "#F36900", "#2A8290", "#EE8DDB"];
var _SAAS_DEFAULT_COLORS3 = ["#278661", "#4FA700", "#5CACFF", "#9185F0", "#B62BF7", "#26616B", "#F46465"];
var _SAAS_DEFAULT_COLORS4 = ["#5531EB", "#FCDBAA", "#112857", "#E61866", "#B98C1D", "#D41DBC", "#87D5E5"];
var SAAS_DEFAULT_COLORS = _SAAS_DEFAULT_COLORS1.concat(_SAAS_DEFAULT_COLORS2).concat(_SAAS_DEFAULT_COLORS3).concat(_SAAS_DEFAULT_COLORS4);
var SAAS_DEFAULT_SAME_COLORS = {
  blue: [{
    color: "#2E94FF",
    idx: 3
  }, {
    color: "#8BC3FF",
    idx: 5
  }, {
    color: "#1F55B5",
    idx: 1
  }, {
    color: "#2070F3",
    idx: 2
  }, {
    color: "#5CACFF",
    idx: 4
  }, {
    color: "#B9DBFF",
    idx: 6
  }, {
    color: "#1B3F86",
    idx: 0
  }],
  green: [{
    color: "#00A874",
    idx: 3
  }, {
    color: "#82DBB1",
    idx: 5
  }, {
    color: "#236549",
    idx: 1
  }, {
    color: "#278661",
    idx: 2
  }, {
    color: "#50C291",
    idx: 4
  }, {
    color: "#AFEDCE",
    idx: 6
  }, {
    color: "#1D4A37",
    idx: 0
  }]
};
var itemPoint = function itemPoint2(color) {
  return ['<span style="', "background-color:" + color + ";", "display: inline-block;", "width: 6px;", "height: 6px;", "border-radius: 50%;", "margin-right:8px;", "vertical-align:middle;", '"></span>'].join("");
};
var itemLabel = function itemLabel2(seriesName, onlyLabel) {
  return ['<span style="', "display:inline-block;", "font-size:12px;", "color:#4E4E4E;", onlyLabel ? "" : "margin-right:25px;", '">' + seriesName + "</span>"].join("");
};
var itemContent = function itemContent2(content) {
  return ['<span style="', "float:right;", "font-size:14px;", "color:#191919;", '">' + content + "</span>"].join("");
};
var Core = {
  name: $prefix + "ChartCore",
  emits: ["ready", "ready-once", "handle-color"],
  props: {
    data: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    settings: {
      type: Object,
      default: function _default2() {
        return {};
      }
    },
    width: {
      type: String,
      default: "auto"
    },
    height: {
      type: String,
      default: "400px"
    },
    events: {
      type: Object,
      default: function _default3() {
      }
    },
    initOptions: {
      type: Object,
      default: function _default4() {
        return {};
      }
    },
    tooltipVisible: {
      type: Boolean,
      default: true
    },
    legendVisible: {
      type: Boolean,
      default: true
    },
    legendPosition: {
      type: String
    },
    theme: Object,
    themeName: [Object, String],
    judgeWidth: {
      type: Boolean,
      default: false
    },
    widthChangeDelay: {
      type: Number,
      default: 200
    },
    resizeable: {
      type: Boolean,
      default: true
    },
    changeDelay: {
      type: Number,
      default: 0
    },
    dataEmpty: Boolean,
    beforeConfig: {
      type: Function
    },
    afterConfig: {
      type: Function
    },
    afterSetOption: {
      type: Function
    },
    afterSetOptionOnce: {
      type: Function
    },
    loading: {
      type: Boolean,
      default: false
    },
    extend: {
      type: Object,
      default: function _default5() {
      }
    },
    tooltipFormatter: {
      type: Function
    },
    markArea: {
      type: Object
    },
    markLine: {
      type: Object
    },
    markPoint: {
      type: Object
    },
    grid: {
      type: [Object, Array]
    },
    colors: {
      type: Array
    },
    visualMap: [Object, Array],
    dataZoom: [Object, Array],
    toolbox: [Object, Array],
    title: Object,
    legend: [Object, Array],
    xAxis: [Object, Array],
    yAxis: [Object, Array],
    radar: Object,
    tooltip: Object,
    axisPointer: Object,
    brush: [Object, Array],
    geo: Object,
    timeline: [Object, Array],
    graphic: [Object, Array],
    series: [Object, Array],
    backgroundColor: [Object, String],
    textStyle: Object,
    animation: Object,
    options: {
      type: Object,
      default: function _default6() {
        return {};
      }
    },
    cancelResizeCheck: {
      type: Boolean,
      default: false
    },
    setOptionOpts: {
      type: Object,
      default: function _default7() {
      }
    },
    colorMode: {
      type: String,
      default: "default"
    }
  },
  data: function data() {
    return {
      huiChartOption: {},
      eChartOption: {},
      renderOption: {},
      initOpts: {},
      watchToPropsEchartOptions: [],
      selfChart: ["BaiduMapChart", "AutonaviMapChart"],
      isSelfChart: false,
      chartList: [],
      once: {},
      store: {}
    };
  },
  computed: {
    // 图表延时的集合
    delay: function delay() {
      return {
        widthChangeDelay: this.widthChangeDelay,
        resizeDelay: this.resizeDelay
      };
    },
    size: function size() {
      return {
        width: this.width,
        height: this.height
      };
    },
    // 图表参数的集合
    setting: function setting() {
      return {
        data: this.data,
        settings: this.settings,
        extend: this.extend,
        tooltipVisible: this.tooltipVisible,
        legendVisible: this.legendVisible
      };
    }
  },
  watch: {
    options: {
      handler: function handler() {
        this.refreshChart();
      },
      deep: true
    },
    setting: {
      handler: function handler2() {
        this.refreshChart();
      },
      deep: true
    },
    events: {
      handler: function handler3(val, oldVal) {
        this.addEvents(val);
        this.removeEvents(oldVal);
      },
      deep: true
    },
    initOptions: {
      handler: function handler4(val) {
        this.initOpts = _extends({}, this.initOpts, val);
        this.renderChart(this.huiChartOption);
      },
      deep: true
    },
    judgeWidth: {
      handler: function handler5(val) {
        this.initOpts.domResize = val;
        this.renderChart(this.huiChartOption);
      }
    },
    delay: {
      handler: function handler6(val) {
        this.initOpts.resizeThrottle = val;
        this.renderChart(this.huiChartOption);
      },
      deep: true
    },
    resizeable: {
      handler: function handler7(val) {
        this.initOpts.windowResize = val;
        this.renderChart(this.huiChartOption);
      }
    },
    setOptionOpts: {
      handler: function handler8(val) {
        this.renderOption = val;
      },
      deep: true
    },
    loading: function loading(val) {
      var _this = this;
      this.$nextTick(function() {
        if (val) {
          _this.integrateChart.showLoading();
        } else {
          _this.integrateChart.closeLoading();
        }
      });
    },
    dataEmpty: function dataEmpty(val) {
      var _this2 = this;
      this.$nextTick(function() {
        if (val) {
          _this2.integrateChart.showEmpty();
        } else {
          _this2.integrateChart.closeEmpty();
        }
      });
    },
    size: {
      handler: function handler9() {
        var _this3 = this;
        this.$nextTick(function() {
          _this3.integrateChart && _this3.integrateChart.echartsIns && _this3.integrateChart.echartsIns.resize();
        });
      }
    },
    colors: {
      handler: function handler10() {
        this.refreshChart();
      },
      deep: true
    }
  },
  methods: {
    selfSetting: function selfSetting(options2) {
      var _this4 = this;
      var echartsSettings = ["grid", "dataZoom", "visualMap", "toolbox", "title", "legend", "xAxis", "yAxis", "radar", "tooltip", "axisPointer", "brush", "geo", "timeline", "graphic", "series", "backgroundColor", "textStyle"];
      echartsSettings.forEach(function(setting2, index) {
        var unwatch = _this4.watchToPropsEchartOptions[index];
        if (_this4[setting2]) {
          if (!options2.extend) {
            options2.extend = {};
          }
          options2.extend[setting2] = cloneDeep$1(_this4[setting2]);
          !unwatch && _this4.$watch(setting2, function() {
            _this4.refreshChart();
          }, {
            deep: true
          });
        } else {
          unwatch && unwatch();
        }
      });
    },
    setAnimation: function setAnimation(options2) {
      var _this5 = this;
      if (this.animation) {
        Object.keys(this.animation).forEach(function(key) {
          options2.extend[key] = _this5.animation[key];
        });
      }
    },
    applyMarks: function applyMarks(options2) {
      if (this.markArea || this.markLine || this.markPoint) {
        var marks = {
          markArea: this.markArea,
          markLine: this.markLine,
          markPoint: this.markPoint
        };
        var series = options2.series;
        var setMark = function setMark2(seriesItem, marks2) {
          Object.keys(marks2).forEach(function(key) {
            if (marks2[key]) {
              seriesItem[key] = marks2[key];
            }
          });
        };
        if (Array.isArray(series)) {
          series.forEach(function(item) {
            setMark(item, marks);
          });
        } else if (isObject(series)) {
          setMark(series, marks);
        }
      }
    },
    applyExtend: function applyExtend(huiChartOption) {
      if (this.extend) {
        return setExtend({
          huiChartOption,
          extend: this.extend
        });
      }
    },
    // 更新图表
    refreshChart: function refreshChart() {
      var _this6 = this;
      var data2 = this.data;
      if (Object.keys(this.options).length === 0) {
        this.updateChart(data2);
      } else {
        this.huiChartOption = cloneDeep$1(this.options);
      }
      var huiChartOption = cloneDeep$1(this.huiChartOption);
      if (!huiChartOption.theme) {
        huiChartOption.theme = "cloud-light";
      }
      if (Array.isArray(this.colors) && this.colors.length > 0) {
        huiChartOption.color = cloneDeep$1(this.colors);
      }
      clearTimeout(this.timer);
      this.timer = null;
      this.timer = setTimeout(function() {
        if (_this6.afterConfig) {
          huiChartOption = _this6.afterConfig(huiChartOption);
        }
        _this6.selfSetting(huiChartOption);
        _this6.setAnimation(huiChartOption);
        _this6.applyMarks(_this6.integrateChart.eChartOption);
        _this6.integrateChart.refresh(cloneDeep$1(huiChartOption));
        if (_this6.colorMode !== "default") {
          huiChartOption.color = _this6.computedChartColor();
        }
        if (_this6.extend && Object.keys(_this6.extend).length !== 0) {
          huiChartOption.extend = cloneDeep$1(_this6.applyExtend(_this6.integrateChart.eChartOption));
          _this6.integrateChart.refresh(cloneDeep$1(huiChartOption));
        }
        _this6.$emit("handle-color", huiChartOption.color);
        if (_this6.afterSetOption) {
          _this6.afterSetOption(_this6.integrateChart.echartsIns);
        }
        _this6.$emit("ready", _this6.integrateChart.echartsIns, huiChartOption);
      }, this.changeDelay);
      this.eChartOption = this.integrateChart.eChartOption;
    },
    // 初始渲染图表
    renderChart: function renderChart(huiChartOption) {
      if (!huiChartOption.theme) {
        huiChartOption.theme = "cloud-light";
      }
      if (Array.isArray(this.colors) && this.colors.length > 0) {
        huiChartOption.color = cloneDeep$1(this.colors);
      }
      var plugins = this.plugins || {};
      if (this.isSelfChart) {
        this.integrateChart.init(this.$refs.chartRef);
        if (this.colorMode !== "default") {
          huiChartOption.color = this.computedChartColor();
        }
        this.integrateChart.setSimpleOption(this.chartList[this.iChartName], huiChartOption, plugins);
        this.$emit("handle-color", huiChartOption.color);
      } else {
        this.selfSetting(huiChartOption);
        this.setAnimation(huiChartOption);
        var theme = this.themeName || this.theme || DEFAULT_THEME;
        this.integrateChart.init(this.$refs.chartRef, this.initOpts, theme);
        if (this.colorMode !== "default") {
          huiChartOption.color = this.computedChartColor();
        }
        this.integrateChart.setSimpleOption(this.iChartName, cloneDeep$1(huiChartOption), plugins);
        this.$emit("handle-color", huiChartOption.color);
        this.applyMarks(this.integrateChart.eChartOption);
      }
      if (this.extend && Object.keys(this.extend).length !== 0) {
        huiChartOption.extend = this.applyExtend(this.integrateChart.eChartOption);
        this.integrateChart.setSimpleOption(this.iChartName, cloneDeep$1(huiChartOption), plugins);
      }
      this.integrateChart.render(this.renderOption);
      this.$emit("ready", this.integrateChart.echartsIns, huiChartOption);
      if (!this.once["ready-once"]) {
        this.once["ready-once"] = true;
        this.$emit("ready-once", this.integrateChart.echartsIns, huiChartOption);
      }
      this.eChartOption = this.integrateChart.eChartOption;
    },
    addEvents: function addEvents(val) {
      var _this7 = this;
      if (typeof val === "object" && val !== null && Object.keys(val).length > 0) {
        var events = Object.keys(val);
        this.$nextTick(function() {
          events.forEach(function(item) {
            _this7.integrateChart.on(item, val[item]);
          });
        });
      }
    },
    removeEvents: function removeEvents(oldVal) {
      var _this8 = this;
      if (typeof oldVal === "object" && oldVal !== null && Object.keys(oldVal).length > 0) {
        var events = Object.keys(oldVal);
        this.$nextTick(function() {
          events.forEach(function(item) {
            _this8.integrateChart.on(item, oldVal[item]);
          });
        });
      }
    },
    resize: function resize() {
      if (!this.cancelResizeCheck) {
        this.integrateChart.echartsIns.resize();
      }
    },
    afterConfigFn: function afterConfigFn(huiChartOption) {
      if (this.afterConfig) {
        huiChartOption = this.afterConfig(huiChartOption);
        this.huiChartOption = huiChartOption;
      }
      return huiChartOption;
    },
    beforeConfigFn: function beforeConfigFn(data2) {
      if (this.beforeConfig) {
        data2 = this.beforeConfig(data2);
      }
      return data2;
    },
    isStack: function isStack() {
      var stack = this.settings.stack, columns = this.data.columns;
      var flag = false;
      if (typeof stack !== "object" || !Array.isArray(columns))
        return flag;
      Object.keys(stack).forEach(function(key) {
        stack[key].forEach(function(stackItem) {
          var isExist = columns.includes(stackItem);
          if (isExist) {
            flag = true;
          }
        });
      });
      return flag;
    },
    calcColors: function calcColors(_ref6) {
      var len = _ref6.len, type = _ref6.type, isStack2 = _ref6.isStack;
      var SAAS_COLOR = SAAS_DEFAULT_COLORS;
      var lastColor = "#1B3F86";
      if (isStack2 && type === "") {
        return len && len > 6 ? [lastColor].concat(SAAS_COLOR.slice(0, len - 1)) : SAAS_COLOR.slice(0, [len || 8]);
      }
      if (!isStack2 && type === "") {
        type = "default";
      }
      if (type === "blue" || type === "green") {
        SAAS_COLOR = SAAS_DEFAULT_SAME_COLORS[type].slice(0, len).sort(function(a, b) {
          return a.idx - b.idx;
        }).map(function(item) {
          return item.color;
        });
      }
      return len && len > 6 ? SAAS_COLOR.slice(0, len - 1).concat([lastColor]) : SAAS_COLOR.slice(0, [len || 8]);
    },
    computedChartColor: function computedChartColor() {
      var defaultColors = DEFAULT_COLORS;
      var flag = this.isStack();
      if (this.data && (Array.isArray(this.data.rows) || Array.isArray(this.data.columns))) {
        var _this$data = this.data, columns = _this$data.columns, rows = _this$data.rows;
        var len = Math.max(columns ? columns.length : 0, rows ? rows.length : 0);
        defaultColors = this.calcColors({
          len,
          type: this.colorMode,
          isStack: flag
        });
      } else if (Array.isArray(this.data)) {
        defaultColors = this.calcColors({
          len: this.data.length,
          type: this.colorMode,
          isStack: flag
        });
      } else if (this.extend && this.extend.series && Array.isArray(this.extend.series.data)) {
        defaultColors = this.calcColors({
          len: this.extend.series.data.length,
          type: this.colorMode,
          isStack: flag
        });
      } else if (this.extend && Array.isArray(this.extend.series)) {
        defaultColors = this.calcColors({
          len: this.extend.series.length,
          type: this.colorMode,
          isStack: flag
        });
      }
      return this.colors || this.theme && this.theme.color || defaultColors;
    }
  },
  created: function created() {
    this.huiChartOption = {};
    if (!this.selfChart.includes(this.iChartName)) {
      this.isSelfChart = false;
      this.integrateChart = new IntegrateChart();
    } else {
      this.isSelfChart = true;
      this.chartList = {
        BaiduMapChart,
        AutonaviMapChart
      };
      this.integrateChart = new this.chartList[this.iChartName]();
    }
  },
  mounted: function mounted() {
    var _this9 = this;
    this.$nextTick(function() {
      _this9.addEvents(_this9.events);
      _this9.loading && _this9.integrateChart.showLoading();
      _this9.dataEmpty && _this9.integrateChart.showEmpty();
    });
    this.initOpts = _extends({}, this.initOptions, {
      domResize: this.judgeWidth,
      resizeThrottle: this.widthChangeDelay
    });
    var data2 = this.data;
    data2 = this.beforeConfigFn(data2);
    if (Object.keys(this.options).length === 0) {
      this.updateChart(data2);
    } else {
      this.huiChartOption = cloneDeep$1(this.options);
    }
    var huiChartOption = this.huiChartOption;
    huiChartOption = this.afterConfigFn(huiChartOption);
    this.renderChart(huiChartOption);
    this.afterSetOption && this.afterSetOption(this.integrateChart.echartsIns);
    this.afterSetOptionOnce && this.afterSetOptionOnce(this.integrateChart.echartsIns);
  },
  beforeUnmount: function beforeUnmount() {
    this.watchToPropsEchartOptions.forEach(function(unwatch) {
      unwatch && unwatch();
    });
  }
};
function typeOf(obj) {
  var map = {
    "[object Object]": "object",
    "[object Null]": "null",
    "[object Date]": "date",
    "[object Undefined]": "undefined",
    "[object RegExp]": "regExp",
    "[object Array]": "array",
    "[object Function]": "function",
    "[object String]": "string",
    "[object Number]": "number",
    "[object Boolean]": "boolean",
    "[object BigInt]": "bigint"
  };
  var toString2 = Object.prototype.toString;
  return map[toString2.call(obj)];
}
var isDefined = function isDefined2(val) {
  return val !== void 0 && val !== null;
};
function deepCopy(val) {
  var o;
  var t = typeOf(val);
  if (t === "array") {
    o = [];
  } else if (t === "object") {
    o = {};
  } else {
    return val;
  }
  if (t === "array") {
    for (var i = 0; i < val.length; i++) {
      o.push(deepCopy(val[i]));
    }
  } else if (t === "object") {
    Object.keys(val).forEach(function(i2) {
      o[i2] = deepCopy(val[i2]);
    });
  }
  return o;
}
var getRows = function getRows2(args) {
  var columns = args.columns, metrics = args.metrics, labelMap = args.labelMap, rows = args.rows, _args$dimension = args.dimension, dimension = _args$dimension === void 0 ? columns[0] : _args$dimension;
  var rowData = [];
  var data2 = labelMap ? metrics.map(function(item) {
    return !labelMap[item] ? item : labelMap[item];
  }) : metrics;
  dimension.forEach(function(item) {
    data2.unshift(item);
  });
  rows.forEach(function(item) {
    var obj = {};
    for (var i = 0; i < data2.length; i++) {
      obj[data2[i]] = item[data2[i]];
    }
    rowData.push(obj);
  });
  return rowData;
};
var getYAxis = function getYAxis2(args) {
  var yAxisType = args.yAxisType, yAxisName = args.yAxisName, _args$scale = args.scale, scale = _args$scale === void 0 ? [false, false] : _args$scale, axisVisible = args.axisVisible, max = args.max, min = args.min, metrics = args.metrics, axisSite = args.axisSite, _args$digit = args.digit, digit = _args$digit === void 0 ? 2 : _args$digit;
  var yAxis = [];
  var yAxisBase = {
    scale
  };
  var _loop = function _loop2(k2) {
    yAxis[k2] = _extends({}, yAxisBase);
    if (yAxisType[k2]) {
      yAxis[k2] = _extends({}, yAxisBase, {
        axisLabel: {
          formatter: function formatter(val) {
            return getFormatted(val, yAxisType[k2], digit);
          }
        }
      });
    } else {
      yAxis[k2] = _extends({}, yAxisBase);
    }
    yAxis[k2].name = yAxisName[k2];
    yAxis[k2].min = min[k2] || null;
    yAxis[k2].max = max[k2] || null;
  };
  for (var k = 0; k < 2; k++) {
    _loop(k);
  }
  metrics.forEach(function(item) {
    if (axisSite.right && axisSite.right.includes(item)) {
      yAxis[1].dataName = [].concat(axisSite.right);
    } else {
      yAxis[0].dataName = item;
    }
  });
  return yAxis;
};
var getTooltip = function getTooltip2(args) {
  var axisSite = args.axisSite, yAxisType = args.yAxisType, labelMap = args.labelMap, _args$digit2 = args.digit, digit = _args$digit2 === void 0 ? 2 : _args$digit2;
  var rightItemsArr = (axisSite == null ? void 0 : axisSite.right) || [];
  var rightListArr = labelMap ? rightItemsArr.map(function(item) {
    return labelMap[item] === void 0 ? item : labelMap[item];
  }) : rightItemsArr;
  var formatter = function formatter2(items) {
    var template = [];
    var _items$ = items[0], name = _items$.name, axisValueLabel = _items$.axisValueLabel;
    var title = name || axisValueLabel;
    template.push(title + "<br>");
    items.forEach(function(_ref7) {
      var seriesName = _ref7.seriesName, data2 = _ref7.data, color = _ref7.color;
      if (color === "transparent" && items.length === 1) {
        color = "#6d8ff0";
      }
      var showData = null;
      var type = ~rightListArr.indexOf(seriesName) ? yAxisType[1] : yAxisType[0];
      var itemData = Array.isArray(data2) ? data2[1] : data2;
      showData = getFormatted(itemData, type, digit);
      template.push(itemPoint(color));
      template.push("" + itemLabel(seriesName) + itemContent(showData));
      template.push("<br>");
    });
    return template.join("");
  };
  return {
    trigger: "axis",
    formatter
  };
};
Core.install = function(Vue) {
  Vue.component(Core.name, Core);
};
export {
  HEAT_MAP_COLOR,
  cloneDeep,
  deepCopy,
  Core as default,
  getObj as get,
  getFormatted,
  getMapJSON,
  getRows,
  getStackMap,
  getTooltip,
  getYAxis,
  htmlHandler,
  isDefined,
  isNull,
  isObject,
  itemContent,
  itemLabel,
  itemPoint,
  _merge as merge,
  setObj as set
};

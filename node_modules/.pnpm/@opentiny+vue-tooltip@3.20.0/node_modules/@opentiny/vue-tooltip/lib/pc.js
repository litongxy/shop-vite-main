function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
import { withDirectives, createVNode, vShow } from "vue";
import { renderless, api } from "@opentiny/vue-renderless/tooltip/vue";
import { defineComponent, $prefix, $props, setup as _setup, createComponent, h, deduplicateCssClass, stringifyCssClass, hooks, parseVnode, isEmptyVnode } from "@opentiny/vue-common";
import "@opentiny/vue-theme/tooltip/index.css";
var _sfc_main = /* @__PURE__ */ defineComponent({
  name: $prefix + "Tooltip",
  componentName: "Tooltip",
  props: _extends({}, $props, {
    visible: {
      type: String,
      default: function _default() {
        return "always";
      },
      validator: function validator(value) {
        return ["always", "auto"].includes(value);
      }
    },
    adjustArrow: {
      type: Boolean,
      default: function _default2() {
        return false;
      }
    },
    appendToBody: {
      type: Boolean,
      default: function _default3() {
        return true;
      }
    },
    arrowOffset: {
      type: Number,
      default: function _default4() {
        return 0;
      }
    },
    boundariesPadding: {
      type: Number,
      default: function _default5() {
        return 5;
      }
    },
    closeDelay: {
      type: Number,
      default: function _default6() {
        return 300;
      }
    },
    content: {
      type: [String, Object]
    },
    disabled: {
      type: Boolean
    },
    effect: {
      type: String,
      default: function _default7() {
        return "dark";
      }
    },
    enterable: {
      type: Boolean,
      default: function _default8() {
        return true;
      }
    },
    hideAfter: {
      type: Number,
      default: function _default9() {
        return 0;
      }
    },
    manual: {
      type: Boolean
    },
    modelValue: {
      type: Boolean
    },
    offset: {
      default: function _default10() {
        return 0;
      }
    },
    openDelay: {
      type: Number,
      default: function _default11() {
        return 0;
      }
    },
    placement: {
      type: String,
      default: function _default12() {
        return "bottom";
      }
    },
    popper: {},
    popperClass: {
      type: String
    },
    popperOptions: {
      default: function _default13() {
        return {
          gpuAcceleration: false,
          boundariesPadding: 10
        };
      }
    },
    pre: {
      type: Boolean
    },
    reference: {},
    renderContent: {
      type: Function
    },
    tabindex: {
      type: Number,
      default: function _default14() {
        return 0;
      }
    },
    transition: {
      type: String,
      default: function _default15() {
        return "tiny-fade-in-linear";
      }
    },
    type: {
      type: String,
      validator: function validator2(value) {
        return Boolean(~["normal", "warning", "error", "info", "success"].indexOf(value));
      }
    },
    visibleArrow: {
      type: Boolean,
      default: function _default16() {
        return true;
      }
    },
    zIndex: {
      type: String,
      default: function _default17() {
        return "next";
      }
    },
    contentMaxHeight: {
      type: String
    }
  }),
  setup: function setup(props, context) {
    return _setup({
      props,
      context,
      renderless,
      api
    });
  },
  render: function render() {
    var _this = this;
    var getContent = function getContent2(vm) {
      var slotContent = vm.slots.content && vm.slots.content();
      if (slotContent && (!hooks.Comment || slotContent[0].type !== hooks.Comment)) {
        return slotContent;
      }
      var attrContent;
      if (vm.renderContent) {
        attrContent = vm.renderContent(h, vm.content);
      } else if (vm.pre) {
        attrContent = vm.content ? h("pre", vm.content) : null;
      } else {
        attrContent = vm.content;
      }
      return attrContent;
    };
    if (!Object.prototype.hasOwnProperty.call(this, "popperVM")) {
      var _cacheVm = {
        value: null
      };
      this.d({
        popperVM: {
          get: function get() {
            if (!_cacheVm.value) {
              _cacheVm.value = createComponent({
                el: document.createElement("div"),
                propsData: null,
                component: {
                  render: function render2() {
                    var content = getContent(_this);
                    var addWrapper = typeof content === "string";
                    var propsData = {
                      attrs: {
                        name: _this.transition
                      },
                      on: {
                        "after-leave": _this.doDestroy
                      }
                    };
                    var typeClass = "is-" + (_this.type || _this.effect || "dark");
                    var mouseenter = function mouseenter2() {
                      return _this.setExpectedState(true);
                    };
                    var mouseleave = function mouseleave2() {
                      _this.setExpectedState(false);
                      _this.debounceClose();
                    };
                    _this.$nextTick(function() {
                      if (!_this.disabled && _this.state.showPopper && content) {
                        _this.updatePopper();
                      }
                    });
                    return h("transition", propsData, [withDirectives(createVNode("div", {
                      "ref": "popper",
                      "id": _this.state.tooltipId,
                      "class": ["tiny-tooltip", "tiny-tooltip__popper", typeClass, _this.popperClass, {
                        "tiny-tooltip__show-tips": _this.state.showContent
                      }],
                      "style": "max-width:" + _this.state.tipsMaxWidth + "px",
                      "role": "tooltip",
                      "aria-hidden": _this.disabled || !_this.state.showPopper ? "true" : "false",
                      "onMouseenter": function onMouseenter() {
                        return mouseenter();
                      },
                      "onMouseleave": function onMouseleave() {
                        return mouseleave();
                      }
                    }, [addWrapper ? createVNode("div", {
                      "class": "tiny-tooltip__content-wrapper",
                      "style": "max-height:" + _this.contentMaxHeight
                    }, [content]) : content]), [[vShow, !_this.disabled && _this.state.showPopper && content]])]);
                  }
                }
              });
            }
            return _cacheVm.value;
          },
          set: function set(val) {
            return _cacheVm.value = val;
          }
        }
      });
    }
    var getFirstElement = function getFirstElement2() {
      var slots = _this.slots.default && _this.slots.default();
      if (!Array.isArray(slots))
        return null;
      var element = null;
      for (var index = 0; index < slots.length; index++) {
        var vnode = parseVnode(slots[index]);
        if (!isEmptyVnode(vnode)) {
          element = vnode;
          break;
        }
      }
      return element;
    };
    var firstElement = getFirstElement();
    if (!firstElement)
      return null;
    var data = firstElement.data || firstElement.props || (firstElement.props = {});
    data.class = deduplicateCssClass("tiny-tooltip " + stringifyCssClass(data.class));
    return firstElement;
  }
});
export {
  _sfc_main as default
};

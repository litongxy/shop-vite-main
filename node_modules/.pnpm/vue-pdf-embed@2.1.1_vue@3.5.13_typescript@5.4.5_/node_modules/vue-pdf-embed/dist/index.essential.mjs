var oy = Object.defineProperty;
var sg = (l) => {
  throw TypeError(l);
};
var ly = (l, e, t) => e in l ? oy(l, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : l[e] = t;
var Z = (l, e, t) => ly(l, typeof e != "symbol" ? e + "" : e, t), wu = (l, e, t) => e.has(l) || sg("Cannot " + t);
var o = (l, e, t) => (wu(l, e, "read from private field"), t ? t.call(l) : e.get(l)), y = (l, e, t) => e.has(l) ? sg("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(l) : e.set(l, t), v = (l, e, t, s) => (wu(l, e, "write to private field"), s ? s.call(l, t) : e.set(l, t), t), m = (l, e, t) => (wu(l, e, "access private method"), t);
var de = (l, e, t, s) => ({
  set _(i) {
    v(l, e, i, t);
  },
  get _() {
    return o(l, e, s);
  }
});
import { shallowRef as Fd, watchEffect as hy, toValue as ig, watch as Bu, onBeforeUnmount as um, defineComponent as cy, ref as dy, toRef as uy, computed as fy, openBlock as el, createElementBlock as sl, Fragment as py, renderList as gy, renderSlot as ng, createElementVNode as fm, normalizeStyle as my, createCommentVNode as rg } from "vue";
var vy = {
  /***/
  9306: (
    /***/
    (l, e, t) => {
      var s = t(4901), i = t(6823), n = TypeError;
      l.exports = function(r) {
        if (s(r)) return r;
        throw new n(i(r) + " is not a function");
      };
    }
  ),
  /***/
  3506: (
    /***/
    (l, e, t) => {
      var s = t(3925), i = String, n = TypeError;
      l.exports = function(r) {
        if (s(r)) return r;
        throw new n("Can't set " + i(r) + " as a prototype");
      };
    }
  ),
  /***/
  7080: (
    /***/
    (l, e, t) => {
      var s = t(4402).has;
      l.exports = function(i) {
        return s(i), i;
      };
    }
  ),
  /***/
  679: (
    /***/
    (l, e, t) => {
      var s = t(1625), i = TypeError;
      l.exports = function(n, r) {
        if (s(r, n)) return n;
        throw new i("Incorrect invocation");
      };
    }
  ),
  /***/
  8551: (
    /***/
    (l, e, t) => {
      var s = t(34), i = String, n = TypeError;
      l.exports = function(r) {
        if (s(r)) return r;
        throw new n(i(r) + " is not an object");
      };
    }
  ),
  /***/
  7811: (
    /***/
    (l) => {
      l.exports = typeof ArrayBuffer < "u" && typeof DataView < "u";
    }
  ),
  /***/
  7394: (
    /***/
    (l, e, t) => {
      var s = t(4576), i = t(6706), n = t(2195), r = s.ArrayBuffer, a = s.TypeError;
      l.exports = r && i(r.prototype, "byteLength", "get") || function(h) {
        if (n(h) !== "ArrayBuffer") throw new a("ArrayBuffer expected");
        return h.byteLength;
      };
    }
  ),
  /***/
  3238: (
    /***/
    (l, e, t) => {
      var s = t(4576), i = t(7476), n = t(7394), r = s.ArrayBuffer, a = r && r.prototype, h = a && i(a.slice);
      l.exports = function(c) {
        if (n(c) !== 0 || !h) return !1;
        try {
          return h(c, 0, 0), !1;
        } catch {
          return !0;
        }
      };
    }
  ),
  /***/
  5169: (
    /***/
    (l, e, t) => {
      var s = t(3238), i = TypeError;
      l.exports = function(n) {
        if (s(n)) throw new i("ArrayBuffer is detached");
        return n;
      };
    }
  ),
  /***/
  5636: (
    /***/
    (l, e, t) => {
      var s = t(4576), i = t(9504), n = t(6706), r = t(7696), a = t(5169), h = t(7394), c = t(4483), d = t(1548), u = s.structuredClone, f = s.ArrayBuffer, p = s.DataView, g = Math.min, b = f.prototype, E = p.prototype, A = i(b.slice), w = n(b, "resizable", "get"), x = n(b, "maxByteLength", "get"), P = i(E.getInt8), T = i(E.setInt8);
      l.exports = (d || c) && function(C, R, M) {
        var S = h(C), I = R === void 0 ? S : r(R), _ = !w || !w(C), D;
        if (a(C), d && (C = u(C, { transfer: [C] }), S === I && (M || _)))
          return C;
        if (S >= I && (!M || _))
          D = A(C, 0, I);
        else {
          var k = M && !_ && x ? { maxByteLength: x(C) } : void 0;
          D = new f(I, k);
          for (var j = new p(C), H = new p(D), L = g(I, S), F = 0; F < L; F++) T(H, F, P(j, F));
        }
        return d || c(C), D;
      };
    }
  ),
  /***/
  4644: (
    /***/
    (l, e, t) => {
      var s = t(7811), i = t(3724), n = t(4576), r = t(4901), a = t(34), h = t(9297), c = t(6955), d = t(6823), u = t(6699), f = t(6840), p = t(2106), g = t(1625), b = t(2787), E = t(2967), A = t(8227), w = t(3392), x = t(1181), P = x.enforce, T = x.get, C = n.Int8Array, R = C && C.prototype, M = n.Uint8ClampedArray, S = M && M.prototype, I = C && b(C), _ = R && b(R), D = Object.prototype, k = n.TypeError, j = A("toStringTag"), H = w("TYPED_ARRAY_TAG"), L = "TypedArrayConstructor", F = s && !!E && c(n.opera) !== "Opera", z = !1, pt, gt, zt, bt = {
        Int8Array: 1,
        Uint8Array: 1,
        Uint8ClampedArray: 1,
        Int16Array: 2,
        Uint16Array: 2,
        Int32Array: 4,
        Uint32Array: 4,
        Float32Array: 4,
        Float64Array: 8
      }, Et = {
        BigInt64Array: 8,
        BigUint64Array: 8
      }, xs = function(Mt) {
        if (!a(Mt)) return !1;
        var _t = c(Mt);
        return _t === "DataView" || h(bt, _t) || h(Et, _t);
      }, Pe = function(Q) {
        var Mt = b(Q);
        if (a(Mt)) {
          var _t = T(Mt);
          return _t && h(_t, L) ? _t[L] : Pe(Mt);
        }
      }, U = function(Q) {
        if (!a(Q)) return !1;
        var Mt = c(Q);
        return h(bt, Mt) || h(Et, Mt);
      }, N = function(Q) {
        if (U(Q)) return Q;
        throw new k("Target is not a typed array");
      }, V = function(Q) {
        if (r(Q) && (!E || g(I, Q))) return Q;
        throw new k(d(Q) + " is not a typed array constructor");
      }, st = function(Q, Mt, _t, Ss) {
        if (i) {
          if (_t) for (var Ae in bt) {
            var Zt = n[Ae];
            if (Zt && h(Zt.prototype, Q)) try {
              delete Zt.prototype[Q];
            } catch {
              try {
                Zt.prototype[Q] = Mt;
              } catch {
              }
            }
          }
          (!_[Q] || _t) && f(_, Q, _t ? Mt : F && R[Q] || Mt, Ss);
        }
      }, Tt = function(Q, Mt, _t) {
        var Ss, Ae;
        if (i) {
          if (E) {
            if (_t) {
              for (Ss in bt)
                if (Ae = n[Ss], Ae && h(Ae, Q)) try {
                  delete Ae[Q];
                } catch {
                }
            }
            if (!I[Q] || _t)
              try {
                return f(I, Q, _t ? Mt : F && I[Q] || Mt);
              } catch {
              }
            else return;
          }
          for (Ss in bt)
            Ae = n[Ss], Ae && (!Ae[Q] || _t) && f(Ae, Q, Mt);
        }
      };
      for (pt in bt)
        gt = n[pt], zt = gt && gt.prototype, zt ? P(zt)[L] = gt : F = !1;
      for (pt in Et)
        gt = n[pt], zt = gt && gt.prototype, zt && (P(zt)[L] = gt);
      if ((!F || !r(I) || I === Function.prototype) && (I = function() {
        throw new k("Incorrect invocation");
      }, F))
        for (pt in bt)
          n[pt] && E(n[pt], I);
      if ((!F || !_ || _ === D) && (_ = I.prototype, F))
        for (pt in bt)
          n[pt] && E(n[pt].prototype, _);
      if (F && b(S) !== _ && E(S, _), i && !h(_, j)) {
        z = !0, p(_, j, {
          configurable: !0,
          get: function() {
            return a(this) ? this[H] : void 0;
          }
        });
        for (pt in bt) n[pt] && u(n[pt], H, pt);
      }
      l.exports = {
        NATIVE_ARRAY_BUFFER_VIEWS: F,
        TYPED_ARRAY_TAG: z && H,
        aTypedArray: N,
        aTypedArrayConstructor: V,
        exportTypedArrayMethod: st,
        exportTypedArrayStaticMethod: Tt,
        getTypedArrayConstructor: Pe,
        isView: xs,
        isTypedArray: U,
        TypedArray: I,
        TypedArrayPrototype: _
      };
    }
  ),
  /***/
  5370: (
    /***/
    (l, e, t) => {
      var s = t(6198);
      l.exports = function(i, n, r) {
        for (var a = 0, h = arguments.length > 2 ? r : s(n), c = new i(h); h > a; ) c[a] = n[a++];
        return c;
      };
    }
  ),
  /***/
  9617: (
    /***/
    (l, e, t) => {
      var s = t(5397), i = t(5610), n = t(6198), r = function(a) {
        return function(h, c, d) {
          var u = s(h), f = n(u);
          if (f === 0) return !a && -1;
          var p = i(d, f), g;
          if (a && c !== c) {
            for (; f > p; )
              if (g = u[p++], g !== g) return !0;
          } else for (; f > p; p++)
            if ((a || p in u) && u[p] === c) return a || p || 0;
          return !a && -1;
        };
      };
      l.exports = {
        // `Array.prototype.includes` method
        // https://tc39.es/ecma262/#sec-array.prototype.includes
        includes: r(!0),
        // `Array.prototype.indexOf` method
        // https://tc39.es/ecma262/#sec-array.prototype.indexof
        indexOf: r(!1)
      };
    }
  ),
  /***/
  4527: (
    /***/
    (l, e, t) => {
      var s = t(3724), i = t(4376), n = TypeError, r = Object.getOwnPropertyDescriptor, a = s && !function() {
        if (this !== void 0) return !0;
        try {
          Object.defineProperty([], "length", { writable: !1 }).length = 1;
        } catch (h) {
          return h instanceof TypeError;
        }
      }();
      l.exports = a ? function(h, c) {
        if (i(h) && !r(h, "length").writable)
          throw new n("Cannot set read only .length");
        return h.length = c;
      } : function(h, c) {
        return h.length = c;
      };
    }
  ),
  /***/
  7628: (
    /***/
    (l, e, t) => {
      var s = t(6198);
      l.exports = function(i, n) {
        for (var r = s(i), a = new n(r), h = 0; h < r; h++) a[h] = i[r - h - 1];
        return a;
      };
    }
  ),
  /***/
  9928: (
    /***/
    (l, e, t) => {
      var s = t(6198), i = t(1291), n = RangeError;
      l.exports = function(r, a, h, c) {
        var d = s(r), u = i(h), f = u < 0 ? d + u : u;
        if (f >= d || f < 0) throw new n("Incorrect index");
        for (var p = new a(d), g = 0; g < d; g++) p[g] = g === f ? c : r[g];
        return p;
      };
    }
  ),
  /***/
  6319: (
    /***/
    (l, e, t) => {
      var s = t(8551), i = t(9539);
      l.exports = function(n, r, a, h) {
        try {
          return h ? r(s(a)[0], a[1]) : r(a);
        } catch (c) {
          i(n, "throw", c);
        }
      };
    }
  ),
  /***/
  2195: (
    /***/
    (l, e, t) => {
      var s = t(9504), i = s({}.toString), n = s("".slice);
      l.exports = function(r) {
        return n(i(r), 8, -1);
      };
    }
  ),
  /***/
  6955: (
    /***/
    (l, e, t) => {
      var s = t(2140), i = t(4901), n = t(2195), r = t(8227), a = r("toStringTag"), h = Object, c = n(/* @__PURE__ */ function() {
        return arguments;
      }()) === "Arguments", d = function(u, f) {
        try {
          return u[f];
        } catch {
        }
      };
      l.exports = s ? n : function(u) {
        var f, p, g;
        return u === void 0 ? "Undefined" : u === null ? "Null" : typeof (p = d(f = h(u), a)) == "string" ? p : c ? n(f) : (g = n(f)) === "Object" && i(f.callee) ? "Arguments" : g;
      };
    }
  ),
  /***/
  7740: (
    /***/
    (l, e, t) => {
      var s = t(9297), i = t(5031), n = t(7347), r = t(4913);
      l.exports = function(a, h, c) {
        for (var d = i(h), u = r.f, f = n.f, p = 0; p < d.length; p++) {
          var g = d[p];
          !s(a, g) && !(c && s(c, g)) && u(a, g, f(h, g));
        }
      };
    }
  ),
  /***/
  2211: (
    /***/
    (l, e, t) => {
      var s = t(9039);
      l.exports = !s(function() {
        function i() {
        }
        return i.prototype.constructor = null, Object.getPrototypeOf(new i()) !== i.prototype;
      });
    }
  ),
  /***/
  2529: (
    /***/
    (l) => {
      l.exports = function(e, t) {
        return { value: e, done: t };
      };
    }
  ),
  /***/
  6699: (
    /***/
    (l, e, t) => {
      var s = t(3724), i = t(4913), n = t(6980);
      l.exports = s ? function(r, a, h) {
        return i.f(r, a, n(1, h));
      } : function(r, a, h) {
        return r[a] = h, r;
      };
    }
  ),
  /***/
  6980: (
    /***/
    (l) => {
      l.exports = function(e, t) {
        return {
          enumerable: !(e & 1),
          configurable: !(e & 2),
          writable: !(e & 4),
          value: t
        };
      };
    }
  ),
  /***/
  4659: (
    /***/
    (l, e, t) => {
      var s = t(3724), i = t(4913), n = t(6980);
      l.exports = function(r, a, h) {
        s ? i.f(r, a, n(0, h)) : r[a] = h;
      };
    }
  ),
  /***/
  2106: (
    /***/
    (l, e, t) => {
      var s = t(283), i = t(4913);
      l.exports = function(n, r, a) {
        return a.get && s(a.get, r, { getter: !0 }), a.set && s(a.set, r, { setter: !0 }), i.f(n, r, a);
      };
    }
  ),
  /***/
  6840: (
    /***/
    (l, e, t) => {
      var s = t(4901), i = t(4913), n = t(283), r = t(9433);
      l.exports = function(a, h, c, d) {
        d || (d = {});
        var u = d.enumerable, f = d.name !== void 0 ? d.name : h;
        if (s(c) && n(c, f, d), d.global)
          u ? a[h] = c : r(h, c);
        else {
          try {
            d.unsafe ? a[h] && (u = !0) : delete a[h];
          } catch {
          }
          u ? a[h] = c : i.f(a, h, {
            value: c,
            enumerable: !1,
            configurable: !d.nonConfigurable,
            writable: !d.nonWritable
          });
        }
        return a;
      };
    }
  ),
  /***/
  6279: (
    /***/
    (l, e, t) => {
      var s = t(6840);
      l.exports = function(i, n, r) {
        for (var a in n) s(i, a, n[a], r);
        return i;
      };
    }
  ),
  /***/
  9433: (
    /***/
    (l, e, t) => {
      var s = t(4576), i = Object.defineProperty;
      l.exports = function(n, r) {
        try {
          i(s, n, { value: r, configurable: !0, writable: !0 });
        } catch {
          s[n] = r;
        }
        return r;
      };
    }
  ),
  /***/
  3724: (
    /***/
    (l, e, t) => {
      var s = t(9039);
      l.exports = !s(function() {
        return Object.defineProperty({}, 1, { get: function() {
          return 7;
        } })[1] !== 7;
      });
    }
  ),
  /***/
  4483: (
    /***/
    (l, e, t) => {
      var s = t(4576), i = t(9429), n = t(1548), r = s.structuredClone, a = s.ArrayBuffer, h = s.MessageChannel, c = !1, d, u, f, p;
      if (n)
        c = function(g) {
          r(g, { transfer: [g] });
        };
      else if (a) try {
        h || (d = i("worker_threads"), d && (h = d.MessageChannel)), h && (u = new h(), f = new a(2), p = function(g) {
          u.port1.postMessage(null, [g]);
        }, f.byteLength === 2 && (p(f), f.byteLength === 0 && (c = p)));
      } catch {
      }
      l.exports = c;
    }
  ),
  /***/
  4055: (
    /***/
    (l, e, t) => {
      var s = t(4576), i = t(34), n = s.document, r = i(n) && i(n.createElement);
      l.exports = function(a) {
        return r ? n.createElement(a) : {};
      };
    }
  ),
  /***/
  6837: (
    /***/
    (l) => {
      var e = TypeError, t = 9007199254740991;
      l.exports = function(s) {
        if (s > t) throw e("Maximum allowed index exceeded");
        return s;
      };
    }
  ),
  /***/
  5002: (
    /***/
    (l) => {
      l.exports = {
        IndexSizeError: { s: "INDEX_SIZE_ERR", c: 1, m: 1 },
        DOMStringSizeError: { s: "DOMSTRING_SIZE_ERR", c: 2, m: 0 },
        HierarchyRequestError: { s: "HIERARCHY_REQUEST_ERR", c: 3, m: 1 },
        WrongDocumentError: { s: "WRONG_DOCUMENT_ERR", c: 4, m: 1 },
        InvalidCharacterError: { s: "INVALID_CHARACTER_ERR", c: 5, m: 1 },
        NoDataAllowedError: { s: "NO_DATA_ALLOWED_ERR", c: 6, m: 0 },
        NoModificationAllowedError: { s: "NO_MODIFICATION_ALLOWED_ERR", c: 7, m: 1 },
        NotFoundError: { s: "NOT_FOUND_ERR", c: 8, m: 1 },
        NotSupportedError: { s: "NOT_SUPPORTED_ERR", c: 9, m: 1 },
        InUseAttributeError: { s: "INUSE_ATTRIBUTE_ERR", c: 10, m: 1 },
        InvalidStateError: { s: "INVALID_STATE_ERR", c: 11, m: 1 },
        SyntaxError: { s: "SYNTAX_ERR", c: 12, m: 1 },
        InvalidModificationError: { s: "INVALID_MODIFICATION_ERR", c: 13, m: 1 },
        NamespaceError: { s: "NAMESPACE_ERR", c: 14, m: 1 },
        InvalidAccessError: { s: "INVALID_ACCESS_ERR", c: 15, m: 1 },
        ValidationError: { s: "VALIDATION_ERR", c: 16, m: 0 },
        TypeMismatchError: { s: "TYPE_MISMATCH_ERR", c: 17, m: 1 },
        SecurityError: { s: "SECURITY_ERR", c: 18, m: 1 },
        NetworkError: { s: "NETWORK_ERR", c: 19, m: 1 },
        AbortError: { s: "ABORT_ERR", c: 20, m: 1 },
        URLMismatchError: { s: "URL_MISMATCH_ERR", c: 21, m: 1 },
        QuotaExceededError: { s: "QUOTA_EXCEEDED_ERR", c: 22, m: 1 },
        TimeoutError: { s: "TIMEOUT_ERR", c: 23, m: 1 },
        InvalidNodeTypeError: { s: "INVALID_NODE_TYPE_ERR", c: 24, m: 1 },
        DataCloneError: { s: "DATA_CLONE_ERR", c: 25, m: 1 }
      };
    }
  ),
  /***/
  8727: (
    /***/
    (l) => {
      l.exports = [
        "constructor",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "toLocaleString",
        "toString",
        "valueOf"
      ];
    }
  ),
  /***/
  6193: (
    /***/
    (l, e, t) => {
      var s = t(4215);
      l.exports = s === "NODE";
    }
  ),
  /***/
  2839: (
    /***/
    (l, e, t) => {
      var s = t(4576), i = s.navigator, n = i && i.userAgent;
      l.exports = n ? String(n) : "";
    }
  ),
  /***/
  9519: (
    /***/
    (l, e, t) => {
      var s = t(4576), i = t(2839), n = s.process, r = s.Deno, a = n && n.versions || r && r.version, h = a && a.v8, c, d;
      h && (c = h.split("."), d = c[0] > 0 && c[0] < 4 ? 1 : +(c[0] + c[1])), !d && i && (c = i.match(/Edge\/(\d+)/), (!c || c[1] >= 74) && (c = i.match(/Chrome\/(\d+)/), c && (d = +c[1]))), l.exports = d;
    }
  ),
  /***/
  4215: (
    /***/
    (l, e, t) => {
      var s = t(4576), i = t(2839), n = t(2195), r = function(a) {
        return i.slice(0, a.length) === a;
      };
      l.exports = function() {
        return r("Bun/") ? "BUN" : r("Cloudflare-Workers") ? "CLOUDFLARE" : r("Deno/") ? "DENO" : r("Node.js/") ? "NODE" : s.Bun && typeof Bun.version == "string" ? "BUN" : s.Deno && typeof Deno.version == "object" ? "DENO" : n(s.process) === "process" ? "NODE" : s.window && s.document ? "BROWSER" : "REST";
      }();
    }
  ),
  /***/
  8574: (
    /***/
    (l, e, t) => {
      var s = t(9504), i = Error, n = s("".replace), r = function(c) {
        return String(new i(c).stack);
      }("zxcasd"), a = /\n\s*at [^:]*:[^\n]*/, h = a.test(r);
      l.exports = function(c, d) {
        if (h && typeof c == "string" && !i.prepareStackTrace)
          for (; d--; ) c = n(c, a, "");
        return c;
      };
    }
  ),
  /***/
  6518: (
    /***/
    (l, e, t) => {
      var s = t(4576), i = t(7347).f, n = t(6699), r = t(6840), a = t(9433), h = t(7740), c = t(2796);
      l.exports = function(d, u) {
        var f = d.target, p = d.global, g = d.stat, b, E, A, w, x, P;
        if (p ? E = s : g ? E = s[f] || a(f, {}) : E = s[f] && s[f].prototype, E) for (A in u) {
          if (x = u[A], d.dontCallGetSet ? (P = i(E, A), w = P && P.value) : w = E[A], b = c(p ? A : f + (g ? "." : "#") + A, d.forced), !b && w !== void 0) {
            if (typeof x == typeof w) continue;
            h(x, w);
          }
          (d.sham || w && w.sham) && n(x, "sham", !0), r(E, A, x, d);
        }
      };
    }
  ),
  /***/
  9039: (
    /***/
    (l) => {
      l.exports = function(e) {
        try {
          return !!e();
        } catch {
          return !0;
        }
      };
    }
  ),
  /***/
  6080: (
    /***/
    (l, e, t) => {
      var s = t(7476), i = t(9306), n = t(616), r = s(s.bind);
      l.exports = function(a, h) {
        return i(a), h === void 0 ? a : n ? r(a, h) : function() {
          return a.apply(h, arguments);
        };
      };
    }
  ),
  /***/
  616: (
    /***/
    (l, e, t) => {
      var s = t(9039);
      l.exports = !s(function() {
        var i = (function() {
        }).bind();
        return typeof i != "function" || i.hasOwnProperty("prototype");
      });
    }
  ),
  /***/
  9565: (
    /***/
    (l, e, t) => {
      var s = t(616), i = Function.prototype.call;
      l.exports = s ? i.bind(i) : function() {
        return i.apply(i, arguments);
      };
    }
  ),
  /***/
  350: (
    /***/
    (l, e, t) => {
      var s = t(3724), i = t(9297), n = Function.prototype, r = s && Object.getOwnPropertyDescriptor, a = i(n, "name"), h = a && (function() {
      }).name === "something", c = a && (!s || s && r(n, "name").configurable);
      l.exports = {
        EXISTS: a,
        PROPER: h,
        CONFIGURABLE: c
      };
    }
  ),
  /***/
  6706: (
    /***/
    (l, e, t) => {
      var s = t(9504), i = t(9306);
      l.exports = function(n, r, a) {
        try {
          return s(i(Object.getOwnPropertyDescriptor(n, r)[a]));
        } catch {
        }
      };
    }
  ),
  /***/
  7476: (
    /***/
    (l, e, t) => {
      var s = t(2195), i = t(9504);
      l.exports = function(n) {
        if (s(n) === "Function") return i(n);
      };
    }
  ),
  /***/
  9504: (
    /***/
    (l, e, t) => {
      var s = t(616), i = Function.prototype, n = i.call, r = s && i.bind.bind(n, n);
      l.exports = s ? r : function(a) {
        return function() {
          return n.apply(a, arguments);
        };
      };
    }
  ),
  /***/
  9429: (
    /***/
    (l, e, t) => {
      var s = t(4576), i = t(6193);
      l.exports = function(n) {
        if (i) {
          try {
            return s.process.getBuiltinModule(n);
          } catch {
          }
          try {
            return Function('return require("' + n + '")')();
          } catch {
          }
        }
      };
    }
  ),
  /***/
  7751: (
    /***/
    (l, e, t) => {
      var s = t(4576), i = t(4901), n = function(r) {
        return i(r) ? r : void 0;
      };
      l.exports = function(r, a) {
        return arguments.length < 2 ? n(s[r]) : s[r] && s[r][a];
      };
    }
  ),
  /***/
  1767: (
    /***/
    (l) => {
      l.exports = function(e) {
        return {
          iterator: e,
          next: e.next,
          done: !1
        };
      };
    }
  ),
  /***/
  8646: (
    /***/
    (l, e, t) => {
      var s = t(9565), i = t(8551), n = t(1767), r = t(851);
      l.exports = function(a, h) {
        (!h || typeof a != "string") && i(a);
        var c = r(a);
        return n(i(c !== void 0 ? s(c, a) : a));
      };
    }
  ),
  /***/
  851: (
    /***/
    (l, e, t) => {
      var s = t(6955), i = t(5966), n = t(4117), r = t(6269), a = t(8227), h = a("iterator");
      l.exports = function(c) {
        if (!n(c)) return i(c, h) || i(c, "@@iterator") || r[s(c)];
      };
    }
  ),
  /***/
  81: (
    /***/
    (l, e, t) => {
      var s = t(9565), i = t(9306), n = t(8551), r = t(6823), a = t(851), h = TypeError;
      l.exports = function(c, d) {
        var u = arguments.length < 2 ? a(c) : d;
        if (i(u)) return n(s(u, c));
        throw new h(r(c) + " is not iterable");
      };
    }
  ),
  /***/
  5966: (
    /***/
    (l, e, t) => {
      var s = t(9306), i = t(4117);
      l.exports = function(n, r) {
        var a = n[r];
        return i(a) ? void 0 : s(a);
      };
    }
  ),
  /***/
  3789: (
    /***/
    (l, e, t) => {
      var s = t(9306), i = t(8551), n = t(9565), r = t(1291), a = t(1767), h = "Invalid size", c = RangeError, d = TypeError, u = Math.max, f = function(p, g) {
        this.set = p, this.size = u(g, 0), this.has = s(p.has), this.keys = s(p.keys);
      };
      f.prototype = {
        getIterator: function() {
          return a(i(n(this.keys, this.set)));
        },
        includes: function(p) {
          return n(this.has, this.set, p);
        }
      }, l.exports = function(p) {
        i(p);
        var g = +p.size;
        if (g !== g) throw new d(h);
        var b = r(g);
        if (b < 0) throw new c(h);
        return new f(p, b);
      };
    }
  ),
  /***/
  4576: (
    /***/
    function(l) {
      var e = function(t) {
        return t && t.Math === Math && t;
      };
      l.exports = // eslint-disable-next-line es/no-global-this -- safe
      e(typeof globalThis == "object" && globalThis) || e(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
      e(typeof self == "object" && self) || e(typeof global == "object" && global) || e(typeof this == "object" && this) || // eslint-disable-next-line no-new-func -- fallback
      /* @__PURE__ */ function() {
        return this;
      }() || Function("return this")();
    }
  ),
  /***/
  9297: (
    /***/
    (l, e, t) => {
      var s = t(9504), i = t(8981), n = s({}.hasOwnProperty);
      l.exports = Object.hasOwn || function(a, h) {
        return n(i(a), h);
      };
    }
  ),
  /***/
  421: (
    /***/
    (l) => {
      l.exports = {};
    }
  ),
  /***/
  397: (
    /***/
    (l, e, t) => {
      var s = t(7751);
      l.exports = s("document", "documentElement");
    }
  ),
  /***/
  5917: (
    /***/
    (l, e, t) => {
      var s = t(3724), i = t(9039), n = t(4055);
      l.exports = !s && !i(function() {
        return Object.defineProperty(n("div"), "a", {
          get: function() {
            return 7;
          }
        }).a !== 7;
      });
    }
  ),
  /***/
  7055: (
    /***/
    (l, e, t) => {
      var s = t(9504), i = t(9039), n = t(2195), r = Object, a = s("".split);
      l.exports = i(function() {
        return !r("z").propertyIsEnumerable(0);
      }) ? function(h) {
        return n(h) === "String" ? a(h, "") : r(h);
      } : r;
    }
  ),
  /***/
  3167: (
    /***/
    (l, e, t) => {
      var s = t(4901), i = t(34), n = t(2967);
      l.exports = function(r, a, h) {
        var c, d;
        return (
          // it can work only with native `setPrototypeOf`
          n && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
          s(c = a.constructor) && c !== h && i(d = c.prototype) && d !== h.prototype && n(r, d), r
        );
      };
    }
  ),
  /***/
  3706: (
    /***/
    (l, e, t) => {
      var s = t(9504), i = t(4901), n = t(7629), r = s(Function.toString);
      i(n.inspectSource) || (n.inspectSource = function(a) {
        return r(a);
      }), l.exports = n.inspectSource;
    }
  ),
  /***/
  1181: (
    /***/
    (l, e, t) => {
      var s = t(8622), i = t(4576), n = t(34), r = t(6699), a = t(9297), h = t(7629), c = t(6119), d = t(421), u = "Object already initialized", f = i.TypeError, p = i.WeakMap, g, b, E, A = function(T) {
        return E(T) ? b(T) : g(T, {});
      }, w = function(T) {
        return function(C) {
          var R;
          if (!n(C) || (R = b(C)).type !== T)
            throw new f("Incompatible receiver, " + T + " required");
          return R;
        };
      };
      if (s || h.state) {
        var x = h.state || (h.state = new p());
        x.get = x.get, x.has = x.has, x.set = x.set, g = function(T, C) {
          if (x.has(T)) throw new f(u);
          return C.facade = T, x.set(T, C), C;
        }, b = function(T) {
          return x.get(T) || {};
        }, E = function(T) {
          return x.has(T);
        };
      } else {
        var P = c("state");
        d[P] = !0, g = function(T, C) {
          if (a(T, P)) throw new f(u);
          return C.facade = T, r(T, P, C), C;
        }, b = function(T) {
          return a(T, P) ? T[P] : {};
        }, E = function(T) {
          return a(T, P);
        };
      }
      l.exports = {
        set: g,
        get: b,
        has: E,
        enforce: A,
        getterFor: w
      };
    }
  ),
  /***/
  4209: (
    /***/
    (l, e, t) => {
      var s = t(8227), i = t(6269), n = s("iterator"), r = Array.prototype;
      l.exports = function(a) {
        return a !== void 0 && (i.Array === a || r[n] === a);
      };
    }
  ),
  /***/
  4376: (
    /***/
    (l, e, t) => {
      var s = t(2195);
      l.exports = Array.isArray || function(n) {
        return s(n) === "Array";
      };
    }
  ),
  /***/
  1108: (
    /***/
    (l, e, t) => {
      var s = t(6955);
      l.exports = function(i) {
        var n = s(i);
        return n === "BigInt64Array" || n === "BigUint64Array";
      };
    }
  ),
  /***/
  4901: (
    /***/
    (l) => {
      var e = typeof document == "object" && document.all;
      l.exports = typeof e > "u" && e !== void 0 ? function(t) {
        return typeof t == "function" || t === e;
      } : function(t) {
        return typeof t == "function";
      };
    }
  ),
  /***/
  2796: (
    /***/
    (l, e, t) => {
      var s = t(9039), i = t(4901), n = /#|\.prototype\./, r = function(u, f) {
        var p = h[a(u)];
        return p === d ? !0 : p === c ? !1 : i(f) ? s(f) : !!f;
      }, a = r.normalize = function(u) {
        return String(u).replace(n, ".").toLowerCase();
      }, h = r.data = {}, c = r.NATIVE = "N", d = r.POLYFILL = "P";
      l.exports = r;
    }
  ),
  /***/
  4117: (
    /***/
    (l) => {
      l.exports = function(e) {
        return e == null;
      };
    }
  ),
  /***/
  34: (
    /***/
    (l, e, t) => {
      var s = t(4901);
      l.exports = function(i) {
        return typeof i == "object" ? i !== null : s(i);
      };
    }
  ),
  /***/
  3925: (
    /***/
    (l, e, t) => {
      var s = t(34);
      l.exports = function(i) {
        return s(i) || i === null;
      };
    }
  ),
  /***/
  6395: (
    /***/
    (l) => {
      l.exports = !1;
    }
  ),
  /***/
  757: (
    /***/
    (l, e, t) => {
      var s = t(7751), i = t(4901), n = t(1625), r = t(7040), a = Object;
      l.exports = r ? function(h) {
        return typeof h == "symbol";
      } : function(h) {
        var c = s("Symbol");
        return i(c) && n(c.prototype, a(h));
      };
    }
  ),
  /***/
  507: (
    /***/
    (l, e, t) => {
      var s = t(9565);
      l.exports = function(i, n, r) {
        for (var a = r ? i : i.iterator, h = i.next, c, d; !(c = s(h, a)).done; )
          if (d = n(c.value), d !== void 0) return d;
      };
    }
  ),
  /***/
  2652: (
    /***/
    (l, e, t) => {
      var s = t(6080), i = t(9565), n = t(8551), r = t(6823), a = t(4209), h = t(6198), c = t(1625), d = t(81), u = t(851), f = t(9539), p = TypeError, g = function(E, A) {
        this.stopped = E, this.result = A;
      }, b = g.prototype;
      l.exports = function(E, A, w) {
        var x = w && w.that, P = !!(w && w.AS_ENTRIES), T = !!(w && w.IS_RECORD), C = !!(w && w.IS_ITERATOR), R = !!(w && w.INTERRUPTED), M = s(A, x), S, I, _, D, k, j, H, L = function(z) {
          return S && f(S, "normal", z), new g(!0, z);
        }, F = function(z) {
          return P ? (n(z), R ? M(z[0], z[1], L) : M(z[0], z[1])) : R ? M(z, L) : M(z);
        };
        if (T)
          S = E.iterator;
        else if (C)
          S = E;
        else {
          if (I = u(E), !I) throw new p(r(E) + " is not iterable");
          if (a(I)) {
            for (_ = 0, D = h(E); D > _; _++)
              if (k = F(E[_]), k && c(b, k)) return k;
            return new g(!1);
          }
          S = d(E, I);
        }
        for (j = T ? E.next : S.next; !(H = i(j, S)).done; ) {
          try {
            k = F(H.value);
          } catch (z) {
            f(S, "throw", z);
          }
          if (typeof k == "object" && k && c(b, k)) return k;
        }
        return new g(!1);
      };
    }
  ),
  /***/
  9539: (
    /***/
    (l, e, t) => {
      var s = t(9565), i = t(8551), n = t(5966);
      l.exports = function(r, a, h) {
        var c, d;
        i(r);
        try {
          if (c = n(r, "return"), !c) {
            if (a === "throw") throw h;
            return h;
          }
          c = s(c, r);
        } catch (u) {
          d = !0, c = u;
        }
        if (a === "throw") throw h;
        if (d) throw c;
        return i(c), h;
      };
    }
  ),
  /***/
  9462: (
    /***/
    (l, e, t) => {
      var s = t(9565), i = t(2360), n = t(6699), r = t(6279), a = t(8227), h = t(1181), c = t(5966), d = t(7657).IteratorPrototype, u = t(2529), f = t(9539), p = a("toStringTag"), g = "IteratorHelper", b = "WrapForValidIterator", E = h.set, A = function(P) {
        var T = h.getterFor(P ? b : g);
        return r(i(d), {
          next: function() {
            var R = T(this);
            if (P) return R.nextHandler();
            try {
              var M = R.done ? void 0 : R.nextHandler();
              return u(M, R.done);
            } catch (S) {
              throw R.done = !0, S;
            }
          },
          return: function() {
            var C = T(this), R = C.iterator;
            if (C.done = !0, P) {
              var M = c(R, "return");
              return M ? s(M, R) : u(void 0, !0);
            }
            if (C.inner) try {
              f(C.inner.iterator, "normal");
            } catch (S) {
              return f(R, "throw", S);
            }
            return f(R, "normal"), u(void 0, !0);
          }
        });
      }, w = A(!0), x = A(!1);
      n(x, p, "Iterator Helper"), l.exports = function(P, T) {
        var C = function(M, S) {
          S ? (S.iterator = M.iterator, S.next = M.next) : S = M, S.type = T ? b : g, S.nextHandler = P, S.counter = 0, S.done = !1, E(this, S);
        };
        return C.prototype = T ? w : x, C;
      };
    }
  ),
  /***/
  713: (
    /***/
    (l, e, t) => {
      var s = t(9565), i = t(9306), n = t(8551), r = t(1767), a = t(9462), h = t(6319), c = a(function() {
        var d = this.iterator, u = n(s(this.next, d)), f = this.done = !!u.done;
        if (!f) return h(d, this.mapper, [u.value, this.counter++], !0);
      });
      l.exports = function(u) {
        return n(this), i(u), new c(r(this), {
          mapper: u
        });
      };
    }
  ),
  /***/
  7657: (
    /***/
    (l, e, t) => {
      var s = t(9039), i = t(4901), n = t(34), r = t(2360), a = t(2787), h = t(6840), c = t(8227), d = t(6395), u = c("iterator"), f = !1, p, g, b;
      [].keys && (b = [].keys(), "next" in b ? (g = a(a(b)), g !== Object.prototype && (p = g)) : f = !0);
      var E = !n(p) || s(function() {
        var A = {};
        return p[u].call(A) !== A;
      });
      E ? p = {} : d && (p = r(p)), i(p[u]) || h(p, u, function() {
        return this;
      }), l.exports = {
        IteratorPrototype: p,
        BUGGY_SAFARI_ITERATORS: f
      };
    }
  ),
  /***/
  6269: (
    /***/
    (l) => {
      l.exports = {};
    }
  ),
  /***/
  6198: (
    /***/
    (l, e, t) => {
      var s = t(8014);
      l.exports = function(i) {
        return s(i.length);
      };
    }
  ),
  /***/
  283: (
    /***/
    (l, e, t) => {
      var s = t(9504), i = t(9039), n = t(4901), r = t(9297), a = t(3724), h = t(350).CONFIGURABLE, c = t(3706), d = t(1181), u = d.enforce, f = d.get, p = String, g = Object.defineProperty, b = s("".slice), E = s("".replace), A = s([].join), w = a && !i(function() {
        return g(function() {
        }, "length", { value: 8 }).length !== 8;
      }), x = String(String).split("String"), P = l.exports = function(T, C, R) {
        b(p(C), 0, 7) === "Symbol(" && (C = "[" + E(p(C), /^Symbol\(([^)]*)\).*$/, "$1") + "]"), R && R.getter && (C = "get " + C), R && R.setter && (C = "set " + C), (!r(T, "name") || h && T.name !== C) && (a ? g(T, "name", { value: C, configurable: !0 }) : T.name = C), w && R && r(R, "arity") && T.length !== R.arity && g(T, "length", { value: R.arity });
        try {
          R && r(R, "constructor") && R.constructor ? a && g(T, "prototype", { writable: !1 }) : T.prototype && (T.prototype = void 0);
        } catch {
        }
        var M = u(T);
        return r(M, "source") || (M.source = A(x, typeof C == "string" ? C : "")), T;
      };
      Function.prototype.toString = P(function() {
        return n(this) && f(this).source || c(this);
      }, "toString");
    }
  ),
  /***/
  741: (
    /***/
    (l) => {
      var e = Math.ceil, t = Math.floor;
      l.exports = Math.trunc || function(i) {
        var n = +i;
        return (n > 0 ? t : e)(n);
      };
    }
  ),
  /***/
  6043: (
    /***/
    (l, e, t) => {
      var s = t(9306), i = TypeError, n = function(r) {
        var a, h;
        this.promise = new r(function(c, d) {
          if (a !== void 0 || h !== void 0) throw new i("Bad Promise constructor");
          a = c, h = d;
        }), this.resolve = s(a), this.reject = s(h);
      };
      l.exports.f = function(r) {
        return new n(r);
      };
    }
  ),
  /***/
  2603: (
    /***/
    (l, e, t) => {
      var s = t(655);
      l.exports = function(i, n) {
        return i === void 0 ? arguments.length < 2 ? "" : n : s(i);
      };
    }
  ),
  /***/
  4149: (
    /***/
    (l) => {
      var e = RangeError;
      l.exports = function(t) {
        if (t === t) return t;
        throw new e("NaN is not allowed");
      };
    }
  ),
  /***/
  2360: (
    /***/
    (l, e, t) => {
      var s = t(8551), i = t(6801), n = t(8727), r = t(421), a = t(397), h = t(4055), c = t(6119), d = ">", u = "<", f = "prototype", p = "script", g = c("IE_PROTO"), b = function() {
      }, E = function(T) {
        return u + p + d + T + u + "/" + p + d;
      }, A = function(T) {
        T.write(E("")), T.close();
        var C = T.parentWindow.Object;
        return T = null, C;
      }, w = function() {
        var T = h("iframe"), C = "java" + p + ":", R;
        return T.style.display = "none", a.appendChild(T), T.src = String(C), R = T.contentWindow.document, R.open(), R.write(E("document.F=Object")), R.close(), R.F;
      }, x, P = function() {
        try {
          x = new ActiveXObject("htmlfile");
        } catch {
        }
        P = typeof document < "u" ? document.domain && x ? A(x) : w() : A(x);
        for (var T = n.length; T--; ) delete P[f][n[T]];
        return P();
      };
      r[g] = !0, l.exports = Object.create || function(C, R) {
        var M;
        return C !== null ? (b[f] = s(C), M = new b(), b[f] = null, M[g] = C) : M = P(), R === void 0 ? M : i.f(M, R);
      };
    }
  ),
  /***/
  6801: (
    /***/
    (l, e, t) => {
      var s = t(3724), i = t(8686), n = t(4913), r = t(8551), a = t(5397), h = t(1072);
      e.f = s && !i ? Object.defineProperties : function(d, u) {
        r(d);
        for (var f = a(u), p = h(u), g = p.length, b = 0, E; g > b; ) n.f(d, E = p[b++], f[E]);
        return d;
      };
    }
  ),
  /***/
  4913: (
    /***/
    (l, e, t) => {
      var s = t(3724), i = t(5917), n = t(8686), r = t(8551), a = t(6969), h = TypeError, c = Object.defineProperty, d = Object.getOwnPropertyDescriptor, u = "enumerable", f = "configurable", p = "writable";
      e.f = s ? n ? function(b, E, A) {
        if (r(b), E = a(E), r(A), typeof b == "function" && E === "prototype" && "value" in A && p in A && !A[p]) {
          var w = d(b, E);
          w && w[p] && (b[E] = A.value, A = {
            configurable: f in A ? A[f] : w[f],
            enumerable: u in A ? A[u] : w[u],
            writable: !1
          });
        }
        return c(b, E, A);
      } : c : function(b, E, A) {
        if (r(b), E = a(E), r(A), i) try {
          return c(b, E, A);
        } catch {
        }
        if ("get" in A || "set" in A) throw new h("Accessors not supported");
        return "value" in A && (b[E] = A.value), b;
      };
    }
  ),
  /***/
  7347: (
    /***/
    (l, e, t) => {
      var s = t(3724), i = t(9565), n = t(8773), r = t(6980), a = t(5397), h = t(6969), c = t(9297), d = t(5917), u = Object.getOwnPropertyDescriptor;
      e.f = s ? u : function(p, g) {
        if (p = a(p), g = h(g), d) try {
          return u(p, g);
        } catch {
        }
        if (c(p, g)) return r(!i(n.f, p, g), p[g]);
      };
    }
  ),
  /***/
  8480: (
    /***/
    (l, e, t) => {
      var s = t(1828), i = t(8727), n = i.concat("length", "prototype");
      e.f = Object.getOwnPropertyNames || function(a) {
        return s(a, n);
      };
    }
  ),
  /***/
  3717: (
    /***/
    (l, e) => {
      e.f = Object.getOwnPropertySymbols;
    }
  ),
  /***/
  2787: (
    /***/
    (l, e, t) => {
      var s = t(9297), i = t(4901), n = t(8981), r = t(6119), a = t(2211), h = r("IE_PROTO"), c = Object, d = c.prototype;
      l.exports = a ? c.getPrototypeOf : function(u) {
        var f = n(u);
        if (s(f, h)) return f[h];
        var p = f.constructor;
        return i(p) && f instanceof p ? p.prototype : f instanceof c ? d : null;
      };
    }
  ),
  /***/
  1625: (
    /***/
    (l, e, t) => {
      var s = t(9504);
      l.exports = s({}.isPrototypeOf);
    }
  ),
  /***/
  1828: (
    /***/
    (l, e, t) => {
      var s = t(9504), i = t(9297), n = t(5397), r = t(9617).indexOf, a = t(421), h = s([].push);
      l.exports = function(c, d) {
        var u = n(c), f = 0, p = [], g;
        for (g in u) !i(a, g) && i(u, g) && h(p, g);
        for (; d.length > f; ) i(u, g = d[f++]) && (~r(p, g) || h(p, g));
        return p;
      };
    }
  ),
  /***/
  1072: (
    /***/
    (l, e, t) => {
      var s = t(1828), i = t(8727);
      l.exports = Object.keys || function(r) {
        return s(r, i);
      };
    }
  ),
  /***/
  8773: (
    /***/
    (l, e) => {
      var t = {}.propertyIsEnumerable, s = Object.getOwnPropertyDescriptor, i = s && !t.call({ 1: 2 }, 1);
      e.f = i ? function(r) {
        var a = s(this, r);
        return !!a && a.enumerable;
      } : t;
    }
  ),
  /***/
  2967: (
    /***/
    (l, e, t) => {
      var s = t(6706), i = t(34), n = t(7750), r = t(3506);
      l.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
        var a = !1, h = {}, c;
        try {
          c = s(Object.prototype, "__proto__", "set"), c(h, []), a = h instanceof Array;
        } catch {
        }
        return function(u, f) {
          return n(u), r(f), i(u) && (a ? c(u, f) : u.__proto__ = f), u;
        };
      }() : void 0);
    }
  ),
  /***/
  4270: (
    /***/
    (l, e, t) => {
      var s = t(9565), i = t(4901), n = t(34), r = TypeError;
      l.exports = function(a, h) {
        var c, d;
        if (h === "string" && i(c = a.toString) && !n(d = s(c, a)) || i(c = a.valueOf) && !n(d = s(c, a)) || h !== "string" && i(c = a.toString) && !n(d = s(c, a))) return d;
        throw new r("Can't convert object to primitive value");
      };
    }
  ),
  /***/
  5031: (
    /***/
    (l, e, t) => {
      var s = t(7751), i = t(9504), n = t(8480), r = t(3717), a = t(8551), h = i([].concat);
      l.exports = s("Reflect", "ownKeys") || function(d) {
        var u = n.f(a(d)), f = r.f;
        return f ? h(u, f(d)) : u;
      };
    }
  ),
  /***/
  8235: (
    /***/
    (l, e, t) => {
      var s = t(9504), i = t(9297), n = SyntaxError, r = parseInt, a = String.fromCharCode, h = s("".charAt), c = s("".slice), d = s(/./.exec), u = {
        '\\"': '"',
        "\\\\": "\\",
        "\\/": "/",
        "\\b": "\b",
        "\\f": "\f",
        "\\n": `
`,
        "\\r": "\r",
        "\\t": "	"
      }, f = /^[\da-f]{4}$/i, p = /^[\u0000-\u001F]$/;
      l.exports = function(g, b) {
        for (var E = !0, A = ""; b < g.length; ) {
          var w = h(g, b);
          if (w === "\\") {
            var x = c(g, b, b + 2);
            if (i(u, x))
              A += u[x], b += 2;
            else if (x === "\\u") {
              b += 2;
              var P = c(g, b, b + 4);
              if (!d(f, P)) throw new n("Bad Unicode escape at: " + b);
              A += a(r(P, 16)), b += 4;
            } else throw new n('Unknown escape sequence: "' + x + '"');
          } else if (w === '"') {
            E = !1, b++;
            break;
          } else {
            if (d(p, w)) throw new n("Bad control character in string literal at: " + b);
            A += w, b++;
          }
        }
        if (E) throw new n("Unterminated string at: " + b);
        return { value: A, end: b };
      };
    }
  ),
  /***/
  7750: (
    /***/
    (l, e, t) => {
      var s = t(4117), i = TypeError;
      l.exports = function(n) {
        if (s(n)) throw new i("Can't call method on " + n);
        return n;
      };
    }
  ),
  /***/
  9286: (
    /***/
    (l, e, t) => {
      var s = t(4402), i = t(8469), n = s.Set, r = s.add;
      l.exports = function(a) {
        var h = new n();
        return i(a, function(c) {
          r(h, c);
        }), h;
      };
    }
  ),
  /***/
  3440: (
    /***/
    (l, e, t) => {
      var s = t(7080), i = t(4402), n = t(9286), r = t(5170), a = t(3789), h = t(8469), c = t(507), d = i.has, u = i.remove;
      l.exports = function(p) {
        var g = s(this), b = a(p), E = n(g);
        return r(g) <= b.size ? h(g, function(A) {
          b.includes(A) && u(E, A);
        }) : c(b.getIterator(), function(A) {
          d(g, A) && u(E, A);
        }), E;
      };
    }
  ),
  /***/
  4402: (
    /***/
    (l, e, t) => {
      var s = t(9504), i = Set.prototype;
      l.exports = {
        // eslint-disable-next-line es/no-set -- safe
        Set,
        add: s(i.add),
        has: s(i.has),
        remove: s(i.delete),
        proto: i
      };
    }
  ),
  /***/
  8750: (
    /***/
    (l, e, t) => {
      var s = t(7080), i = t(4402), n = t(5170), r = t(3789), a = t(8469), h = t(507), c = i.Set, d = i.add, u = i.has;
      l.exports = function(p) {
        var g = s(this), b = r(p), E = new c();
        return n(g) > b.size ? h(b.getIterator(), function(A) {
          u(g, A) && d(E, A);
        }) : a(g, function(A) {
          b.includes(A) && d(E, A);
        }), E;
      };
    }
  ),
  /***/
  4449: (
    /***/
    (l, e, t) => {
      var s = t(7080), i = t(4402).has, n = t(5170), r = t(3789), a = t(8469), h = t(507), c = t(9539);
      l.exports = function(u) {
        var f = s(this), p = r(u);
        if (n(f) <= p.size) return a(f, function(b) {
          if (p.includes(b)) return !1;
        }, !0) !== !1;
        var g = p.getIterator();
        return h(g, function(b) {
          if (i(f, b)) return c(g, "normal", !1);
        }) !== !1;
      };
    }
  ),
  /***/
  3838: (
    /***/
    (l, e, t) => {
      var s = t(7080), i = t(5170), n = t(8469), r = t(3789);
      l.exports = function(h) {
        var c = s(this), d = r(h);
        return i(c) > d.size ? !1 : n(c, function(u) {
          if (!d.includes(u)) return !1;
        }, !0) !== !1;
      };
    }
  ),
  /***/
  8527: (
    /***/
    (l, e, t) => {
      var s = t(7080), i = t(4402).has, n = t(5170), r = t(3789), a = t(507), h = t(9539);
      l.exports = function(d) {
        var u = s(this), f = r(d);
        if (n(u) < f.size) return !1;
        var p = f.getIterator();
        return a(p, function(g) {
          if (!i(u, g)) return h(p, "normal", !1);
        }) !== !1;
      };
    }
  ),
  /***/
  8469: (
    /***/
    (l, e, t) => {
      var s = t(9504), i = t(507), n = t(4402), r = n.Set, a = n.proto, h = s(a.forEach), c = s(a.keys), d = c(new r()).next;
      l.exports = function(u, f, p) {
        return p ? i({ iterator: c(u), next: d }, f) : h(u, f);
      };
    }
  ),
  /***/
  4916: (
    /***/
    (l, e, t) => {
      var s = t(7751), i = function(n) {
        return {
          size: n,
          has: function() {
            return !1;
          },
          keys: function() {
            return {
              next: function() {
                return { done: !0 };
              }
            };
          }
        };
      };
      l.exports = function(n) {
        var r = s("Set");
        try {
          new r()[n](i(0));
          try {
            return new r()[n](i(-1)), !1;
          } catch {
            return !0;
          }
        } catch {
          return !1;
        }
      };
    }
  ),
  /***/
  5170: (
    /***/
    (l, e, t) => {
      var s = t(6706), i = t(4402);
      l.exports = s(i.proto, "size", "get") || function(n) {
        return n.size;
      };
    }
  ),
  /***/
  3650: (
    /***/
    (l, e, t) => {
      var s = t(7080), i = t(4402), n = t(9286), r = t(3789), a = t(507), h = i.add, c = i.has, d = i.remove;
      l.exports = function(f) {
        var p = s(this), g = r(f).getIterator(), b = n(p);
        return a(g, function(E) {
          c(p, E) ? d(b, E) : h(b, E);
        }), b;
      };
    }
  ),
  /***/
  4204: (
    /***/
    (l, e, t) => {
      var s = t(7080), i = t(4402).add, n = t(9286), r = t(3789), a = t(507);
      l.exports = function(c) {
        var d = s(this), u = r(c).getIterator(), f = n(d);
        return a(u, function(p) {
          i(f, p);
        }), f;
      };
    }
  ),
  /***/
  6119: (
    /***/
    (l, e, t) => {
      var s = t(5745), i = t(3392), n = s("keys");
      l.exports = function(r) {
        return n[r] || (n[r] = i(r));
      };
    }
  ),
  /***/
  7629: (
    /***/
    (l, e, t) => {
      var s = t(6395), i = t(4576), n = t(9433), r = "__core-js_shared__", a = l.exports = i[r] || n(r, {});
      (a.versions || (a.versions = [])).push({
        version: "3.38.1",
        mode: s ? "pure" : "global",
        copyright: "Â© 2014-2024 Denis Pushkarev (zloirock.ru)",
        license: "https://github.com/zloirock/core-js/blob/v3.38.1/LICENSE",
        source: "https://github.com/zloirock/core-js"
      });
    }
  ),
  /***/
  5745: (
    /***/
    (l, e, t) => {
      var s = t(7629);
      l.exports = function(i, n) {
        return s[i] || (s[i] = n || {});
      };
    }
  ),
  /***/
  1548: (
    /***/
    (l, e, t) => {
      var s = t(4576), i = t(9039), n = t(9519), r = t(4215), a = s.structuredClone;
      l.exports = !!a && !i(function() {
        if (r === "DENO" && n > 92 || r === "NODE" && n > 94 || r === "BROWSER" && n > 97) return !1;
        var h = new ArrayBuffer(8), c = a(h, { transfer: [h] });
        return h.byteLength !== 0 || c.byteLength !== 8;
      });
    }
  ),
  /***/
  4495: (
    /***/
    (l, e, t) => {
      var s = t(9519), i = t(9039), n = t(4576), r = n.String;
      l.exports = !!Object.getOwnPropertySymbols && !i(function() {
        var a = Symbol("symbol detection");
        return !r(a) || !(Object(a) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
        !Symbol.sham && s && s < 41;
      });
    }
  ),
  /***/
  5610: (
    /***/
    (l, e, t) => {
      var s = t(1291), i = Math.max, n = Math.min;
      l.exports = function(r, a) {
        var h = s(r);
        return h < 0 ? i(h + a, 0) : n(h, a);
      };
    }
  ),
  /***/
  5854: (
    /***/
    (l, e, t) => {
      var s = t(2777), i = TypeError;
      l.exports = function(n) {
        var r = s(n, "number");
        if (typeof r == "number") throw new i("Can't convert number to bigint");
        return BigInt(r);
      };
    }
  ),
  /***/
  7696: (
    /***/
    (l, e, t) => {
      var s = t(1291), i = t(8014), n = RangeError;
      l.exports = function(r) {
        if (r === void 0) return 0;
        var a = s(r), h = i(a);
        if (a !== h) throw new n("Wrong length or index");
        return h;
      };
    }
  ),
  /***/
  5397: (
    /***/
    (l, e, t) => {
      var s = t(7055), i = t(7750);
      l.exports = function(n) {
        return s(i(n));
      };
    }
  ),
  /***/
  1291: (
    /***/
    (l, e, t) => {
      var s = t(741);
      l.exports = function(i) {
        var n = +i;
        return n !== n || n === 0 ? 0 : s(n);
      };
    }
  ),
  /***/
  8014: (
    /***/
    (l, e, t) => {
      var s = t(1291), i = Math.min;
      l.exports = function(n) {
        var r = s(n);
        return r > 0 ? i(r, 9007199254740991) : 0;
      };
    }
  ),
  /***/
  8981: (
    /***/
    (l, e, t) => {
      var s = t(7750), i = Object;
      l.exports = function(n) {
        return i(s(n));
      };
    }
  ),
  /***/
  9590: (
    /***/
    (l, e, t) => {
      var s = t(1291), i = RangeError;
      l.exports = function(n) {
        var r = s(n);
        if (r < 0) throw new i("The argument can't be less than 0");
        return r;
      };
    }
  ),
  /***/
  2777: (
    /***/
    (l, e, t) => {
      var s = t(9565), i = t(34), n = t(757), r = t(5966), a = t(4270), h = t(8227), c = TypeError, d = h("toPrimitive");
      l.exports = function(u, f) {
        if (!i(u) || n(u)) return u;
        var p = r(u, d), g;
        if (p) {
          if (f === void 0 && (f = "default"), g = s(p, u, f), !i(g) || n(g)) return g;
          throw new c("Can't convert object to primitive value");
        }
        return f === void 0 && (f = "number"), a(u, f);
      };
    }
  ),
  /***/
  6969: (
    /***/
    (l, e, t) => {
      var s = t(2777), i = t(757);
      l.exports = function(n) {
        var r = s(n, "string");
        return i(r) ? r : r + "";
      };
    }
  ),
  /***/
  2140: (
    /***/
    (l, e, t) => {
      var s = t(8227), i = s("toStringTag"), n = {};
      n[i] = "z", l.exports = String(n) === "[object z]";
    }
  ),
  /***/
  655: (
    /***/
    (l, e, t) => {
      var s = t(6955), i = String;
      l.exports = function(n) {
        if (s(n) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
        return i(n);
      };
    }
  ),
  /***/
  6823: (
    /***/
    (l) => {
      var e = String;
      l.exports = function(t) {
        try {
          return e(t);
        } catch {
          return "Object";
        }
      };
    }
  ),
  /***/
  3392: (
    /***/
    (l, e, t) => {
      var s = t(9504), i = 0, n = Math.random(), r = s(1 .toString);
      l.exports = function(a) {
        return "Symbol(" + (a === void 0 ? "" : a) + ")_" + r(++i + n, 36);
      };
    }
  ),
  /***/
  7040: (
    /***/
    (l, e, t) => {
      var s = t(4495);
      l.exports = s && !Symbol.sham && typeof Symbol.iterator == "symbol";
    }
  ),
  /***/
  8686: (
    /***/
    (l, e, t) => {
      var s = t(3724), i = t(9039);
      l.exports = s && i(function() {
        return Object.defineProperty(function() {
        }, "prototype", {
          value: 42,
          writable: !1
        }).prototype !== 42;
      });
    }
  ),
  /***/
  2812: (
    /***/
    (l) => {
      var e = TypeError;
      l.exports = function(t, s) {
        if (t < s) throw new e("Not enough arguments");
        return t;
      };
    }
  ),
  /***/
  8622: (
    /***/
    (l, e, t) => {
      var s = t(4576), i = t(4901), n = s.WeakMap;
      l.exports = i(n) && /native code/.test(String(n));
    }
  ),
  /***/
  8227: (
    /***/
    (l, e, t) => {
      var s = t(4576), i = t(5745), n = t(9297), r = t(3392), a = t(4495), h = t(7040), c = s.Symbol, d = i("wks"), u = h ? c.for || c : c && c.withoutSetter || r;
      l.exports = function(f) {
        return n(d, f) || (d[f] = a && n(c, f) ? c[f] : u("Symbol." + f)), d[f];
      };
    }
  ),
  /***/
  6573: (
    /***/
    (l, e, t) => {
      var s = t(3724), i = t(2106), n = t(3238), r = ArrayBuffer.prototype;
      s && !("detached" in r) && i(r, "detached", {
        configurable: !0,
        get: function() {
          return n(this);
        }
      });
    }
  ),
  /***/
  7936: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(5636);
      i && s({ target: "ArrayBuffer", proto: !0 }, {
        transferToFixedLength: function() {
          return i(this, arguments.length ? arguments[0] : void 0, !1);
        }
      });
    }
  ),
  /***/
  8100: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(5636);
      i && s({ target: "ArrayBuffer", proto: !0 }, {
        transfer: function() {
          return i(this, arguments.length ? arguments[0] : void 0, !0);
        }
      });
    }
  ),
  /***/
  4114: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(8981), n = t(6198), r = t(4527), a = t(6837), h = t(9039), c = h(function() {
        return [].push.call({ length: 4294967296 }, 1) !== 4294967297;
      }), d = function() {
        try {
          Object.defineProperty([], "length", { writable: !1 }).push();
        } catch (f) {
          return f instanceof TypeError;
        }
      }, u = c || !d();
      s({ target: "Array", proto: !0, arity: 1, forced: u }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        push: function(p) {
          var g = i(this), b = n(g), E = arguments.length;
          a(b + E);
          for (var A = 0; A < E; A++)
            g[b] = arguments[A], b++;
          return r(g, b), b;
        }
      });
    }
  ),
  /***/
  4628: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(6043);
      s({ target: "Promise", stat: !0 }, {
        withResolvers: function() {
          var r = i.f(this);
          return {
            promise: r.promise,
            resolve: r.resolve,
            reject: r.reject
          };
        }
      });
    }
  ),
  /***/
  7642: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(3440), n = t(4916);
      s({ target: "Set", proto: !0, real: !0, forced: !n("difference") }, {
        difference: i
      });
    }
  ),
  /***/
  8004: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(9039), n = t(8750), r = t(4916), a = !r("intersection") || i(function() {
        return String(Array.from((/* @__PURE__ */ new Set([1, 2, 3])).intersection(/* @__PURE__ */ new Set([3, 2])))) !== "3,2";
      });
      s({ target: "Set", proto: !0, real: !0, forced: a }, {
        intersection: n
      });
    }
  ),
  /***/
  3853: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(4449), n = t(4916);
      s({ target: "Set", proto: !0, real: !0, forced: !n("isDisjointFrom") }, {
        isDisjointFrom: i
      });
    }
  ),
  /***/
  5876: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(3838), n = t(4916);
      s({ target: "Set", proto: !0, real: !0, forced: !n("isSubsetOf") }, {
        isSubsetOf: i
      });
    }
  ),
  /***/
  2475: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(8527), n = t(4916);
      s({ target: "Set", proto: !0, real: !0, forced: !n("isSupersetOf") }, {
        isSupersetOf: i
      });
    }
  ),
  /***/
  5024: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(3650), n = t(4916);
      s({ target: "Set", proto: !0, real: !0, forced: !n("symmetricDifference") }, {
        symmetricDifference: i
      });
    }
  ),
  /***/
  1698: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(4204), n = t(4916);
      s({ target: "Set", proto: !0, real: !0, forced: !n("union") }, {
        union: i
      });
    }
  ),
  /***/
  7467: (
    /***/
    (l, e, t) => {
      var s = t(7628), i = t(4644), n = i.aTypedArray, r = i.exportTypedArrayMethod, a = i.getTypedArrayConstructor;
      r("toReversed", function() {
        return s(n(this), a(this));
      });
    }
  ),
  /***/
  4732: (
    /***/
    (l, e, t) => {
      var s = t(4644), i = t(9504), n = t(9306), r = t(5370), a = s.aTypedArray, h = s.getTypedArrayConstructor, c = s.exportTypedArrayMethod, d = i(s.TypedArrayPrototype.sort);
      c("toSorted", function(f) {
        f !== void 0 && n(f);
        var p = a(this), g = r(h(p), p);
        return d(g, f);
      });
    }
  ),
  /***/
  9577: (
    /***/
    (l, e, t) => {
      var s = t(9928), i = t(4644), n = t(1108), r = t(1291), a = t(5854), h = i.aTypedArray, c = i.getTypedArrayConstructor, d = i.exportTypedArrayMethod, u = !!function() {
        try {
          new Int8Array(1).with(2, { valueOf: function() {
            throw 8;
          } });
        } catch (f) {
          return f === 8;
        }
      }();
      d("with", function(f, p) {
        var g = h(this), b = r(f), E = n(g) ? a(p) : +p;
        return s(g, c(g), b, E);
      }, !u);
    }
  ),
  /***/
  8992: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(4576), n = t(679), r = t(8551), a = t(4901), h = t(2787), c = t(2106), d = t(4659), u = t(9039), f = t(9297), p = t(8227), g = t(7657).IteratorPrototype, b = t(3724), E = t(6395), A = "constructor", w = "Iterator", x = p("toStringTag"), P = TypeError, T = i[w], C = E || !a(T) || T.prototype !== g || !u(function() {
        T({});
      }), R = function() {
        if (n(this, g), h(this) === g) throw new P("Abstract class Iterator not directly constructable");
      }, M = function(S, I) {
        b ? c(g, S, {
          configurable: !0,
          get: function() {
            return I;
          },
          set: function(_) {
            if (r(this), this === g) throw new P("You can't redefine this property");
            f(this, S) ? this[S] = _ : d(this, S, _);
          }
        }) : g[S] = I;
      };
      f(g, x) || M(x, w), (C || !f(g, A) || g[A] === Object) && M(A, R), R.prototype = g, s({ global: !0, constructor: !0, forced: C }, {
        Iterator: R
      });
    }
  ),
  /***/
  4743: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(9565), n = t(8551), r = t(1767), a = t(4149), h = t(9590), c = t(9462), d = t(6395), u = c(function() {
        for (var f = this.iterator, p = this.next, g, b; this.remaining; )
          if (this.remaining--, g = n(i(p, f)), b = this.done = !!g.done, b) return;
        if (g = n(i(p, f)), b = this.done = !!g.done, !b) return g.value;
      });
      s({ target: "Iterator", proto: !0, real: !0, forced: d }, {
        drop: function(p) {
          n(this);
          var g = h(a(+p));
          return new u(r(this), {
            remaining: g
          });
        }
      });
    }
  ),
  /***/
  3215: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(2652), n = t(9306), r = t(8551), a = t(1767);
      s({ target: "Iterator", proto: !0, real: !0 }, {
        every: function(c) {
          r(this), n(c);
          var d = a(this), u = 0;
          return !i(d, function(f, p) {
            if (!c(f, u++)) return p();
          }, { IS_RECORD: !0, INTERRUPTED: !0 }).stopped;
        }
      });
    }
  ),
  /***/
  4520: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(9565), n = t(9306), r = t(8551), a = t(1767), h = t(9462), c = t(6319), d = t(6395), u = h(function() {
        for (var f = this.iterator, p = this.predicate, g = this.next, b, E, A; ; ) {
          if (b = r(i(g, f)), E = this.done = !!b.done, E) return;
          if (A = b.value, c(f, p, [A, this.counter++], !0)) return A;
        }
      });
      s({ target: "Iterator", proto: !0, real: !0, forced: d }, {
        filter: function(p) {
          return r(this), n(p), new u(a(this), {
            predicate: p
          });
        }
      });
    }
  ),
  /***/
  670: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(9565), n = t(9306), r = t(8551), a = t(1767), h = t(8646), c = t(9462), d = t(9539), u = t(6395), f = c(function() {
        for (var p = this.iterator, g = this.mapper, b, E; ; ) {
          if (E = this.inner) try {
            if (b = r(i(E.next, E.iterator)), !b.done) return b.value;
            this.inner = null;
          } catch (A) {
            d(p, "throw", A);
          }
          if (b = r(i(this.next, p)), this.done = !!b.done) return;
          try {
            this.inner = h(g(b.value, this.counter++), !1);
          } catch (A) {
            d(p, "throw", A);
          }
        }
      });
      s({ target: "Iterator", proto: !0, real: !0, forced: u }, {
        flatMap: function(g) {
          return r(this), n(g), new f(a(this), {
            mapper: g,
            inner: null
          });
        }
      });
    }
  ),
  /***/
  1454: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(713), n = t(6395);
      s({ target: "Iterator", proto: !0, real: !0, forced: n }, {
        map: i
      });
    }
  ),
  /***/
  7550: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(2652), n = t(9306), r = t(8551), a = t(1767);
      s({ target: "Iterator", proto: !0, real: !0 }, {
        some: function(c) {
          r(this), n(c);
          var d = a(this), u = 0;
          return i(d, function(f, p) {
            if (c(f, u++)) return p();
          }, { IS_RECORD: !0, INTERRUPTED: !0 }).stopped;
        }
      });
    }
  ),
  /***/
  8335: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(3724), n = t(4576), r = t(7751), a = t(9504), h = t(9565), c = t(4901), d = t(34), u = t(4376), f = t(9297), p = t(655), g = t(6198), b = t(4659), E = t(9039), A = t(8235), w = t(4495), x = n.JSON, P = n.Number, T = n.SyntaxError, C = x && x.parse, R = r("Object", "keys"), M = Object.getOwnPropertyDescriptor, S = a("".charAt), I = a("".slice), _ = a(/./.exec), D = a([].push), k = /^\d$/, j = /^[1-9]$/, H = /^[\d-]$/, L = /^[\t\n\r ]$/, F = 0, z = 1, pt = function(U, N) {
        U = p(U);
        var V = new Et(U, 0), st = V.parse(), Tt = st.value, Q = V.skip(L, st.end);
        if (Q < U.length)
          throw new T('Unexpected extra character: "' + S(U, Q) + '" after the parsed data at: ' + Q);
        return c(N) ? gt({ "": Tt }, "", N, st) : Tt;
      }, gt = function(U, N, V, st) {
        var Tt = U[N], Q = st && Tt === st.value, Mt = Q && typeof st.source == "string" ? { source: st.source } : {}, _t, Ss, Ae, Zt, Ea;
        if (d(Tt)) {
          var Eu = u(Tt), Dc = Q ? st.nodes : Eu ? [] : {};
          if (Eu)
            for (_t = Dc.length, Ae = g(Tt), Zt = 0; Zt < Ae; Zt++)
              zt(Tt, Zt, gt(Tt, "" + Zt, V, Zt < _t ? Dc[Zt] : void 0));
          else
            for (Ss = R(Tt), Ae = g(Ss), Zt = 0; Zt < Ae; Zt++)
              Ea = Ss[Zt], zt(Tt, Ea, gt(Tt, Ea, V, f(Dc, Ea) ? Dc[Ea] : void 0));
        }
        return h(V, U, N, Tt, Mt);
      }, zt = function(U, N, V) {
        if (i) {
          var st = M(U, N);
          if (st && !st.configurable) return;
        }
        V === void 0 ? delete U[N] : b(U, N, V);
      }, bt = function(U, N, V, st) {
        this.value = U, this.end = N, this.source = V, this.nodes = st;
      }, Et = function(U, N) {
        this.source = U, this.index = N;
      };
      Et.prototype = {
        fork: function(U) {
          return new Et(this.source, U);
        },
        parse: function() {
          var U = this.source, N = this.skip(L, this.index), V = this.fork(N), st = S(U, N);
          if (_(H, st)) return V.number();
          switch (st) {
            case "{":
              return V.object();
            case "[":
              return V.array();
            case '"':
              return V.string();
            case "t":
              return V.keyword(!0);
            case "f":
              return V.keyword(!1);
            case "n":
              return V.keyword(null);
          }
          throw new T('Unexpected character: "' + st + '" at: ' + N);
        },
        node: function(U, N, V, st, Tt) {
          return new bt(N, st, U ? null : I(this.source, V, st), Tt);
        },
        object: function() {
          for (var U = this.source, N = this.index + 1, V = !1, st = {}, Tt = {}; N < U.length; ) {
            if (N = this.until(['"', "}"], N), S(U, N) === "}" && !V) {
              N++;
              break;
            }
            var Q = this.fork(N).string(), Mt = Q.value;
            N = Q.end, N = this.until([":"], N) + 1, N = this.skip(L, N), Q = this.fork(N).parse(), b(Tt, Mt, Q), b(st, Mt, Q.value), N = this.until([",", "}"], Q.end);
            var _t = S(U, N);
            if (_t === ",")
              V = !0, N++;
            else if (_t === "}") {
              N++;
              break;
            }
          }
          return this.node(z, st, this.index, N, Tt);
        },
        array: function() {
          for (var U = this.source, N = this.index + 1, V = !1, st = [], Tt = []; N < U.length; ) {
            if (N = this.skip(L, N), S(U, N) === "]" && !V) {
              N++;
              break;
            }
            var Q = this.fork(N).parse();
            if (D(Tt, Q), D(st, Q.value), N = this.until([",", "]"], Q.end), S(U, N) === ",")
              V = !0, N++;
            else if (S(U, N) === "]") {
              N++;
              break;
            }
          }
          return this.node(z, st, this.index, N, Tt);
        },
        string: function() {
          var U = this.index, N = A(this.source, this.index + 1);
          return this.node(F, N.value, U, N.end);
        },
        number: function() {
          var U = this.source, N = this.index, V = N;
          if (S(U, V) === "-" && V++, S(U, V) === "0") V++;
          else if (_(j, S(U, V))) V = this.skip(k, V + 1);
          else throw new T("Failed to parse number at: " + V);
          if (S(U, V) === "." && (V = this.skip(k, V + 1)), S(U, V) === "e" || S(U, V) === "E") {
            V++, (S(U, V) === "+" || S(U, V) === "-") && V++;
            var st = V;
            if (V = this.skip(k, V), st === V) throw new T("Failed to parse number's exponent value at: " + V);
          }
          return this.node(F, P(I(U, N, V)), N, V);
        },
        keyword: function(U) {
          var N = "" + U, V = this.index, st = V + N.length;
          if (I(this.source, V, st) !== N) throw new T("Failed to parse value at: " + V);
          return this.node(F, U, V, st);
        },
        skip: function(U, N) {
          for (var V = this.source; N < V.length && _(U, S(V, N)); N++) ;
          return N;
        },
        until: function(U, N) {
          N = this.skip(L, N);
          for (var V = S(this.source, N), st = 0; st < U.length; st++) if (U[st] === V) return N;
          throw new T('Unexpected character: "' + V + '" at: ' + N);
        }
      };
      var xs = E(function() {
        var U = "9007199254740993", N;
        return C(U, function(V, st, Tt) {
          N = Tt.source;
        }), N !== U;
      }), Pe = w && !E(function() {
        return 1 / C("-0 	") !== -1 / 0;
      });
      s({ target: "JSON", stat: !0, forced: xs }, {
        parse: function(N, V) {
          return Pe && !c(V) ? C(N) : pt(N, V);
        }
      });
    }
  ),
  /***/
  4979: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(4576), n = t(7751), r = t(6980), a = t(4913).f, h = t(9297), c = t(679), d = t(3167), u = t(2603), f = t(5002), p = t(8574), g = t(3724), b = t(6395), E = "DOMException", A = n("Error"), w = n(E), x = function() {
        c(this, P);
        var L = arguments.length, F = u(L < 1 ? void 0 : arguments[0]), z = u(L < 2 ? void 0 : arguments[1], "Error"), pt = new w(F, z), gt = new A(F);
        return gt.name = E, a(pt, "stack", r(1, p(gt.stack, 1))), d(pt, this, x), pt;
      }, P = x.prototype = w.prototype, T = "stack" in new A(E), C = "stack" in new w(1, 2), R = w && g && Object.getOwnPropertyDescriptor(i, E), M = !!R && !(R.writable && R.configurable), S = T && !M && !C;
      s({ global: !0, constructor: !0, forced: b || S }, {
        // TODO: fix export logic
        DOMException: S ? x : w
      });
      var I = n(E), _ = I.prototype;
      if (_.constructor !== I) {
        b || a(_, "constructor", r(1, I));
        for (var D in f) if (h(f, D)) {
          var k = f[D], j = k.s;
          h(I, j) || a(I, j, r(6, k.c));
        }
      }
    }
  ),
  /***/
  4603: (
    /***/
    (l, e, t) => {
      var s = t(6840), i = t(9504), n = t(655), r = t(2812), a = URLSearchParams, h = a.prototype, c = i(h.append), d = i(h.delete), u = i(h.forEach), f = i([].push), p = new a("a=1&a=2&b=3");
      p.delete("a", 1), p.delete("b", void 0), p + "" != "a=2" && s(h, "delete", function(g) {
        var b = arguments.length, E = b < 2 ? void 0 : arguments[1];
        if (b && E === void 0) return d(this, g);
        var A = [];
        u(this, function(S, I) {
          f(A, { key: I, value: S });
        }), r(b, 1);
        for (var w = n(g), x = n(E), P = 0, T = 0, C = !1, R = A.length, M; P < R; )
          M = A[P++], C || M.key === w ? (C = !0, d(this, M.key)) : T++;
        for (; T < R; )
          M = A[T++], M.key === w && M.value === x || c(this, M.key, M.value);
      }, { enumerable: !0, unsafe: !0 });
    }
  ),
  /***/
  7566: (
    /***/
    (l, e, t) => {
      var s = t(6840), i = t(9504), n = t(655), r = t(2812), a = URLSearchParams, h = a.prototype, c = i(h.getAll), d = i(h.has), u = new a("a=1");
      (u.has("a", 2) || !u.has("a", void 0)) && s(h, "has", function(p) {
        var g = arguments.length, b = g < 2 ? void 0 : arguments[1];
        if (g && b === void 0) return d(this, p);
        var E = c(this, p);
        r(g, 1);
        for (var A = n(b), w = 0; w < E.length; )
          if (E[w++] === A) return !0;
        return !1;
      }, { enumerable: !0, unsafe: !0 });
    }
  ),
  /***/
  8721: (
    /***/
    (l, e, t) => {
      var s = t(3724), i = t(9504), n = t(2106), r = URLSearchParams.prototype, a = i(r.forEach);
      s && !("size" in r) && n(r, "size", {
        get: function() {
          var c = 0;
          return a(this, function() {
            c++;
          }), c;
        },
        configurable: !0,
        enumerable: !0
      });
    }
  )
  /******/
}, ag = {};
function dt(l) {
  var e = ag[l];
  if (e !== void 0)
    return e.exports;
  var t = ag[l] = {
    /******/
    // no module.id needed
    /******/
    // no module.loaded needed
    /******/
    exports: {}
    /******/
  };
  return vy[l].call(t.exports, t, t.exports, dt), t.exports;
}
dt.d = (l, e) => {
  for (var t in e)
    dt.o(e, t) && !dt.o(l, t) && Object.defineProperty(l, t, { enumerable: !0, get: e[t] });
};
dt.o = (l, e) => Object.prototype.hasOwnProperty.call(l, e);
var q = globalThis.pdfjsLib = {};
dt.d(q, {
  AbortException: () => (
    /* reexport */
    ya
  ),
  AnnotationEditorLayer: () => (
    /* reexport */
    mE
  ),
  AnnotationEditorParamsType: () => (
    /* reexport */
    J
  ),
  AnnotationEditorType: () => (
    /* reexport */
    it
  ),
  AnnotationEditorUIManager: () => (
    /* reexport */
    kl
  ),
  AnnotationLayer: () => (
    /* reexport */
    pE
  ),
  AnnotationMode: () => (
    /* reexport */
    Zi
  ),
  CMapCompressionType: () => (
    /* reexport */
    $u
  ),
  ColorPicker: () => (
    /* reexport */
    Fv
  ),
  DOMSVGFactory: () => (
    /* reexport */
    $p
  ),
  DrawLayer: () => (
    /* reexport */
    vE
  ),
  FeatureTest: () => (
    /* reexport */
    ke
  ),
  GlobalWorkerOptions: () => (
    /* reexport */
    Zn
  ),
  ImageKind: () => (
    /* reexport */
    Kc
  ),
  InvalidPDFException: () => (
    /* reexport */
    gm
  ),
  MissingPDFException: () => (
    /* reexport */
    ba
  ),
  OPS: () => (
    /* reexport */
    hs
  ),
  OutputScale: () => (
    /* reexport */
    Xu
  ),
  PDFDataRangeTransport: () => (
    /* reexport */
    dv
  ),
  PDFDateString: () => (
    /* reexport */
    Sm
  ),
  PDFWorker: () => (
    /* reexport */
    ad
  ),
  PasswordResponses: () => (
    /* reexport */
    Ey
  ),
  PermissionFlag: () => (
    /* reexport */
    Ay
  ),
  PixelsPerInch: () => (
    /* reexport */
    Qo
  ),
  RenderingCancelledException: () => (
    /* reexport */
    Vp
  ),
  TextLayer: () => (
    /* reexport */
    Af
  ),
  UnexpectedResponseException: () => (
    /* reexport */
    pu
  ),
  Util: () => (
    /* reexport */
    X
  ),
  VerbosityLevel: () => (
    /* reexport */
    du
  ),
  XfaLayer: () => (
    /* reexport */
    fv
  ),
  build: () => (
    /* reexport */
    YA
  ),
  createValidAbsoluteUrl: () => (
    /* reexport */
    Ty
  ),
  fetchData: () => (
    /* reexport */
    mu
  ),
  getDocument: () => (
    /* reexport */
    HA
  ),
  getFilenameFromUrl: () => (
    /* reexport */
    ky
  ),
  getPdfFilenameFromUrl: () => (
    /* reexport */
    Fy
  ),
  getXfaPageViewport: () => (
    /* reexport */
    jy
  ),
  isDataScheme: () => (
    /* reexport */
    vu
  ),
  isPdfFile: () => (
    /* reexport */
    Up
  ),
  noContextMenu: () => (
    /* reexport */
    os
  ),
  normalizeUnicode: () => (
    /* reexport */
    My
  ),
  setLayerDimensions: () => (
    /* reexport */
    pa
  ),
  shadow: () => (
    /* reexport */
    ht
  ),
  version: () => (
    /* reexport */
    KA
  )
});
dt(4114);
dt(6573);
dt(8100);
dt(7936);
dt(7467);
dt(4732);
dt(9577);
dt(4603);
dt(7566);
dt(8721);
const ye = typeof process == "object" && process + "" == "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser"), pm = [1, 0, 0, 1, 0, 0], Hu = [1e-3, 0, 0, 1e-3, 0, 0], by = 1e7, xu = 1.35, Xe = {
  ANY: 1,
  DISPLAY: 2,
  PRINT: 4,
  SAVE: 8,
  ANNOTATIONS_FORMS: 16,
  ANNOTATIONS_STORAGE: 32,
  ANNOTATIONS_DISABLE: 64,
  IS_EDITING: 128,
  OPLIST: 256
}, Zi = {
  DISABLE: 0,
  ENABLE: 1,
  ENABLE_FORMS: 2,
  ENABLE_STORAGE: 3
}, yy = "pdfjs_internal_editor_", it = {
  DISABLE: -1,
  NONE: 0,
  FREETEXT: 3,
  HIGHLIGHT: 9,
  STAMP: 13,
  INK: 15
}, J = {
  RESIZE: 1,
  CREATE: 2,
  FREETEXT_SIZE: 11,
  FREETEXT_COLOR: 12,
  FREETEXT_OPACITY: 13,
  INK_COLOR: 21,
  INK_THICKNESS: 22,
  INK_OPACITY: 23,
  HIGHLIGHT_COLOR: 31,
  HIGHLIGHT_DEFAULT_COLOR: 32,
  HIGHLIGHT_THICKNESS: 33,
  HIGHLIGHT_FREE: 34,
  HIGHLIGHT_SHOW_ALL: 35
}, Ay = {
  PRINT: 4,
  MODIFY_CONTENTS: 8,
  COPY: 16,
  MODIFY_ANNOTATIONS: 32,
  FILL_INTERACTIVE_FORMS: 256,
  COPY_FOR_ACCESSIBILITY: 512,
  ASSEMBLE: 1024,
  PRINT_HIGH_QUALITY: 2048
}, ue = {
  FILL: 0,
  STROKE: 1,
  FILL_STROKE: 2,
  INVISIBLE: 3,
  FILL_ADD_TO_PATH: 4,
  STROKE_ADD_TO_PATH: 5,
  FILL_STROKE_ADD_TO_PATH: 6,
  ADD_TO_PATH: 7,
  FILL_STROKE_MASK: 3,
  ADD_TO_PATH_FLAG: 4
}, Kc = {
  GRAYSCALE_1BPP: 1,
  RGB_24BPP: 2,
  RGBA_32BPP: 3
}, Wt = {
  TEXT: 1,
  LINK: 2,
  FREETEXT: 3,
  LINE: 4,
  SQUARE: 5,
  CIRCLE: 6,
  POLYGON: 7,
  POLYLINE: 8,
  HIGHLIGHT: 9,
  UNDERLINE: 10,
  SQUIGGLY: 11,
  STRIKEOUT: 12,
  STAMP: 13,
  CARET: 14,
  INK: 15,
  POPUP: 16,
  FILEATTACHMENT: 17,
  SOUND: 18,
  MOVIE: 19,
  WIDGET: 20,
  SCREEN: 21,
  PRINTERMARK: 22,
  TRAPNET: 23,
  WATERMARK: 24,
  THREED: 25,
  REDACT: 26
}, il = {
  SOLID: 1,
  DASHED: 2,
  BEVELED: 3,
  INSET: 4,
  UNDERLINE: 5
}, du = {
  ERRORS: 0,
  WARNINGS: 1,
  INFOS: 5
}, $u = {
  NONE: 0,
  BINARY: 1
}, hs = {
  dependency: 1,
  setLineWidth: 2,
  setLineCap: 3,
  setLineJoin: 4,
  setMiterLimit: 5,
  setDash: 6,
  setRenderingIntent: 7,
  setFlatness: 8,
  setGState: 9,
  save: 10,
  restore: 11,
  transform: 12,
  moveTo: 13,
  lineTo: 14,
  curveTo: 15,
  curveTo2: 16,
  curveTo3: 17,
  closePath: 18,
  rectangle: 19,
  stroke: 20,
  closeStroke: 21,
  fill: 22,
  eoFill: 23,
  fillStroke: 24,
  eoFillStroke: 25,
  closeFillStroke: 26,
  closeEOFillStroke: 27,
  endPath: 28,
  clip: 29,
  eoClip: 30,
  beginText: 31,
  endText: 32,
  setCharSpacing: 33,
  setWordSpacing: 34,
  setHScale: 35,
  setLeading: 36,
  setFont: 37,
  setTextRenderingMode: 38,
  setTextRise: 39,
  moveText: 40,
  setLeadingMoveText: 41,
  setTextMatrix: 42,
  nextLine: 43,
  showText: 44,
  showSpacedText: 45,
  nextLineShowText: 46,
  nextLineSetSpacingShowText: 47,
  setCharWidth: 48,
  setCharWidthAndBounds: 49,
  setStrokeColorSpace: 50,
  setFillColorSpace: 51,
  setStrokeColor: 52,
  setStrokeColorN: 53,
  setFillColor: 54,
  setFillColorN: 55,
  setStrokeGray: 56,
  setFillGray: 57,
  setStrokeRGBColor: 58,
  setFillRGBColor: 59,
  setStrokeCMYKColor: 60,
  setFillCMYKColor: 61,
  shadingFill: 62,
  beginInlineImage: 63,
  beginImageData: 64,
  endInlineImage: 65,
  paintXObject: 66,
  markPoint: 67,
  markPointProps: 68,
  beginMarkedContent: 69,
  beginMarkedContentProps: 70,
  endMarkedContent: 71,
  beginCompat: 72,
  endCompat: 73,
  paintFormXObjectBegin: 74,
  paintFormXObjectEnd: 75,
  beginGroup: 76,
  endGroup: 77,
  beginAnnotation: 80,
  endAnnotation: 81,
  paintImageMaskXObject: 83,
  paintImageMaskXObjectGroup: 84,
  paintImageXObject: 85,
  paintInlineImageXObject: 86,
  paintInlineImageXObjectGroup: 87,
  paintImageXObjectRepeat: 88,
  paintImageMaskXObjectRepeat: 89,
  paintSolidColorImageMask: 90,
  constructPath: 91,
  setStrokeTransparent: 92,
  setFillTransparent: 93
}, Ey = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
let uu = du.WARNINGS;
function wy(l) {
  Number.isInteger(l) && (uu = l);
}
function xy() {
  return uu;
}
function fu(l) {
  uu >= du.INFOS && console.log(`Info: ${l}`);
}
function nt(l) {
  uu >= du.WARNINGS && console.log(`Warning: ${l}`);
}
function Ut(l) {
  throw new Error(l);
}
function Qt(l, e) {
  l || Ut(e);
}
function Sy(l) {
  switch (l == null ? void 0 : l.protocol) {
    case "http:":
    case "https:":
    case "ftp:":
    case "mailto:":
    case "tel:":
      return !0;
    default:
      return !1;
  }
}
function Ty(l, e = null, t = null) {
  if (!l)
    return null;
  try {
    if (t && typeof l == "string") {
      if (t.addDefaultProtocol && l.startsWith("www.")) {
        const i = l.match(/\./g);
        (i == null ? void 0 : i.length) >= 2 && (l = `http://${l}`);
      }
      if (t.tryConvertEncoding)
        try {
          l = Ly(l);
        } catch {
        }
    }
    const s = e ? new URL(l, e) : new URL(l);
    if (Sy(s))
      return s;
  } catch {
  }
  return null;
}
function ht(l, e, t, s = !1) {
  return Object.defineProperty(l, e, {
    value: t,
    enumerable: !s,
    configurable: !0,
    writable: !1
  }), t;
}
const zn = function() {
  function e(t, s) {
    this.message = t, this.name = s;
  }
  return e.prototype = new Error(), e.constructor = e, e;
}();
class Vu extends zn {
  constructor(e, t) {
    super(e, "PasswordException"), this.code = t;
  }
}
class Uu extends zn {
  constructor(e, t) {
    super(e, "UnknownErrorException"), this.details = t;
  }
}
let gm = class extends zn {
  constructor(e) {
    super(e, "InvalidPDFException");
  }
}, ba = class extends zn {
  constructor(e) {
    super(e, "MissingPDFException");
  }
}, pu = class extends zn {
  constructor(e, t) {
    super(e, "UnexpectedResponseException"), this.status = t;
  }
};
class Py extends zn {
  constructor(e) {
    super(e, "FormatError");
  }
}
let ya = class extends zn {
  constructor(e) {
    super(e, "AbortException");
  }
};
function mm(l) {
  (typeof l != "object" || (l == null ? void 0 : l.length) === void 0) && Ut("Invalid argument for bytesToString");
  const e = l.length, t = 8192;
  if (e < t)
    return String.fromCharCode.apply(null, l);
  const s = [];
  for (let i = 0; i < e; i += t) {
    const n = Math.min(i + t, e), r = l.subarray(i, n);
    s.push(String.fromCharCode.apply(null, r));
  }
  return s.join("");
}
function gu(l) {
  typeof l != "string" && Ut("Invalid argument for stringToBytes");
  const e = l.length, t = new Uint8Array(e);
  for (let s = 0; s < e; ++s)
    t[s] = l.charCodeAt(s) & 255;
  return t;
}
function Cy(l) {
  return String.fromCharCode(l >> 24 & 255, l >> 16 & 255, l >> 8 & 255, l & 255);
}
function Bp(l) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const [t, s] of l)
    e[t] = s;
  return e;
}
function Ry() {
  const l = new Uint8Array(4);
  return l[0] = 1, new Uint32Array(l.buffer, 0, 1)[0] === 1;
}
function Iy() {
  try {
    return new Function(""), !0;
  } catch {
    return !1;
  }
}
class ke {
  static get isLittleEndian() {
    return ht(this, "isLittleEndian", Ry());
  }
  static get isEvalSupported() {
    return ht(this, "isEvalSupported", Iy());
  }
  static get isOffscreenCanvasSupported() {
    return ht(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
  }
  static get platform() {
    return typeof navigator < "u" && typeof (navigator == null ? void 0 : navigator.platform) == "string" ? ht(this, "platform", {
      isMac: navigator.platform.includes("Mac"),
      isWindows: navigator.platform.includes("Win"),
      isFirefox: typeof (navigator == null ? void 0 : navigator.userAgent) == "string" && navigator.userAgent.includes("Firefox")
    }) : ht(this, "platform", {
      isMac: !1,
      isWindows: !1,
      isFirefox: !1
    });
  }
  static get isCSSRoundSupported() {
    var e, t;
    return ht(this, "isCSSRoundSupported", (t = (e = globalThis.CSS) == null ? void 0 : e.supports) == null ? void 0 : t.call(e, "width: round(1.5px, 1px)"));
  }
}
const Su = Array.from(Array(256).keys(), (l) => l.toString(16).padStart(2, "0"));
var $i, ju, Yc, zu;
let X = (ju = class {
  static makeHexColor(e, t, s) {
    return `#${Su[e]}${Su[t]}${Su[s]}`;
  }
  static scaleMinMax(e, t) {
    let s;
    e[0] ? (e[0] < 0 && (s = t[0], t[0] = t[2], t[2] = s), t[0] *= e[0], t[2] *= e[0], e[3] < 0 && (s = t[1], t[1] = t[3], t[3] = s), t[1] *= e[3], t[3] *= e[3]) : (s = t[0], t[0] = t[1], t[1] = s, s = t[2], t[2] = t[3], t[3] = s, e[1] < 0 && (s = t[1], t[1] = t[3], t[3] = s), t[1] *= e[1], t[3] *= e[1], e[2] < 0 && (s = t[0], t[0] = t[2], t[2] = s), t[0] *= e[2], t[2] *= e[2]), t[0] += e[4], t[1] += e[5], t[2] += e[4], t[3] += e[5];
  }
  static transform(e, t) {
    return [e[0] * t[0] + e[2] * t[1], e[1] * t[0] + e[3] * t[1], e[0] * t[2] + e[2] * t[3], e[1] * t[2] + e[3] * t[3], e[0] * t[4] + e[2] * t[5] + e[4], e[1] * t[4] + e[3] * t[5] + e[5]];
  }
  static applyTransform(e, t) {
    const s = e[0] * t[0] + e[1] * t[2] + t[4], i = e[0] * t[1] + e[1] * t[3] + t[5];
    return [s, i];
  }
  static applyInverseTransform(e, t) {
    const s = t[0] * t[3] - t[1] * t[2], i = (e[0] * t[3] - e[1] * t[2] + t[2] * t[5] - t[4] * t[3]) / s, n = (-e[0] * t[1] + e[1] * t[0] + t[4] * t[1] - t[5] * t[0]) / s;
    return [i, n];
  }
  static getAxialAlignedBoundingBox(e, t) {
    const s = this.applyTransform(e, t), i = this.applyTransform(e.slice(2, 4), t), n = this.applyTransform([e[0], e[3]], t), r = this.applyTransform([e[2], e[1]], t);
    return [Math.min(s[0], i[0], n[0], r[0]), Math.min(s[1], i[1], n[1], r[1]), Math.max(s[0], i[0], n[0], r[0]), Math.max(s[1], i[1], n[1], r[1])];
  }
  static inverseTransform(e) {
    const t = e[0] * e[3] - e[1] * e[2];
    return [e[3] / t, -e[1] / t, -e[2] / t, e[0] / t, (e[2] * e[5] - e[4] * e[3]) / t, (e[4] * e[1] - e[5] * e[0]) / t];
  }
  static singularValueDecompose2dScale(e) {
    const t = [e[0], e[2], e[1], e[3]], s = e[0] * t[0] + e[1] * t[2], i = e[0] * t[1] + e[1] * t[3], n = e[2] * t[0] + e[3] * t[2], r = e[2] * t[1] + e[3] * t[3], a = (s + r) / 2, h = Math.sqrt((s + r) ** 2 - 4 * (s * r - n * i)) / 2, c = a + h || 1, d = a - h || 1;
    return [Math.sqrt(c), Math.sqrt(d)];
  }
  static normalizeRect(e) {
    const t = e.slice(0);
    return e[0] > e[2] && (t[0] = e[2], t[2] = e[0]), e[1] > e[3] && (t[1] = e[3], t[3] = e[1]), t;
  }
  static intersect(e, t) {
    const s = Math.max(Math.min(e[0], e[2]), Math.min(t[0], t[2])), i = Math.min(Math.max(e[0], e[2]), Math.max(t[0], t[2]));
    if (s > i)
      return null;
    const n = Math.max(Math.min(e[1], e[3]), Math.min(t[1], t[3])), r = Math.min(Math.max(e[1], e[3]), Math.max(t[1], t[3]));
    return n > r ? null : [s, n, i, r];
  }
  static bezierBoundingBox(e, t, s, i, n, r, a, h, c) {
    return c ? (c[0] = Math.min(c[0], e, a), c[1] = Math.min(c[1], t, h), c[2] = Math.max(c[2], e, a), c[3] = Math.max(c[3], t, h)) : c = [Math.min(e, a), Math.min(t, h), Math.max(e, a), Math.max(t, h)], m(this, $i, zu).call(this, e, s, n, a, t, i, r, h, 3 * (-e + 3 * (s - n) + a), 6 * (e - 2 * s + n), 3 * (s - e), c), m(this, $i, zu).call(this, e, s, n, a, t, i, r, h, 3 * (-t + 3 * (i - r) + h), 6 * (t - 2 * i + r), 3 * (i - t), c), c;
  }
}, $i = new WeakSet(), Yc = function(e, t, s, i, n, r, a, h, c, d) {
  if (c <= 0 || c >= 1)
    return;
  const u = 1 - c, f = c * c, p = f * c, g = u * (u * (u * e + 3 * c * t) + 3 * f * s) + p * i, b = u * (u * (u * n + 3 * c * r) + 3 * f * a) + p * h;
  d[0] = Math.min(d[0], g), d[1] = Math.min(d[1], b), d[2] = Math.max(d[2], g), d[3] = Math.max(d[3], b);
}, zu = function(e, t, s, i, n, r, a, h, c, d, u, f) {
  if (Math.abs(c) < 1e-12) {
    Math.abs(d) >= 1e-12 && m(this, $i, Yc).call(this, e, t, s, i, n, r, a, h, -u / d, f);
    return;
  }
  const p = d ** 2 - 4 * u * c;
  if (p < 0)
    return;
  const g = Math.sqrt(p), b = 2 * c;
  m(this, $i, Yc).call(this, e, t, s, i, n, r, a, h, (-d + g) / b, f), m(this, $i, Yc).call(this, e, t, s, i, n, r, a, h, (-d - g) / b, f);
}, y(ju, $i), ju);
function Ly(l) {
  return decodeURIComponent(escape(l));
}
let Tu = null, og = null;
function My(l) {
  return Tu || (Tu = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, og = /* @__PURE__ */ new Map([["ï¬", "Å¿t"]])), l.replaceAll(Tu, (e, t, s) => t ? t.normalize("NFKC") : og.get(s));
}
function _y() {
  if (typeof crypto < "u" && typeof (crypto == null ? void 0 : crypto.randomUUID) == "function")
    return crypto.randomUUID();
  const l = new Uint8Array(32);
  if (typeof crypto < "u" && typeof (crypto == null ? void 0 : crypto.getRandomValues) == "function")
    crypto.getRandomValues(l);
  else
    for (let e = 0; e < 32; e++)
      l[e] = Math.floor(Math.random() * 255);
  return mm(l);
}
const Hp = "pdfjs_internal_id_", si = {
  BEZIER_CURVE_TO: 0,
  MOVE_TO: 1,
  LINE_TO: 2,
  QUADRATIC_CURVE_TO: 3,
  RESTORE: 4,
  SAVE: 5,
  SCALE: 6,
  TRANSFORM: 7,
  TRANSLATE: 8
};
dt(4628);
dt(7642);
dt(8004);
dt(3853);
dt(5876);
dt(2475);
dt(5024);
dt(1698);
dt(1454);
dt(4979);
dt(8992);
dt(4743);
dt(3215);
dt(7550);
dt(8335);
dt(4520);
class vm {
  addFilter(e) {
    return "none";
  }
  addHCMFilter(e, t) {
    return "none";
  }
  addAlphaFilter(e) {
    return "none";
  }
  addLuminosityFilter(e) {
    return "none";
  }
  addHighlightHCMFilter(e, t, s, i, n) {
    return "none";
  }
  destroy(e = !1) {
  }
}
var $l;
class bm {
  constructor({
    enableHWA: e = !1
  }) {
    y(this, $l, !1);
    v(this, $l, e);
  }
  create(e, t) {
    if (e <= 0 || t <= 0)
      throw new Error("Invalid canvas size");
    const s = this._createCanvas(e, t);
    return {
      canvas: s,
      context: s.getContext("2d", {
        willReadFrequently: !o(this, $l)
      })
    };
  }
  reset(e, t, s) {
    if (!e.canvas)
      throw new Error("Canvas is not specified");
    if (t <= 0 || s <= 0)
      throw new Error("Invalid canvas size");
    e.canvas.width = t, e.canvas.height = s;
  }
  destroy(e) {
    if (!e.canvas)
      throw new Error("Canvas is not specified");
    e.canvas.width = 0, e.canvas.height = 0, e.canvas = null, e.context = null;
  }
  _createCanvas(e, t) {
    Ut("Abstract method `_createCanvas` called.");
  }
}
$l = new WeakMap();
class ym {
  constructor({
    baseUrl: e = null,
    isCompressed: t = !0
  }) {
    this.baseUrl = e, this.isCompressed = t;
  }
  async fetch({
    name: e
  }) {
    if (!this.baseUrl)
      throw new Error("Ensure that the `cMapUrl` and `cMapPacked` API parameters are provided.");
    if (!e)
      throw new Error("CMap name must be specified.");
    const t = this.baseUrl + e + (this.isCompressed ? ".bcmap" : ""), s = this.isCompressed ? $u.BINARY : $u.NONE;
    return this._fetchData(t, s).catch((i) => {
      throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${t}`);
    });
  }
  _fetchData(e, t) {
    Ut("Abstract method `_fetchData` called.");
  }
}
class Am {
  constructor({
    baseUrl: e = null
  }) {
    this.baseUrl = e;
  }
  async fetch({
    filename: e
  }) {
    if (!this.baseUrl)
      throw new Error("Ensure that the `standardFontDataUrl` API parameter is provided.");
    if (!e)
      throw new Error("Font filename must be specified.");
    const t = `${this.baseUrl}${e}`;
    return this._fetchData(t).catch((s) => {
      throw new Error(`Unable to load font data at: ${t}`);
    });
  }
  _fetchData(e) {
    Ut("Abstract method `_fetchData` called.");
  }
}
class Oy {
  create(e, t, s = !1) {
    if (e <= 0 || t <= 0)
      throw new Error("Invalid SVG dimensions");
    const i = this._createSVG("svg:svg");
    return i.setAttribute("version", "1.1"), s || (i.setAttribute("width", `${e}px`), i.setAttribute("height", `${t}px`)), i.setAttribute("preserveAspectRatio", "none"), i.setAttribute("viewBox", `0 0 ${e} ${t}`), i;
  }
  createElement(e) {
    if (typeof e != "string")
      throw new Error("Invalid SVG element type");
    return this._createSVG(e);
  }
  _createSVG(e) {
    Ut("Abstract method `_createSVG` called.");
  }
}
const ni = "http://www.w3.org/2000/svg";
var Zs;
let Qo = (Zs = class {
}, Z(Zs, "CSS", 96), Z(Zs, "PDF", 72), Z(Zs, "PDF_TO_CSS_UNITS", Zs.CSS / Zs.PDF), Zs);
var tr, er, Cs, hi, pe, Wd, sr, W, fe, wa, xa, Qc, Sa, Em, Wu, Ta, hl, cl, Gu, dl;
class Ny extends vm {
  constructor({
    docId: t,
    ownerDocument: s = globalThis.document
  }) {
    super();
    y(this, W);
    y(this, tr);
    y(this, er);
    y(this, Cs);
    y(this, hi);
    y(this, pe);
    y(this, Wd);
    y(this, sr, 0);
    v(this, hi, t), v(this, pe, s);
  }
  addFilter(t) {
    if (!t)
      return "none";
    let s = o(this, W, fe).get(t);
    if (s)
      return s;
    const [i, n, r] = m(this, W, Qc).call(this, t), a = t.length === 1 ? i : `${i}${n}${r}`;
    if (s = o(this, W, fe).get(a), s)
      return o(this, W, fe).set(t, s), s;
    const h = `g_${o(this, hi)}_transfer_map_${de(this, sr)._++}`, c = m(this, W, Sa).call(this, h);
    o(this, W, fe).set(t, c), o(this, W, fe).set(a, c);
    const d = m(this, W, Ta).call(this, h);
    return m(this, W, cl).call(this, i, n, r, d), c;
  }
  addHCMFilter(t, s) {
    var g;
    const i = `${t}-${s}`, n = "base";
    let r = o(this, W, wa).get(n);
    if ((r == null ? void 0 : r.key) === i || (r ? ((g = r.filter) == null || g.remove(), r.key = i, r.url = "none", r.filter = null) : (r = {
      key: i,
      url: "none",
      filter: null
    }, o(this, W, wa).set(n, r)), !t || !s))
      return r.url;
    const a = m(this, W, dl).call(this, t);
    t = X.makeHexColor(...a);
    const h = m(this, W, dl).call(this, s);
    if (s = X.makeHexColor(...h), o(this, W, xa).style.color = "", t === "#000000" && s === "#ffffff" || t === s)
      return r.url;
    const c = new Array(256);
    for (let b = 0; b <= 255; b++) {
      const E = b / 255;
      c[b] = E <= 0.03928 ? E / 12.92 : ((E + 0.055) / 1.055) ** 2.4;
    }
    const d = c.join(","), u = `g_${o(this, hi)}_hcm_filter`, f = r.filter = m(this, W, Ta).call(this, u);
    m(this, W, cl).call(this, d, d, d, f), m(this, W, Wu).call(this, f);
    const p = (b, E) => {
      const A = a[b] / 255, w = h[b] / 255, x = new Array(E + 1);
      for (let P = 0; P <= E; P++)
        x[P] = A + P / E * (w - A);
      return x.join(",");
    };
    return m(this, W, cl).call(this, p(0, 5), p(1, 5), p(2, 5), f), r.url = m(this, W, Sa).call(this, u), r.url;
  }
  addAlphaFilter(t) {
    let s = o(this, W, fe).get(t);
    if (s)
      return s;
    const [i] = m(this, W, Qc).call(this, [t]), n = `alpha_${i}`;
    if (s = o(this, W, fe).get(n), s)
      return o(this, W, fe).set(t, s), s;
    const r = `g_${o(this, hi)}_alpha_map_${de(this, sr)._++}`, a = m(this, W, Sa).call(this, r);
    o(this, W, fe).set(t, a), o(this, W, fe).set(n, a);
    const h = m(this, W, Ta).call(this, r);
    return m(this, W, Gu).call(this, i, h), a;
  }
  addLuminosityFilter(t) {
    let s = o(this, W, fe).get(t || "luminosity");
    if (s)
      return s;
    let i, n;
    if (t ? ([i] = m(this, W, Qc).call(this, [t]), n = `luminosity_${i}`) : n = "luminosity", s = o(this, W, fe).get(n), s)
      return o(this, W, fe).set(t, s), s;
    const r = `g_${o(this, hi)}_luminosity_map_${de(this, sr)._++}`, a = m(this, W, Sa).call(this, r);
    o(this, W, fe).set(t, a), o(this, W, fe).set(n, a);
    const h = m(this, W, Ta).call(this, r);
    return m(this, W, Em).call(this, h), t && m(this, W, Gu).call(this, i, h), a;
  }
  addHighlightHCMFilter(t, s, i, n, r) {
    var w;
    const a = `${s}-${i}-${n}-${r}`;
    let h = o(this, W, wa).get(t);
    if ((h == null ? void 0 : h.key) === a || (h ? ((w = h.filter) == null || w.remove(), h.key = a, h.url = "none", h.filter = null) : (h = {
      key: a,
      url: "none",
      filter: null
    }, o(this, W, wa).set(t, h)), !s || !i))
      return h.url;
    const [c, d] = [s, i].map(m(this, W, dl).bind(this));
    let u = Math.round(0.2126 * c[0] + 0.7152 * c[1] + 0.0722 * c[2]), f = Math.round(0.2126 * d[0] + 0.7152 * d[1] + 0.0722 * d[2]), [p, g] = [n, r].map(m(this, W, dl).bind(this));
    f < u && ([u, f, p, g] = [f, u, g, p]), o(this, W, xa).style.color = "";
    const b = (x, P, T) => {
      const C = new Array(256), R = (f - u) / T, M = x / 255, S = (P - x) / (255 * T);
      let I = 0;
      for (let _ = 0; _ <= T; _++) {
        const D = Math.round(u + _ * R), k = M + _ * S;
        for (let j = I; j <= D; j++)
          C[j] = k;
        I = D + 1;
      }
      for (let _ = I; _ < 256; _++)
        C[_] = C[I - 1];
      return C.join(",");
    }, E = `g_${o(this, hi)}_hcm_${t}_filter`, A = h.filter = m(this, W, Ta).call(this, E);
    return m(this, W, Wu).call(this, A), m(this, W, cl).call(this, b(p[0], g[0], 5), b(p[1], g[1], 5), b(p[2], g[2], 5), A), h.url = m(this, W, Sa).call(this, E), h.url;
  }
  destroy(t = !1) {
    t && o(this, W, wa).size !== 0 || (o(this, Cs) && (o(this, Cs).parentNode.parentNode.remove(), v(this, Cs, null)), o(this, er) && (o(this, er).clear(), v(this, er, null)), v(this, sr, 0));
  }
}
tr = new WeakMap(), er = new WeakMap(), Cs = new WeakMap(), hi = new WeakMap(), pe = new WeakMap(), Wd = new WeakMap(), sr = new WeakMap(), W = new WeakSet(), fe = function() {
  return o(this, er) || v(this, er, /* @__PURE__ */ new Map());
}, wa = function() {
  return o(this, Wd) || v(this, Wd, /* @__PURE__ */ new Map());
}, xa = function() {
  if (!o(this, Cs)) {
    const t = o(this, pe).createElement("div"), {
      style: s
    } = t;
    s.visibility = "hidden", s.contain = "strict", s.width = s.height = 0, s.position = "absolute", s.top = s.left = 0, s.zIndex = -1;
    const i = o(this, pe).createElementNS(ni, "svg");
    i.setAttribute("width", 0), i.setAttribute("height", 0), v(this, Cs, o(this, pe).createElementNS(ni, "defs")), t.append(i), i.append(o(this, Cs)), o(this, pe).body.append(t);
  }
  return o(this, Cs);
}, Qc = function(t) {
  if (t.length === 1) {
    const c = t[0], d = new Array(256);
    for (let f = 0; f < 256; f++)
      d[f] = c[f] / 255;
    const u = d.join(",");
    return [u, u, u];
  }
  const [s, i, n] = t, r = new Array(256), a = new Array(256), h = new Array(256);
  for (let c = 0; c < 256; c++)
    r[c] = s[c] / 255, a[c] = i[c] / 255, h[c] = n[c] / 255;
  return [r.join(","), a.join(","), h.join(",")];
}, Sa = function(t) {
  if (o(this, tr) === void 0) {
    v(this, tr, "");
    const s = o(this, pe).URL;
    s !== o(this, pe).baseURI && (vu(s) ? nt('#createUrl: ignore "data:"-URL for performance reasons.') : v(this, tr, s.split("#", 1)[0]));
  }
  return `url(${o(this, tr)}#${t})`;
}, Em = function(t) {
  const s = o(this, pe).createElementNS(ni, "feColorMatrix");
  s.setAttribute("type", "matrix"), s.setAttribute("values", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0"), t.append(s);
}, Wu = function(t) {
  const s = o(this, pe).createElementNS(ni, "feColorMatrix");
  s.setAttribute("type", "matrix"), s.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0"), t.append(s);
}, Ta = function(t) {
  const s = o(this, pe).createElementNS(ni, "filter");
  return s.setAttribute("color-interpolation-filters", "sRGB"), s.setAttribute("id", t), o(this, W, xa).append(s), s;
}, hl = function(t, s, i) {
  const n = o(this, pe).createElementNS(ni, s);
  n.setAttribute("type", "discrete"), n.setAttribute("tableValues", i), t.append(n);
}, cl = function(t, s, i, n) {
  const r = o(this, pe).createElementNS(ni, "feComponentTransfer");
  n.append(r), m(this, W, hl).call(this, r, "feFuncR", t), m(this, W, hl).call(this, r, "feFuncG", s), m(this, W, hl).call(this, r, "feFuncB", i);
}, Gu = function(t, s) {
  const i = o(this, pe).createElementNS(ni, "feComponentTransfer");
  s.append(i), m(this, W, hl).call(this, i, "feFuncA", t);
}, dl = function(t) {
  return o(this, W, xa).style.color = t, zp(getComputedStyle(o(this, W, xa)).getPropertyValue("color"));
};
class Dy extends bm {
  constructor({
    ownerDocument: e = globalThis.document,
    enableHWA: t = !1
  }) {
    super({
      enableHWA: t
    }), this._document = e;
  }
  _createCanvas(e, t) {
    const s = this._document.createElement("canvas");
    return s.width = e, s.height = t, s;
  }
}
async function mu(l, e = "text") {
  if (ul(l, document.baseURI)) {
    const t = await fetch(l);
    if (!t.ok)
      throw new Error(t.statusText);
    switch (e) {
      case "arraybuffer":
        return t.arrayBuffer();
      case "blob":
        return t.blob();
      case "json":
        return t.json();
    }
    return t.text();
  }
  return new Promise((t, s) => {
    const i = new XMLHttpRequest();
    i.open("GET", l, !0), i.responseType = e, i.onreadystatechange = () => {
      if (i.readyState === XMLHttpRequest.DONE) {
        if (i.status === 200 || i.status === 0) {
          switch (e) {
            case "arraybuffer":
            case "blob":
            case "json":
              t(i.response);
              return;
          }
          t(i.responseText);
          return;
        }
        s(new Error(i.statusText));
      }
    }, i.send(null);
  });
}
class wm extends ym {
  _fetchData(e, t) {
    return mu(e, this.isCompressed ? "arraybuffer" : "text").then((s) => ({
      cMapData: s instanceof ArrayBuffer ? new Uint8Array(s) : gu(s),
      compressionType: t
    }));
  }
}
class xm extends Am {
  _fetchData(e) {
    return mu(e, "arraybuffer").then((t) => new Uint8Array(t));
  }
}
let $p = class extends Oy {
  _createSVG(e) {
    return document.createElementNS(ni, e);
  }
};
class _c {
  constructor({
    viewBox: e,
    scale: t,
    rotation: s,
    offsetX: i = 0,
    offsetY: n = 0,
    dontFlip: r = !1
  }) {
    this.viewBox = e, this.scale = t, this.rotation = s, this.offsetX = i, this.offsetY = n;
    const a = (e[2] + e[0]) / 2, h = (e[3] + e[1]) / 2;
    let c, d, u, f;
    switch (s %= 360, s < 0 && (s += 360), s) {
      case 180:
        c = -1, d = 0, u = 0, f = 1;
        break;
      case 90:
        c = 0, d = 1, u = 1, f = 0;
        break;
      case 270:
        c = 0, d = -1, u = -1, f = 0;
        break;
      case 0:
        c = 1, d = 0, u = 0, f = -1;
        break;
      default:
        throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
    }
    r && (u = -u, f = -f);
    let p, g, b, E;
    c === 0 ? (p = Math.abs(h - e[1]) * t + i, g = Math.abs(a - e[0]) * t + n, b = (e[3] - e[1]) * t, E = (e[2] - e[0]) * t) : (p = Math.abs(a - e[0]) * t + i, g = Math.abs(h - e[1]) * t + n, b = (e[2] - e[0]) * t, E = (e[3] - e[1]) * t), this.transform = [c * t, d * t, u * t, f * t, p - c * t * a - u * t * h, g - d * t * a - f * t * h], this.width = b, this.height = E;
  }
  get rawDims() {
    const {
      viewBox: e
    } = this;
    return ht(this, "rawDims", {
      pageWidth: e[2] - e[0],
      pageHeight: e[3] - e[1],
      pageX: e[0],
      pageY: e[1]
    });
  }
  clone({
    scale: e = this.scale,
    rotation: t = this.rotation,
    offsetX: s = this.offsetX,
    offsetY: i = this.offsetY,
    dontFlip: n = !1
  } = {}) {
    return new _c({
      viewBox: this.viewBox.slice(),
      scale: e,
      rotation: t,
      offsetX: s,
      offsetY: i,
      dontFlip: n
    });
  }
  convertToViewportPoint(e, t) {
    return X.applyTransform([e, t], this.transform);
  }
  convertToViewportRectangle(e) {
    const t = X.applyTransform([e[0], e[1]], this.transform), s = X.applyTransform([e[2], e[3]], this.transform);
    return [t[0], t[1], s[0], s[1]];
  }
  convertToPdfPoint(e, t) {
    return X.applyInverseTransform([e, t], this.transform);
  }
}
let Vp = class extends zn {
  constructor(e, t = 0) {
    super(e, "RenderingCancelledException"), this.extraDelay = t;
  }
};
function vu(l) {
  const e = l.length;
  let t = 0;
  for (; t < e && l[t].trim() === ""; )
    t++;
  return l.substring(t, t + 5).toLowerCase() === "data:";
}
function Up(l) {
  return typeof l == "string" && /\.pdf$/i.test(l);
}
function ky(l) {
  return [l] = l.split(/[#?]/, 1), l.substring(l.lastIndexOf("/") + 1);
}
function Fy(l, e = "document.pdf") {
  if (typeof l != "string")
    return e;
  if (vu(l))
    return nt('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.'), e;
  const t = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/, s = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i, i = t.exec(l);
  let n = s.exec(i[1]) || s.exec(i[2]) || s.exec(i[3]);
  if (n && (n = n[0], n.includes("%")))
    try {
      n = s.exec(decodeURIComponent(n))[0];
    } catch {
    }
  return n || e;
}
class lg {
  constructor() {
    Z(this, "started", /* @__PURE__ */ Object.create(null));
    Z(this, "times", []);
  }
  time(e) {
    e in this.started && nt(`Timer is already running for ${e}`), this.started[e] = Date.now();
  }
  timeEnd(e) {
    e in this.started || nt(`Timer has not been started for ${e}`), this.times.push({
      name: e,
      start: this.started[e],
      end: Date.now()
    }), delete this.started[e];
  }
  toString() {
    const e = [];
    let t = 0;
    for (const {
      name: s
    } of this.times)
      t = Math.max(s.length, t);
    for (const {
      name: s,
      start: i,
      end: n
    } of this.times)
      e.push(`${s.padEnd(t)} ${n - i}ms
`);
    return e.join("");
  }
}
function ul(l, e) {
  try {
    const {
      protocol: t
    } = e ? new URL(l, e) : new URL(l);
    return t === "http:" || t === "https:";
  } catch {
    return !1;
  }
}
function os(l) {
  l.preventDefault();
}
function hg(l) {
  console.log("Deprecated API usage: " + l);
}
let cg, Sm = class {
  static toDateObject(e) {
    if (!e || typeof e != "string")
      return null;
    cg || (cg = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"));
    const t = cg.exec(e);
    if (!t)
      return null;
    const s = parseInt(t[1], 10);
    let i = parseInt(t[2], 10);
    i = i >= 1 && i <= 12 ? i - 1 : 0;
    let n = parseInt(t[3], 10);
    n = n >= 1 && n <= 31 ? n : 1;
    let r = parseInt(t[4], 10);
    r = r >= 0 && r <= 23 ? r : 0;
    let a = parseInt(t[5], 10);
    a = a >= 0 && a <= 59 ? a : 0;
    let h = parseInt(t[6], 10);
    h = h >= 0 && h <= 59 ? h : 0;
    const c = t[7] || "Z";
    let d = parseInt(t[8], 10);
    d = d >= 0 && d <= 23 ? d : 0;
    let u = parseInt(t[9], 10) || 0;
    return u = u >= 0 && u <= 59 ? u : 0, c === "-" ? (r += d, a += u) : c === "+" && (r -= d, a -= u), new Date(Date.UTC(s, i, n, r, a, h));
  }
};
function jy(l, {
  scale: e = 1,
  rotation: t = 0
}) {
  const {
    width: s,
    height: i
  } = l.attributes.style, n = [0, 0, parseInt(s), parseInt(i)];
  return new _c({
    viewBox: n,
    scale: e,
    rotation: t
  });
}
function zp(l) {
  if (l.startsWith("#")) {
    const e = parseInt(l.slice(1), 16);
    return [(e & 16711680) >> 16, (e & 65280) >> 8, e & 255];
  }
  return l.startsWith("rgb(") ? l.slice(4, -1).split(",").map((e) => parseInt(e)) : l.startsWith("rgba(") ? l.slice(5, -1).split(",").map((e) => parseInt(e)).slice(0, 3) : (nt(`Not a valid color format: "${l}"`), [0, 0, 0]);
}
function By(l) {
  const e = document.createElement("span");
  e.style.visibility = "hidden", document.body.append(e);
  for (const t of l.keys()) {
    e.style.color = t;
    const s = window.getComputedStyle(e).color;
    l.set(t, zp(s));
  }
  e.remove();
}
function It(l) {
  const {
    a: e,
    b: t,
    c: s,
    d: i,
    e: n,
    f: r
  } = l.getTransform();
  return [e, t, s, i, n, r];
}
function ii(l) {
  const {
    a: e,
    b: t,
    c: s,
    d: i,
    e: n,
    f: r
  } = l.getTransform().invertSelf();
  return [e, t, s, i, n, r];
}
function pa(l, e, t = !1, s = !0) {
  if (e instanceof _c) {
    const {
      pageWidth: i,
      pageHeight: n
    } = e.rawDims, {
      style: r
    } = l, a = ke.isCSSRoundSupported, h = `var(--scale-factor) * ${i}px`, c = `var(--scale-factor) * ${n}px`, d = a ? `round(down, ${h}, var(--scale-round-x, 1px))` : `calc(${h})`, u = a ? `round(down, ${c}, var(--scale-round-y, 1px))` : `calc(${c})`;
    !t || e.rotation % 180 === 0 ? (r.width = d, r.height = u) : (r.width = u, r.height = d);
  }
  s && l.setAttribute("data-main-rotation", e.rotation);
}
let Xu = class {
  constructor() {
    const e = window.devicePixelRatio || 1;
    this.sx = e, this.sy = e;
  }
  get scaled() {
    return this.sx !== 1 || this.sy !== 1;
  }
  get symmetric() {
    return this.sx === this.sy;
  }
};
var Ji, ir, cs, nr, Vl, Ul, Gd, Tm, Se, Pm, Cm, Zc, Rm, Yu;
const ai = class ai {
  constructor(e) {
    y(this, Se);
    y(this, Ji, null);
    y(this, ir, null);
    y(this, cs);
    y(this, nr, null);
    y(this, Vl, null);
    v(this, cs, e), o(ai, Ul) || v(ai, Ul, Object.freeze({
      freetext: "pdfjs-editor-remove-freetext-button",
      highlight: "pdfjs-editor-remove-highlight-button",
      ink: "pdfjs-editor-remove-ink-button",
      stamp: "pdfjs-editor-remove-stamp-button"
    }));
  }
  render() {
    const e = v(this, Ji, document.createElement("div"));
    e.classList.add("editToolbar", "hidden"), e.setAttribute("role", "toolbar");
    const t = o(this, cs)._uiManager._signal;
    e.addEventListener("contextmenu", os, {
      signal: t
    }), e.addEventListener("pointerdown", m(ai, Gd, Tm), {
      signal: t
    });
    const s = v(this, nr, document.createElement("div"));
    s.className = "buttons", e.append(s);
    const i = o(this, cs).toolbarPosition;
    if (i) {
      const {
        style: n
      } = e, r = o(this, cs)._uiManager.direction === "ltr" ? 1 - i[0] : i[0];
      n.insetInlineEnd = `${100 * r}%`, n.top = `calc(${100 * i[1]}% + var(--editor-toolbar-vert-offset))`;
    }
    return m(this, Se, Rm).call(this), e;
  }
  get div() {
    return o(this, Ji);
  }
  hide() {
    var e;
    o(this, Ji).classList.add("hidden"), (e = o(this, ir)) == null || e.hideDropdown();
  }
  show() {
    var e;
    o(this, Ji).classList.remove("hidden"), (e = o(this, Vl)) == null || e.shown();
  }
  async addAltText(e) {
    const t = await e.render();
    m(this, Se, Zc).call(this, t), o(this, nr).prepend(t, o(this, Se, Yu)), v(this, Vl, e);
  }
  addColorPicker(e) {
    v(this, ir, e);
    const t = e.renderButton();
    m(this, Se, Zc).call(this, t), o(this, nr).prepend(t, o(this, Se, Yu));
  }
  remove() {
    var e;
    o(this, Ji).remove(), (e = o(this, ir)) == null || e.destroy(), v(this, ir, null);
  }
};
Ji = new WeakMap(), ir = new WeakMap(), cs = new WeakMap(), nr = new WeakMap(), Vl = new WeakMap(), Ul = new WeakMap(), Gd = new WeakSet(), Tm = function(e) {
  e.stopPropagation();
}, Se = new WeakSet(), Pm = function(e) {
  o(this, cs)._focusEventsAllowed = !1, e.preventDefault(), e.stopPropagation();
}, Cm = function(e) {
  o(this, cs)._focusEventsAllowed = !0, e.preventDefault(), e.stopPropagation();
}, Zc = function(e) {
  const t = o(this, cs)._uiManager._signal;
  e.addEventListener("focusin", m(this, Se, Pm).bind(this), {
    capture: !0,
    signal: t
  }), e.addEventListener("focusout", m(this, Se, Cm).bind(this), {
    capture: !0,
    signal: t
  }), e.addEventListener("contextmenu", os, {
    signal: t
  });
}, Rm = function() {
  const {
    editorType: e,
    _uiManager: t
  } = o(this, cs), s = document.createElement("button");
  s.className = "delete", s.tabIndex = 0, s.setAttribute("data-l10n-id", o(ai, Ul)[e]), m(this, Se, Zc).call(this, s), s.addEventListener("click", (i) => {
    t.delete();
  }, {
    signal: t._signal
  }), o(this, nr).append(s);
}, Yu = function() {
  const e = document.createElement("div");
  return e.className = "divider", e;
}, y(ai, Gd), y(ai, Ul, null);
let Ku = ai;
var zl, rr, ar, Vn, Im, Lm, Mm;
class Hy {
  constructor(e) {
    y(this, Vn);
    y(this, zl, null);
    y(this, rr, null);
    y(this, ar);
    v(this, ar, e);
  }
  show(e, t, s) {
    const [i, n] = m(this, Vn, Lm).call(this, t, s), {
      style: r
    } = o(this, rr) || v(this, rr, m(this, Vn, Im).call(this));
    e.append(o(this, rr)), r.insetInlineEnd = `${100 * i}%`, r.top = `calc(${100 * n}% + var(--editor-toolbar-vert-offset))`;
  }
  hide() {
    o(this, rr).remove();
  }
}
zl = new WeakMap(), rr = new WeakMap(), ar = new WeakMap(), Vn = new WeakSet(), Im = function() {
  const e = v(this, rr, document.createElement("div"));
  e.className = "editToolbar", e.setAttribute("role", "toolbar"), e.addEventListener("contextmenu", os, {
    signal: o(this, ar)._signal
  });
  const t = v(this, zl, document.createElement("div"));
  return t.className = "buttons", e.append(t), m(this, Vn, Mm).call(this), e;
}, Lm = function(e, t) {
  let s = 0, i = 0;
  for (const n of e) {
    const r = n.y + n.height;
    if (r < s)
      continue;
    const a = n.x + (t ? n.width : 0);
    if (r > s) {
      i = a, s = r;
      continue;
    }
    t ? a > i && (i = a) : a < i && (i = a);
  }
  return [t ? 1 - i : i, s];
}, Mm = function() {
  const e = document.createElement("button");
  e.className = "highlightButton", e.tabIndex = 0, e.setAttribute("data-l10n-id", "pdfjs-highlight-floating-button1");
  const t = document.createElement("span");
  e.append(t), t.className = "visuallyHidden", t.setAttribute("data-l10n-id", "pdfjs-highlight-floating-button-label");
  const s = o(this, ar)._signal;
  e.addEventListener("contextmenu", os, {
    signal: s
  }), e.addEventListener("click", () => {
    o(this, ar).highlightSelection("floating_button");
  }, {
    signal: s
  }), o(this, zl).append(e);
};
function jd(l, e, t) {
  for (const s of t)
    e.addEventListener(s, l[s].bind(l));
}
function $y(l) {
  return Math.round(Math.min(255, Math.max(1, 255 * l))).toString(16).padStart(2, "0");
}
var Xd;
class Vy {
  constructor() {
    y(this, Xd, 0);
  }
  get id() {
    return `${yy}${de(this, Xd)._++}`;
  }
}
Xd = new WeakMap();
var Na, Wl, ge, Da, Jc;
const qp = class qp {
  constructor() {
    y(this, Da);
    y(this, Na, _y());
    y(this, Wl, 0);
    y(this, ge, null);
  }
  static get _isSVGFittingCanvas() {
    const e = 'data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>', s = new OffscreenCanvas(1, 3).getContext("2d", {
      willReadFrequently: !0
    }), i = new Image();
    i.src = e;
    const n = i.decode().then(() => (s.drawImage(i, 0, 0, 1, 1, 0, 0, 1, 3), new Uint32Array(s.getImageData(0, 0, 1, 1).data.buffer)[0] === 0));
    return ht(this, "_isSVGFittingCanvas", n);
  }
  async getFromFile(e) {
    const {
      lastModified: t,
      name: s,
      size: i,
      type: n
    } = e;
    return m(this, Da, Jc).call(this, `${t}_${s}_${i}_${n}`, e);
  }
  async getFromUrl(e) {
    return m(this, Da, Jc).call(this, e, e);
  }
  async getFromBlob(e, t) {
    const s = await t;
    return m(this, Da, Jc).call(this, e, s);
  }
  async getFromId(e) {
    o(this, ge) || v(this, ge, /* @__PURE__ */ new Map());
    const t = o(this, ge).get(e);
    if (!t)
      return null;
    if (t.bitmap)
      return t.refCounter += 1, t;
    if (t.file)
      return this.getFromFile(t.file);
    if (t.blobPromise) {
      const {
        blobPromise: s
      } = t;
      return delete t.blobPromise, this.getFromBlob(t.id, s);
    }
    return this.getFromUrl(t.url);
  }
  getFromCanvas(e, t) {
    o(this, ge) || v(this, ge, /* @__PURE__ */ new Map());
    let s = o(this, ge).get(e);
    if (s != null && s.bitmap)
      return s.refCounter += 1, s;
    const i = new OffscreenCanvas(t.width, t.height);
    return i.getContext("2d").drawImage(t, 0, 0), s = {
      bitmap: i.transferToImageBitmap(),
      id: `image_${o(this, Na)}_${de(this, Wl)._++}`,
      refCounter: 1,
      isSvg: !1
    }, o(this, ge).set(e, s), o(this, ge).set(s.id, s), s;
  }
  getSvgUrl(e) {
    const t = o(this, ge).get(e);
    return t != null && t.isSvg ? t.svgUrl : null;
  }
  deleteId(e) {
    var i;
    o(this, ge) || v(this, ge, /* @__PURE__ */ new Map());
    const t = o(this, ge).get(e);
    if (!t || (t.refCounter -= 1, t.refCounter !== 0))
      return;
    const {
      bitmap: s
    } = t;
    if (!t.url && !t.file) {
      const n = new OffscreenCanvas(s.width, s.height);
      n.getContext("bitmaprenderer").transferFromImageBitmap(s), t.blobPromise = n.convertToBlob();
    }
    (i = s.close) == null || i.call(s), t.bitmap = null;
  }
  isValidId(e) {
    return e.startsWith(`image_${o(this, Na)}_`);
  }
};
Na = new WeakMap(), Wl = new WeakMap(), ge = new WeakMap(), Da = new WeakSet(), Jc = async function(e, t) {
  o(this, ge) || v(this, ge, /* @__PURE__ */ new Map());
  let s = o(this, ge).get(e);
  if (s === null)
    return null;
  if (s != null && s.bitmap)
    return s.refCounter += 1, s;
  try {
    s || (s = {
      bitmap: null,
      id: `image_${o(this, Na)}_${de(this, Wl)._++}`,
      refCounter: 0,
      isSvg: !1
    });
    let i;
    if (typeof t == "string" ? (s.url = t, i = await mu(t, "blob")) : t instanceof File ? i = s.file = t : t instanceof Blob && (i = t), i.type === "image/svg+xml") {
      const n = qp._isSVGFittingCanvas, r = new FileReader(), a = new Image(), h = new Promise((c, d) => {
        a.onload = () => {
          s.bitmap = a, s.isSvg = !0, c();
        }, r.onload = async () => {
          const u = s.svgUrl = r.result;
          a.src = await n ? `${u}#svgView(preserveAspectRatio(none))` : u;
        }, a.onerror = r.onerror = d;
      });
      r.readAsDataURL(i), await h;
    } else
      s.bitmap = await createImageBitmap(i);
    s.refCounter = 1;
  } catch (i) {
    console.error(i), s = null;
  }
  return o(this, ge).set(e, s), s && o(this, ge).set(s.id, s), s;
};
let Qu = qp;
var qt, qi, Gl, te;
class Uy {
  constructor(e = 128) {
    y(this, qt, []);
    y(this, qi, !1);
    y(this, Gl);
    y(this, te, -1);
    v(this, Gl, e);
  }
  add({
    cmd: e,
    undo: t,
    post: s,
    mustExec: i,
    type: n = NaN,
    overwriteIfSameType: r = !1,
    keepUndo: a = !1
  }) {
    if (i && e(), o(this, qi))
      return;
    const h = {
      cmd: e,
      undo: t,
      post: s,
      type: n
    };
    if (o(this, te) === -1) {
      o(this, qt).length > 0 && (o(this, qt).length = 0), v(this, te, 0), o(this, qt).push(h);
      return;
    }
    if (r && o(this, qt)[o(this, te)].type === n) {
      a && (h.undo = o(this, qt)[o(this, te)].undo), o(this, qt)[o(this, te)] = h;
      return;
    }
    const c = o(this, te) + 1;
    c === o(this, Gl) ? o(this, qt).splice(0, 1) : (v(this, te, c), c < o(this, qt).length && o(this, qt).splice(c)), o(this, qt).push(h);
  }
  undo() {
    if (o(this, te) === -1)
      return;
    v(this, qi, !0);
    const {
      undo: e,
      post: t
    } = o(this, qt)[o(this, te)];
    e(), t == null || t(), v(this, qi, !1), v(this, te, o(this, te) - 1);
  }
  redo() {
    if (o(this, te) < o(this, qt).length - 1) {
      v(this, te, o(this, te) + 1), v(this, qi, !0);
      const {
        cmd: e,
        post: t
      } = o(this, qt)[o(this, te)];
      e(), t == null || t(), v(this, qi, !1);
    }
  }
  hasSomethingToUndo() {
    return o(this, te) !== -1;
  }
  hasSomethingToRedo() {
    return o(this, te) < o(this, qt).length - 1;
  }
  destroy() {
    v(this, qt, null);
  }
}
qt = new WeakMap(), qi = new WeakMap(), Gl = new WeakMap(), te = new WeakMap();
var Kd, _m;
class Oc {
  constructor(e) {
    y(this, Kd);
    this.buffer = [], this.callbacks = /* @__PURE__ */ new Map(), this.allKeys = /* @__PURE__ */ new Set();
    const {
      isMac: t
    } = ke.platform;
    for (const [s, i, n = {}] of e)
      for (const r of s) {
        const a = r.startsWith("mac+");
        t && a ? (this.callbacks.set(r.slice(4), {
          callback: i,
          options: n
        }), this.allKeys.add(r.split("+").at(-1))) : !t && !a && (this.callbacks.set(r, {
          callback: i,
          options: n
        }), this.allKeys.add(r.split("+").at(-1)));
      }
  }
  exec(e, t) {
    if (!this.allKeys.has(t.key))
      return;
    const s = this.callbacks.get(m(this, Kd, _m).call(this, t));
    if (!s)
      return;
    const {
      callback: i,
      options: {
        bubbles: n = !1,
        args: r = [],
        checker: a = null
      }
    } = s;
    a && !a(e, t) || (i.bind(e, ...r, t)(), n || (t.stopPropagation(), t.preventDefault()));
  }
}
Kd = new WeakSet(), _m = function(e) {
  e.altKey && this.buffer.push("alt"), e.ctrlKey && this.buffer.push("ctrl"), e.metaKey && this.buffer.push("meta"), e.shiftKey && this.buffer.push("shift"), this.buffer.push(e.key);
  const t = this.buffer.join("+");
  return this.buffer.length = 0, t;
};
const Yd = class Yd {
  get _colors() {
    const e = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
    return By(e), ht(this, "_colors", e);
  }
  convert(e) {
    const t = zp(e);
    if (!window.matchMedia("(forced-colors: active)").matches)
      return t;
    for (const [s, i] of this._colors)
      if (i.every((n, r) => n === t[r]))
        return Yd._colorsMapping.get(s);
    return t;
  }
  getHexCode(e) {
    const t = this._colors.get(e);
    return t ? X.makeHexColor(...t) : e;
  }
};
Z(Yd, "_colorsMapping", /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]));
let Zu = Yd;
var ka, Be, Gt, ae, Fa, ci, ja, ds, tn, Ba, or, Rs, us, lr, Xl, Kl, Ha, Yl, Is, en, $a, sn, Ls, Qd, nn, Ql, rn, hr, Zl, Jl, ee, vt, di, cr, ql, th, an, Ms, ui, eh, Je, ji, $, qc, Ju, Om, Nm, td, Dm, km, Fm, qu, jm, tf, ef, Bm, Ee, Wi, Hm, $m, sf, Vm, fl, nf;
let kl = (ji = class {
  constructor(e, t, s, i, n, r, a, h, c, d, u) {
    y(this, $);
    y(this, ka, new AbortController());
    y(this, Be, null);
    y(this, Gt, /* @__PURE__ */ new Map());
    y(this, ae, /* @__PURE__ */ new Map());
    y(this, Fa, null);
    y(this, ci, null);
    y(this, ja, null);
    y(this, ds, new Uy());
    y(this, tn, null);
    y(this, Ba, 0);
    y(this, or, /* @__PURE__ */ new Set());
    y(this, Rs, null);
    y(this, us, null);
    y(this, lr, /* @__PURE__ */ new Set());
    y(this, Xl, !1);
    y(this, Kl, !1);
    y(this, Ha, !1);
    y(this, Yl, null);
    y(this, Is, null);
    y(this, en, null);
    y(this, $a, null);
    y(this, sn, !1);
    y(this, Ls, null);
    y(this, Qd, new Vy());
    y(this, nn, !1);
    y(this, Ql, !1);
    y(this, rn, null);
    y(this, hr, null);
    y(this, Zl, null);
    y(this, Jl, null);
    y(this, ee, it.NONE);
    y(this, vt, /* @__PURE__ */ new Set());
    y(this, di, null);
    y(this, cr, null);
    y(this, ql, null);
    y(this, th, {
      isEditing: !1,
      isEmpty: !0,
      hasSomethingToUndo: !1,
      hasSomethingToRedo: !1,
      hasSelectedEditor: !1,
      hasSelectedText: !1
    });
    y(this, an, [0, 0]);
    y(this, Ms, null);
    y(this, ui, null);
    y(this, eh, null);
    y(this, Je, null);
    const f = this._signal = o(this, ka).signal;
    v(this, ui, e), v(this, eh, t), v(this, Fa, s), this._eventBus = i, i._on("editingaction", this.onEditingAction.bind(this), {
      signal: f
    }), i._on("pagechanging", this.onPageChanging.bind(this), {
      signal: f
    }), i._on("scalechanging", this.onScaleChanging.bind(this), {
      signal: f
    }), i._on("rotationchanging", this.onRotationChanging.bind(this), {
      signal: f
    }), i._on("setpreference", this.onSetPreference.bind(this), {
      signal: f
    }), i._on("switchannotationeditorparams", (p) => this.updateParams(p.type, p.value), {
      signal: f
    }), m(this, $, Dm).call(this), m(this, $, Bm).call(this), m(this, $, qu).call(this), v(this, ci, n.annotationStorage), v(this, Yl, n.filterFactory), v(this, cr, r), v(this, $a, a || null), v(this, Xl, h), v(this, Kl, c), v(this, Ha, d), v(this, Jl, u || null), this.viewParameters = {
      realScale: Qo.PDF_TO_CSS_UNITS,
      rotation: 0
    }, this.isShiftKeyDown = !1;
  }
  static get _keyboardManager() {
    const e = ji.prototype, t = (r) => o(r, ui).contains(document.activeElement) && document.activeElement.tagName !== "BUTTON" && r.hasSomethingToControl(), s = (r, {
      target: a
    }) => {
      if (a instanceof HTMLInputElement) {
        const {
          type: h
        } = a;
        return h !== "text" && h !== "number";
      }
      return !0;
    }, i = this.TRANSLATE_SMALL, n = this.TRANSLATE_BIG;
    return ht(this, "_keyboardManager", new Oc([[["ctrl+a", "mac+meta+a"], e.selectAll, {
      checker: s
    }], [["ctrl+z", "mac+meta+z"], e.undo, {
      checker: s
    }], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], e.redo, {
      checker: s
    }], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], e.delete, {
      checker: s
    }], [["Enter", "mac+Enter"], e.addNewEditorFromKeyboard, {
      checker: (r, {
        target: a
      }) => !(a instanceof HTMLButtonElement) && o(r, ui).contains(a) && !r.isEnterHandled
    }], [[" ", "mac+ "], e.addNewEditorFromKeyboard, {
      checker: (r, {
        target: a
      }) => !(a instanceof HTMLButtonElement) && o(r, ui).contains(document.activeElement)
    }], [["Escape", "mac+Escape"], e.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], e.translateSelectedEditors, {
      args: [-i, 0],
      checker: t
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], e.translateSelectedEditors, {
      args: [-n, 0],
      checker: t
    }], [["ArrowRight", "mac+ArrowRight"], e.translateSelectedEditors, {
      args: [i, 0],
      checker: t
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], e.translateSelectedEditors, {
      args: [n, 0],
      checker: t
    }], [["ArrowUp", "mac+ArrowUp"], e.translateSelectedEditors, {
      args: [0, -i],
      checker: t
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], e.translateSelectedEditors, {
      args: [0, -n],
      checker: t
    }], [["ArrowDown", "mac+ArrowDown"], e.translateSelectedEditors, {
      args: [0, i],
      checker: t
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], e.translateSelectedEditors, {
      args: [0, n],
      checker: t
    }]]));
  }
  destroy() {
    var e, t, s, i;
    (e = o(this, Je)) == null || e.resolve(), v(this, Je, null), (t = o(this, ka)) == null || t.abort(), v(this, ka, null), this._signal = null;
    for (const n of o(this, ae).values())
      n.destroy();
    o(this, ae).clear(), o(this, Gt).clear(), o(this, lr).clear(), v(this, Be, null), o(this, vt).clear(), o(this, ds).destroy(), (s = o(this, Fa)) == null || s.destroy(), (i = o(this, Ls)) == null || i.hide(), v(this, Ls, null), o(this, Is) && (clearTimeout(o(this, Is)), v(this, Is, null)), o(this, Ms) && (clearTimeout(o(this, Ms)), v(this, Ms, null));
  }
  combinedSignal(e) {
    return AbortSignal.any([this._signal, e.signal]);
  }
  get mlManager() {
    return o(this, Jl);
  }
  get useNewAltTextFlow() {
    return o(this, Kl);
  }
  get useNewAltTextWhenAddingImage() {
    return o(this, Ha);
  }
  get hcmFilter() {
    return ht(this, "hcmFilter", o(this, cr) ? o(this, Yl).addHCMFilter(o(this, cr).foreground, o(this, cr).background) : "none");
  }
  get direction() {
    return ht(this, "direction", getComputedStyle(o(this, ui)).direction);
  }
  get highlightColors() {
    return ht(this, "highlightColors", o(this, $a) ? new Map(o(this, $a).split(",").map((e) => e.split("=").map((t) => t.trim()))) : null);
  }
  get highlightColorNames() {
    return ht(this, "highlightColorNames", this.highlightColors ? new Map(Array.from(this.highlightColors, (e) => e.reverse())) : null);
  }
  setMainHighlightColorPicker(e) {
    v(this, Zl, e);
  }
  editAltText(e, t = !1) {
    var s;
    (s = o(this, Fa)) == null || s.editAltText(this, e, t);
  }
  switchToMode(e, t) {
    this._eventBus.on("annotationeditormodechanged", t, {
      once: !0,
      signal: this._signal
    }), this._eventBus.dispatch("showannotationeditorui", {
      source: this,
      mode: e
    });
  }
  setPreference(e, t) {
    this._eventBus.dispatch("setpreference", {
      source: this,
      name: e,
      value: t
    });
  }
  onSetPreference({
    name: e,
    value: t
  }) {
    switch (e) {
      case "enableNewAltTextWhenAddingImage":
        v(this, Ha, t);
        break;
    }
  }
  onPageChanging({
    pageNumber: e
  }) {
    v(this, Ba, e - 1);
  }
  focusMainContainer() {
    o(this, ui).focus();
  }
  findParent(e, t) {
    for (const s of o(this, ae).values()) {
      const {
        x: i,
        y: n,
        width: r,
        height: a
      } = s.div.getBoundingClientRect();
      if (e >= i && e <= i + r && t >= n && t <= n + a)
        return s;
    }
    return null;
  }
  disableUserSelect(e = !1) {
    o(this, eh).classList.toggle("noUserSelect", e);
  }
  addShouldRescale(e) {
    o(this, lr).add(e);
  }
  removeShouldRescale(e) {
    o(this, lr).delete(e);
  }
  onScaleChanging({
    scale: e
  }) {
    this.commitOrRemove(), this.viewParameters.realScale = e * Qo.PDF_TO_CSS_UNITS;
    for (const t of o(this, lr))
      t.onScaleChanging();
  }
  onRotationChanging({
    pagesRotation: e
  }) {
    this.commitOrRemove(), this.viewParameters.rotation = e;
  }
  highlightSelection(e = "") {
    const t = document.getSelection();
    if (!t || t.isCollapsed)
      return;
    const {
      anchorNode: s,
      anchorOffset: i,
      focusNode: n,
      focusOffset: r
    } = t, a = t.toString(), c = m(this, $, qc).call(this, t).closest(".textLayer"), d = this.getSelectionBoxes(c);
    if (!d)
      return;
    t.empty();
    const u = m(this, $, Ju).call(this, c), f = o(this, ee) === it.NONE, p = () => {
      u == null || u.createAndAddNewEditor({
        x: 0,
        y: 0
      }, !1, {
        methodOfCreation: e,
        boxes: d,
        anchorNode: s,
        anchorOffset: i,
        focusNode: n,
        focusOffset: r,
        text: a
      }), f && this.showAllEditors("highlight", !0, !0);
    };
    if (f) {
      this.switchToMode(it.HIGHLIGHT, p);
      return;
    }
    p();
  }
  addToAnnotationStorage(e) {
    !e.isEmpty() && o(this, ci) && !o(this, ci).has(e.id) && o(this, ci).setValue(e.id, e);
  }
  blur() {
    if (this.isShiftKeyDown = !1, o(this, sn) && (v(this, sn, !1), m(this, $, td).call(this, "main_toolbar")), !this.hasSelection)
      return;
    const {
      activeElement: e
    } = document;
    for (const t of o(this, vt))
      if (t.div.contains(e)) {
        v(this, hr, [t, e]), t._focusEventsAllowed = !1;
        break;
      }
  }
  focus() {
    if (!o(this, hr))
      return;
    const [e, t] = o(this, hr);
    v(this, hr, null), t.addEventListener("focusin", () => {
      e._focusEventsAllowed = !0;
    }, {
      once: !0,
      signal: this._signal
    }), t.focus();
  }
  addEditListeners() {
    m(this, $, qu).call(this), m(this, $, tf).call(this);
  }
  removeEditListeners() {
    m(this, $, jm).call(this), m(this, $, ef).call(this);
  }
  dragOver(e) {
    for (const {
      type: t
    } of e.dataTransfer.items)
      for (const s of o(this, us))
        if (s.isHandlingMimeForPasting(t)) {
          e.dataTransfer.dropEffect = "copy", e.preventDefault();
          return;
        }
  }
  drop(e) {
    for (const t of e.dataTransfer.items)
      for (const s of o(this, us))
        if (s.isHandlingMimeForPasting(t.type)) {
          s.paste(t, this.currentLayer), e.preventDefault();
          return;
        }
  }
  copy(e) {
    var s;
    if (e.preventDefault(), (s = o(this, Be)) == null || s.commitOrRemove(), !this.hasSelection)
      return;
    const t = [];
    for (const i of o(this, vt)) {
      const n = i.serialize(!0);
      n && t.push(n);
    }
    t.length !== 0 && e.clipboardData.setData("application/pdfjs", JSON.stringify(t));
  }
  cut(e) {
    this.copy(e), this.delete();
  }
  async paste(e) {
    e.preventDefault();
    const {
      clipboardData: t
    } = e;
    for (const n of t.items)
      for (const r of o(this, us))
        if (r.isHandlingMimeForPasting(n.type)) {
          r.paste(n, this.currentLayer);
          return;
        }
    let s = t.getData("application/pdfjs");
    if (!s)
      return;
    try {
      s = JSON.parse(s);
    } catch (n) {
      nt(`paste: "${n.message}".`);
      return;
    }
    if (!Array.isArray(s))
      return;
    this.unselectAll();
    const i = this.currentLayer;
    try {
      const n = [];
      for (const h of s) {
        const c = await i.deserialize(h);
        if (!c)
          return;
        n.push(c);
      }
      const r = () => {
        for (const h of n)
          m(this, $, sf).call(this, h);
        m(this, $, nf).call(this, n);
      }, a = () => {
        for (const h of n)
          h.remove();
      };
      this.addCommands({
        cmd: r,
        undo: a,
        mustExec: !0
      });
    } catch (n) {
      nt(`paste: "${n.message}".`);
    }
  }
  keydown(e) {
    !this.isShiftKeyDown && e.key === "Shift" && (this.isShiftKeyDown = !0), o(this, ee) !== it.NONE && !this.isEditorHandlingKeyboard && ji._keyboardManager.exec(this, e);
  }
  keyup(e) {
    this.isShiftKeyDown && e.key === "Shift" && (this.isShiftKeyDown = !1, o(this, sn) && (v(this, sn, !1), m(this, $, td).call(this, "main_toolbar")));
  }
  onEditingAction({
    name: e
  }) {
    switch (e) {
      case "undo":
      case "redo":
      case "delete":
      case "selectAll":
        this[e]();
        break;
      case "highlightSelection":
        this.highlightSelection("context_menu");
        break;
    }
  }
  setEditingState(e) {
    e ? (m(this, $, km).call(this), m(this, $, tf).call(this), m(this, $, Ee).call(this, {
      isEditing: o(this, ee) !== it.NONE,
      isEmpty: m(this, $, fl).call(this),
      hasSomethingToUndo: o(this, ds).hasSomethingToUndo(),
      hasSomethingToRedo: o(this, ds).hasSomethingToRedo(),
      hasSelectedEditor: !1
    })) : (m(this, $, Fm).call(this), m(this, $, ef).call(this), m(this, $, Ee).call(this, {
      isEditing: !1
    }), this.disableUserSelect(!1));
  }
  registerEditorTypes(e) {
    if (!o(this, us)) {
      v(this, us, e);
      for (const t of o(this, us))
        m(this, $, Wi).call(this, t.defaultPropertiesToUpdate);
    }
  }
  getId() {
    return o(this, Qd).id;
  }
  get currentLayer() {
    return o(this, ae).get(o(this, Ba));
  }
  getLayer(e) {
    return o(this, ae).get(e);
  }
  get currentPageIndex() {
    return o(this, Ba);
  }
  addLayer(e) {
    o(this, ae).set(e.pageIndex, e), o(this, nn) ? e.enable() : e.disable();
  }
  removeLayer(e) {
    o(this, ae).delete(e.pageIndex);
  }
  async updateMode(e, t = null, s = !1) {
    if (o(this, ee) !== e && !(o(this, Je) && (await o(this, Je).promise, !o(this, Je)))) {
      if (v(this, Je, Promise.withResolvers()), v(this, ee, e), e === it.NONE) {
        this.setEditingState(!1), m(this, $, $m).call(this), o(this, Je).resolve();
        return;
      }
      this.setEditingState(!0), await m(this, $, Hm).call(this), this.unselectAll();
      for (const i of o(this, ae).values())
        i.updateMode(e);
      if (!t) {
        s && this.addNewEditorFromKeyboard(), o(this, Je).resolve();
        return;
      }
      for (const i of o(this, Gt).values())
        i.annotationElementId === t ? (this.setSelected(i), i.enterInEditMode()) : i.unselect();
      o(this, Je).resolve();
    }
  }
  addNewEditorFromKeyboard() {
    this.currentLayer.canCreateNewEmptyEditor() && this.currentLayer.addNewEditor();
  }
  updateToolbar(e) {
    e !== o(this, ee) && this._eventBus.dispatch("switchannotationeditormode", {
      source: this,
      mode: e
    });
  }
  updateParams(e, t) {
    var s;
    if (o(this, us)) {
      switch (e) {
        case J.CREATE:
          this.currentLayer.addNewEditor();
          return;
        case J.HIGHLIGHT_DEFAULT_COLOR:
          (s = o(this, Zl)) == null || s.updateColor(t);
          break;
        case J.HIGHLIGHT_SHOW_ALL:
          this._eventBus.dispatch("reporttelemetry", {
            source: this,
            details: {
              type: "editing",
              data: {
                type: "highlight",
                action: "toggle_visibility"
              }
            }
          }), (o(this, ql) || v(this, ql, /* @__PURE__ */ new Map())).set(e, t), this.showAllEditors("highlight", t);
          break;
      }
      for (const i of o(this, vt))
        i.updateParams(e, t);
      for (const i of o(this, us))
        i.updateDefaultParams(e, t);
    }
  }
  showAllEditors(e, t, s = !1) {
    var n;
    for (const r of o(this, Gt).values())
      r.editorType === e && r.show(t);
    (((n = o(this, ql)) == null ? void 0 : n.get(J.HIGHLIGHT_SHOW_ALL)) ?? !0) !== t && m(this, $, Wi).call(this, [[J.HIGHLIGHT_SHOW_ALL, t]]);
  }
  enableWaiting(e = !1) {
    if (o(this, Ql) !== e) {
      v(this, Ql, e);
      for (const t of o(this, ae).values())
        e ? t.disableClick() : t.enableClick(), t.div.classList.toggle("waiting", e);
    }
  }
  getEditors(e) {
    const t = [];
    for (const s of o(this, Gt).values())
      s.pageIndex === e && t.push(s);
    return t;
  }
  getEditor(e) {
    return o(this, Gt).get(e);
  }
  addEditor(e) {
    o(this, Gt).set(e.id, e);
  }
  removeEditor(e) {
    var t;
    e.div.contains(document.activeElement) && (o(this, Is) && clearTimeout(o(this, Is)), v(this, Is, setTimeout(() => {
      this.focusMainContainer(), v(this, Is, null);
    }, 0))), o(this, Gt).delete(e.id), this.unselect(e), (!e.annotationElementId || !o(this, or).has(e.annotationElementId)) && ((t = o(this, ci)) == null || t.remove(e.id));
  }
  addDeletedAnnotationElement(e) {
    o(this, or).add(e.annotationElementId), this.addChangedExistingAnnotation(e), e.deleted = !0;
  }
  isDeletedAnnotationElement(e) {
    return o(this, or).has(e);
  }
  removeDeletedAnnotationElement(e) {
    o(this, or).delete(e.annotationElementId), this.removeChangedExistingAnnotation(e), e.deleted = !1;
  }
  setActiveEditor(e) {
    o(this, Be) !== e && (v(this, Be, e), e && m(this, $, Wi).call(this, e.propertiesToUpdate));
  }
  updateUI(e) {
    o(this, $, Vm) === e && m(this, $, Wi).call(this, e.propertiesToUpdate);
  }
  toggleSelected(e) {
    if (o(this, vt).has(e)) {
      o(this, vt).delete(e), e.unselect(), m(this, $, Ee).call(this, {
        hasSelectedEditor: this.hasSelection
      });
      return;
    }
    o(this, vt).add(e), e.select(), m(this, $, Wi).call(this, e.propertiesToUpdate), m(this, $, Ee).call(this, {
      hasSelectedEditor: !0
    });
  }
  setSelected(e) {
    for (const t of o(this, vt))
      t !== e && t.unselect();
    o(this, vt).clear(), o(this, vt).add(e), e.select(), m(this, $, Wi).call(this, e.propertiesToUpdate), m(this, $, Ee).call(this, {
      hasSelectedEditor: !0
    });
  }
  isSelected(e) {
    return o(this, vt).has(e);
  }
  get firstSelectedEditor() {
    return o(this, vt).values().next().value;
  }
  unselect(e) {
    e.unselect(), o(this, vt).delete(e), m(this, $, Ee).call(this, {
      hasSelectedEditor: this.hasSelection
    });
  }
  get hasSelection() {
    return o(this, vt).size !== 0;
  }
  get isEnterHandled() {
    return o(this, vt).size === 1 && this.firstSelectedEditor.isEnterHandled;
  }
  undo() {
    o(this, ds).undo(), m(this, $, Ee).call(this, {
      hasSomethingToUndo: o(this, ds).hasSomethingToUndo(),
      hasSomethingToRedo: !0,
      isEmpty: m(this, $, fl).call(this)
    });
  }
  redo() {
    o(this, ds).redo(), m(this, $, Ee).call(this, {
      hasSomethingToUndo: !0,
      hasSomethingToRedo: o(this, ds).hasSomethingToRedo(),
      isEmpty: m(this, $, fl).call(this)
    });
  }
  addCommands(e) {
    o(this, ds).add(e), m(this, $, Ee).call(this, {
      hasSomethingToUndo: !0,
      hasSomethingToRedo: !1,
      isEmpty: m(this, $, fl).call(this)
    });
  }
  delete() {
    if (this.commitOrRemove(), !this.hasSelection)
      return;
    const e = [...o(this, vt)], t = () => {
      for (const i of e)
        i.remove();
    }, s = () => {
      for (const i of e)
        m(this, $, sf).call(this, i);
    };
    this.addCommands({
      cmd: t,
      undo: s,
      mustExec: !0
    });
  }
  commitOrRemove() {
    var e;
    (e = o(this, Be)) == null || e.commitOrRemove();
  }
  hasSomethingToControl() {
    return o(this, Be) || this.hasSelection;
  }
  selectAll() {
    for (const e of o(this, vt))
      e.commit();
    m(this, $, nf).call(this, o(this, Gt).values());
  }
  unselectAll() {
    if (!(o(this, Be) && (o(this, Be).commitOrRemove(), o(this, ee) !== it.NONE)) && this.hasSelection) {
      for (const e of o(this, vt))
        e.unselect();
      o(this, vt).clear(), m(this, $, Ee).call(this, {
        hasSelectedEditor: !1
      });
    }
  }
  translateSelectedEditors(e, t, s = !1) {
    if (s || this.commitOrRemove(), !this.hasSelection)
      return;
    o(this, an)[0] += e, o(this, an)[1] += t;
    const [i, n] = o(this, an), r = [...o(this, vt)], a = 1e3;
    o(this, Ms) && clearTimeout(o(this, Ms)), v(this, Ms, setTimeout(() => {
      v(this, Ms, null), o(this, an)[0] = o(this, an)[1] = 0, this.addCommands({
        cmd: () => {
          for (const h of r)
            o(this, Gt).has(h.id) && h.translateInPage(i, n);
        },
        undo: () => {
          for (const h of r)
            o(this, Gt).has(h.id) && h.translateInPage(-i, -n);
        },
        mustExec: !1
      });
    }, a));
    for (const h of r)
      h.translateInPage(e, t);
  }
  setUpDragSession() {
    if (this.hasSelection) {
      this.disableUserSelect(!0), v(this, Rs, /* @__PURE__ */ new Map());
      for (const e of o(this, vt))
        o(this, Rs).set(e, {
          savedX: e.x,
          savedY: e.y,
          savedPageIndex: e.pageIndex,
          newX: 0,
          newY: 0,
          newPageIndex: -1
        });
    }
  }
  endDragSession() {
    if (!o(this, Rs))
      return !1;
    this.disableUserSelect(!1);
    const e = o(this, Rs);
    v(this, Rs, null);
    let t = !1;
    for (const [{
      x: i,
      y: n,
      pageIndex: r
    }, a] of e)
      a.newX = i, a.newY = n, a.newPageIndex = r, t || (t = i !== a.savedX || n !== a.savedY || r !== a.savedPageIndex);
    if (!t)
      return !1;
    const s = (i, n, r, a) => {
      if (o(this, Gt).has(i.id)) {
        const h = o(this, ae).get(a);
        h ? i._setParentAndPosition(h, n, r) : (i.pageIndex = a, i.x = n, i.y = r);
      }
    };
    return this.addCommands({
      cmd: () => {
        for (const [i, {
          newX: n,
          newY: r,
          newPageIndex: a
        }] of e)
          s(i, n, r, a);
      },
      undo: () => {
        for (const [i, {
          savedX: n,
          savedY: r,
          savedPageIndex: a
        }] of e)
          s(i, n, r, a);
      },
      mustExec: !0
    }), !0;
  }
  dragSelectedEditors(e, t) {
    if (o(this, Rs))
      for (const s of o(this, Rs).keys())
        s.drag(e, t);
  }
  rebuild(e) {
    if (e.parent === null) {
      const t = this.getLayer(e.pageIndex);
      t ? (t.changeParent(e), t.addOrRebuild(e)) : (this.addEditor(e), this.addToAnnotationStorage(e), e.rebuild());
    } else
      e.parent.addOrRebuild(e);
  }
  get isEditorHandlingKeyboard() {
    var e;
    return ((e = this.getActive()) == null ? void 0 : e.shouldGetKeyboardEvents()) || o(this, vt).size === 1 && this.firstSelectedEditor.shouldGetKeyboardEvents();
  }
  isActive(e) {
    return o(this, Be) === e;
  }
  getActive() {
    return o(this, Be);
  }
  getMode() {
    return o(this, ee);
  }
  get imageManager() {
    return ht(this, "imageManager", new Qu());
  }
  getSelectionBoxes(e) {
    if (!e)
      return null;
    const t = document.getSelection();
    for (let c = 0, d = t.rangeCount; c < d; c++)
      if (!e.contains(t.getRangeAt(c).commonAncestorContainer))
        return null;
    const {
      x: s,
      y: i,
      width: n,
      height: r
    } = e.getBoundingClientRect();
    let a;
    switch (e.getAttribute("data-main-rotation")) {
      case "90":
        a = (c, d, u, f) => ({
          x: (d - i) / r,
          y: 1 - (c + u - s) / n,
          width: f / r,
          height: u / n
        });
        break;
      case "180":
        a = (c, d, u, f) => ({
          x: 1 - (c + u - s) / n,
          y: 1 - (d + f - i) / r,
          width: u / n,
          height: f / r
        });
        break;
      case "270":
        a = (c, d, u, f) => ({
          x: 1 - (d + f - i) / r,
          y: (c - s) / n,
          width: f / r,
          height: u / n
        });
        break;
      default:
        a = (c, d, u, f) => ({
          x: (c - s) / n,
          y: (d - i) / r,
          width: u / n,
          height: f / r
        });
        break;
    }
    const h = [];
    for (let c = 0, d = t.rangeCount; c < d; c++) {
      const u = t.getRangeAt(c);
      if (!u.collapsed)
        for (const {
          x: f,
          y: p,
          width: g,
          height: b
        } of u.getClientRects())
          g === 0 || b === 0 || h.push(a(f, p, g, b));
    }
    return h.length === 0 ? null : h;
  }
  addChangedExistingAnnotation({
    annotationElementId: e,
    id: t
  }) {
    (o(this, ja) || v(this, ja, /* @__PURE__ */ new Map())).set(e, t);
  }
  removeChangedExistingAnnotation({
    annotationElementId: e
  }) {
    var t;
    (t = o(this, ja)) == null || t.delete(e);
  }
  renderAnnotationElement(e) {
    var i;
    const t = (i = o(this, ja)) == null ? void 0 : i.get(e.data.id);
    if (!t)
      return;
    const s = o(this, ci).getRawValue(t);
    s && (o(this, ee) === it.NONE && !s.hasBeenModified || s.renderAnnotationElement(e));
  }
}, ka = new WeakMap(), Be = new WeakMap(), Gt = new WeakMap(), ae = new WeakMap(), Fa = new WeakMap(), ci = new WeakMap(), ja = new WeakMap(), ds = new WeakMap(), tn = new WeakMap(), Ba = new WeakMap(), or = new WeakMap(), Rs = new WeakMap(), us = new WeakMap(), lr = new WeakMap(), Xl = new WeakMap(), Kl = new WeakMap(), Ha = new WeakMap(), Yl = new WeakMap(), Is = new WeakMap(), en = new WeakMap(), $a = new WeakMap(), sn = new WeakMap(), Ls = new WeakMap(), Qd = new WeakMap(), nn = new WeakMap(), Ql = new WeakMap(), rn = new WeakMap(), hr = new WeakMap(), Zl = new WeakMap(), Jl = new WeakMap(), ee = new WeakMap(), vt = new WeakMap(), di = new WeakMap(), cr = new WeakMap(), ql = new WeakMap(), th = new WeakMap(), an = new WeakMap(), Ms = new WeakMap(), ui = new WeakMap(), eh = new WeakMap(), Je = new WeakMap(), $ = new WeakSet(), qc = function({
  anchorNode: e
}) {
  return e.nodeType === Node.TEXT_NODE ? e.parentElement : e;
}, Ju = function(e) {
  const {
    currentLayer: t
  } = this;
  if (t.hasTextLayer(e))
    return t;
  for (const s of o(this, ae).values())
    if (s.hasTextLayer(e))
      return s;
  return null;
}, Om = function() {
  const e = document.getSelection();
  if (!e || e.isCollapsed)
    return;
  const s = m(this, $, qc).call(this, e).closest(".textLayer"), i = this.getSelectionBoxes(s);
  i && (o(this, Ls) || v(this, Ls, new Hy(this)), o(this, Ls).show(s, i, this.direction === "ltr"));
}, Nm = function() {
  var n, r, a;
  const e = document.getSelection();
  if (!e || e.isCollapsed) {
    o(this, di) && ((n = o(this, Ls)) == null || n.hide(), v(this, di, null), m(this, $, Ee).call(this, {
      hasSelectedText: !1
    }));
    return;
  }
  const {
    anchorNode: t
  } = e;
  if (t === o(this, di))
    return;
  const i = m(this, $, qc).call(this, e).closest(".textLayer");
  if (!i) {
    o(this, di) && ((r = o(this, Ls)) == null || r.hide(), v(this, di, null), m(this, $, Ee).call(this, {
      hasSelectedText: !1
    }));
    return;
  }
  if ((a = o(this, Ls)) == null || a.hide(), v(this, di, t), m(this, $, Ee).call(this, {
    hasSelectedText: !0
  }), !(o(this, ee) !== it.HIGHLIGHT && o(this, ee) !== it.NONE) && (o(this, ee) === it.HIGHLIGHT && this.showAllEditors("highlight", !0, !0), v(this, sn, this.isShiftKeyDown), !this.isShiftKeyDown)) {
    const h = o(this, ee) === it.HIGHLIGHT ? m(this, $, Ju).call(this, i) : null;
    h == null || h.toggleDrawing();
    const c = new AbortController(), d = this.combinedSignal(c), u = (f) => {
      f.type === "pointerup" && f.button !== 0 || (c.abort(), h == null || h.toggleDrawing(!0), f.type === "pointerup" && m(this, $, td).call(this, "main_toolbar"));
    };
    window.addEventListener("pointerup", u, {
      signal: d
    }), window.addEventListener("blur", u, {
      signal: d
    });
  }
}, td = function(e = "") {
  o(this, ee) === it.HIGHLIGHT ? this.highlightSelection(e) : o(this, Xl) && m(this, $, Om).call(this);
}, Dm = function() {
  document.addEventListener("selectionchange", m(this, $, Nm).bind(this), {
    signal: this._signal
  });
}, km = function() {
  if (o(this, en))
    return;
  v(this, en, new AbortController());
  const e = this.combinedSignal(o(this, en));
  window.addEventListener("focus", this.focus.bind(this), {
    signal: e
  }), window.addEventListener("blur", this.blur.bind(this), {
    signal: e
  });
}, Fm = function() {
  var e;
  (e = o(this, en)) == null || e.abort(), v(this, en, null);
}, qu = function() {
  if (o(this, rn))
    return;
  v(this, rn, new AbortController());
  const e = this.combinedSignal(o(this, rn));
  window.addEventListener("keydown", this.keydown.bind(this), {
    signal: e
  }), window.addEventListener("keyup", this.keyup.bind(this), {
    signal: e
  });
}, jm = function() {
  var e;
  (e = o(this, rn)) == null || e.abort(), v(this, rn, null);
}, tf = function() {
  if (o(this, tn))
    return;
  v(this, tn, new AbortController());
  const e = this.combinedSignal(o(this, tn));
  document.addEventListener("copy", this.copy.bind(this), {
    signal: e
  }), document.addEventListener("cut", this.cut.bind(this), {
    signal: e
  }), document.addEventListener("paste", this.paste.bind(this), {
    signal: e
  });
}, ef = function() {
  var e;
  (e = o(this, tn)) == null || e.abort(), v(this, tn, null);
}, Bm = function() {
  const e = this._signal;
  document.addEventListener("dragover", this.dragOver.bind(this), {
    signal: e
  }), document.addEventListener("drop", this.drop.bind(this), {
    signal: e
  });
}, Ee = function(e) {
  Object.entries(e).some(([s, i]) => o(this, th)[s] !== i) && (this._eventBus.dispatch("annotationeditorstateschanged", {
    source: this,
    details: Object.assign(o(this, th), e)
  }), o(this, ee) === it.HIGHLIGHT && e.hasSelectedEditor === !1 && m(this, $, Wi).call(this, [[J.HIGHLIGHT_FREE, !0]]));
}, Wi = function(e) {
  this._eventBus.dispatch("annotationeditorparamschanged", {
    source: this,
    details: e
  });
}, Hm = async function() {
  if (!o(this, nn)) {
    v(this, nn, !0);
    const e = [];
    for (const t of o(this, ae).values())
      e.push(t.enable());
    await Promise.all(e);
    for (const t of o(this, Gt).values())
      t.enable();
  }
}, $m = function() {
  if (this.unselectAll(), o(this, nn)) {
    v(this, nn, !1);
    for (const e of o(this, ae).values())
      e.disable();
    for (const e of o(this, Gt).values())
      e.disable();
  }
}, sf = function(e) {
  const t = o(this, ae).get(e.pageIndex);
  t ? t.addOrRebuild(e) : (this.addEditor(e), this.addToAnnotationStorage(e));
}, Vm = function() {
  let e = null;
  for (e of o(this, vt))
    ;
  return e;
}, fl = function() {
  if (o(this, Gt).size === 0)
    return !0;
  if (o(this, Gt).size === 1)
    for (const e of o(this, Gt).values())
      return e.isEmpty();
  return !1;
}, nf = function(e) {
  for (const t of o(this, vt))
    t.unselect();
  o(this, vt).clear();
  for (const t of e)
    t.isEmpty() || (o(this, vt).add(t), t.select());
  m(this, $, Ee).call(this, {
    hasSelectedEditor: this.hasSelection
  });
}, Z(ji, "TRANSLATE_SMALL", 1), Z(ji, "TRANSLATE_BIG", 10), ji);
var se, _s, fs, Os, He, Va, Ns, Re, fi, dr, Ds, Ua, qs, ed, sd;
const Jt = class Jt {
  constructor(e) {
    y(this, qs);
    y(this, se, null);
    y(this, _s, !1);
    y(this, fs, null);
    y(this, Os, null);
    y(this, He, null);
    y(this, Va, !1);
    y(this, Ns, null);
    y(this, Re, null);
    y(this, fi, null);
    y(this, dr, null);
    y(this, Ds, !1);
    v(this, Re, e), v(this, Ds, e._uiManager.useNewAltTextFlow), o(Jt, Ua) || v(Jt, Ua, Object.freeze({
      added: "pdfjs-editor-new-alt-text-added-button-label",
      missing: "pdfjs-editor-new-alt-text-missing-button-label",
      review: "pdfjs-editor-new-alt-text-to-review-button-label"
    }));
  }
  static initialize(e) {
    Jt._l10nPromise || (Jt._l10nPromise = e);
  }
  async render() {
    const e = v(this, fs, document.createElement("button"));
    e.className = "altText";
    let t;
    o(this, Ds) ? (e.classList.add("new"), t = await Jt._l10nPromise.get(o(Jt, Ua).missing)) : t = await Jt._l10nPromise.get("pdfjs-editor-alt-text-button-label"), e.textContent = t, e.setAttribute("aria-label", t), e.tabIndex = "0";
    const s = o(this, Re)._uiManager._signal;
    e.addEventListener("contextmenu", os, {
      signal: s
    }), e.addEventListener("pointerdown", (n) => n.stopPropagation(), {
      signal: s
    });
    const i = (n) => {
      n.preventDefault(), o(this, Re)._uiManager.editAltText(o(this, Re)), o(this, Ds) && o(this, Re)._reportTelemetry({
        action: "pdfjs.image.alt_text.image_status_label_clicked",
        data: {
          label: o(this, qs, ed)
        }
      });
    };
    return e.addEventListener("click", i, {
      capture: !0,
      signal: s
    }), e.addEventListener("keydown", (n) => {
      n.target === e && n.key === "Enter" && (v(this, Va, !0), i(n));
    }, {
      signal: s
    }), await m(this, qs, sd).call(this), e;
  }
  finish() {
    o(this, fs) && (o(this, fs).focus({
      focusVisible: o(this, Va)
    }), v(this, Va, !1));
  }
  isEmpty() {
    return o(this, Ds) ? o(this, se) === null : !o(this, se) && !o(this, _s);
  }
  hasData() {
    return o(this, Ds) ? o(this, se) !== null || !!o(this, fi) : this.isEmpty();
  }
  get guessedText() {
    return o(this, fi);
  }
  async setGuessedText(e) {
    o(this, se) === null && (v(this, fi, e), v(this, dr, await Jt._l10nPromise.get("pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer")({
      generatedAltText: e
    })), m(this, qs, sd).call(this));
  }
  toggleAltTextBadge(e = !1) {
    var t;
    if (!o(this, Ds) || o(this, se)) {
      (t = o(this, Ns)) == null || t.remove(), v(this, Ns, null);
      return;
    }
    if (!o(this, Ns)) {
      const s = v(this, Ns, document.createElement("div"));
      s.className = "noAltTextBadge", o(this, Re).div.append(s);
    }
    o(this, Ns).classList.toggle("hidden", !e);
  }
  serialize(e) {
    let t = o(this, se);
    return !e && o(this, fi) === t && (t = o(this, dr)), {
      altText: t,
      decorative: o(this, _s),
      guessedText: o(this, fi),
      textWithDisclaimer: o(this, dr)
    };
  }
  get data() {
    return {
      altText: o(this, se),
      decorative: o(this, _s)
    };
  }
  set data({
    altText: e,
    decorative: t,
    guessedText: s,
    textWithDisclaimer: i,
    cancel: n = !1
  }) {
    s && (v(this, fi, s), v(this, dr, i)), !(o(this, se) === e && o(this, _s) === t) && (n || (v(this, se, e), v(this, _s, t)), m(this, qs, sd).call(this));
  }
  toggle(e = !1) {
    o(this, fs) && (!e && o(this, He) && (clearTimeout(o(this, He)), v(this, He, null)), o(this, fs).disabled = !e);
  }
  shown() {
    o(this, Re)._reportTelemetry({
      action: "pdfjs.image.alt_text.image_status_label_displayed",
      data: {
        label: o(this, qs, ed)
      }
    });
  }
  destroy() {
    var e, t;
    (e = o(this, fs)) == null || e.remove(), v(this, fs, null), v(this, Os, null), (t = o(this, Ns)) == null || t.remove(), v(this, Ns, null);
  }
};
se = new WeakMap(), _s = new WeakMap(), fs = new WeakMap(), Os = new WeakMap(), He = new WeakMap(), Va = new WeakMap(), Ns = new WeakMap(), Re = new WeakMap(), fi = new WeakMap(), dr = new WeakMap(), Ds = new WeakMap(), Ua = new WeakMap(), qs = new WeakSet(), ed = function() {
  return o(this, se) && "added" || o(this, se) === null && this.guessedText && "review" || "missing";
}, sd = async function() {
  var i, n;
  const e = o(this, fs);
  if (!e)
    return;
  if (o(this, Ds)) {
    if (e.classList.toggle("done", !!o(this, se)), Jt._l10nPromise.get(o(Jt, Ua)[o(this, qs, ed)]).then((r) => {
      e.setAttribute("aria-label", r);
      for (const a of e.childNodes)
        if (a.nodeType === Node.TEXT_NODE) {
          a.textContent = r;
          break;
        }
    }), !o(this, se)) {
      (i = o(this, Os)) == null || i.remove();
      return;
    }
  } else {
    if (!o(this, se) && !o(this, _s)) {
      e.classList.remove("done"), (n = o(this, Os)) == null || n.remove();
      return;
    }
    e.classList.add("done"), Jt._l10nPromise.get("pdfjs-editor-alt-text-edit-button-label").then((r) => {
      e.setAttribute("aria-label", r);
    });
  }
  let t = o(this, Os);
  if (!t) {
    v(this, Os, t = document.createElement("span")), t.className = "tooltip", t.setAttribute("role", "tooltip"), t.id = `alt-text-tooltip-${o(this, Re).id}`;
    const r = 100, a = o(this, Re)._uiManager._signal;
    a.addEventListener("abort", () => {
      clearTimeout(o(this, He)), v(this, He, null);
    }, {
      once: !0
    }), e.addEventListener("mouseenter", () => {
      v(this, He, setTimeout(() => {
        v(this, He, null), o(this, Os).classList.add("show"), o(this, Re)._reportTelemetry({
          action: "alt_text_tooltip"
        });
      }, r));
    }, {
      signal: a
    }), e.addEventListener("mouseleave", () => {
      var h;
      o(this, He) && (clearTimeout(o(this, He)), v(this, He, null)), (h = o(this, Os)) == null || h.classList.remove("show");
    }, {
      signal: a
    });
  }
  t.innerText = o(this, _s) ? await Jt._l10nPromise.get("pdfjs-editor-alt-text-decorative-tooltip") : o(this, se), t.parentNode || e.append(t);
  const s = o(this, Re).getImageForAltText();
  s == null || s.setAttribute("aria-describedby", t.id);
}, y(Jt, Ua, null), Z(Jt, "_l10nPromise", null);
let Bd = Jt;
var ur, ps, Ct, za, fr, oe, pr, on, sh, gr, ln, ih, mr, pi, ks, Wa, Ga, qe, nh, Zd, rt, rf, rh, af, of, Um, zm, lf, hf, cf, Wm, df, Gm, Xm, Km, uf, pl;
const ut = class ut {
  constructor(e) {
    y(this, rt);
    y(this, ur, null);
    y(this, ps, null);
    y(this, Ct, null);
    y(this, za, !1);
    y(this, fr, !1);
    y(this, oe, null);
    y(this, pr, null);
    y(this, on, null);
    y(this, sh, "");
    y(this, gr, !1);
    y(this, ln, null);
    y(this, ih, !1);
    y(this, mr, !1);
    y(this, pi, !1);
    y(this, ks, null);
    y(this, Wa, 0);
    y(this, Ga, 0);
    y(this, qe, null);
    Z(this, "_editToolbar", null);
    Z(this, "_initialOptions", /* @__PURE__ */ Object.create(null));
    Z(this, "_initialData", null);
    Z(this, "_isVisible", !0);
    Z(this, "_uiManager", null);
    Z(this, "_focusEventsAllowed", !0);
    y(this, nh, !1);
    y(this, Zd, ut._zIndex++);
    this.parent = e.parent, this.id = e.id, this.width = this.height = null, this.pageIndex = e.parent.pageIndex, this.name = e.name, this.div = null, this._uiManager = e.uiManager, this.annotationElementId = null, this._willKeepAspectRatio = !1, this._initialOptions.isCentered = e.isCentered, this._structTreeParentId = null;
    const {
      rotation: t,
      rawDims: {
        pageWidth: s,
        pageHeight: i,
        pageX: n,
        pageY: r
      }
    } = this.parent.viewport;
    this.rotation = t, this.pageRotation = (360 + t - this._uiManager.viewParameters.rotation) % 360, this.pageDimensions = [s, i], this.pageTranslation = [n, r];
    const [a, h] = this.parentDimensions;
    this.x = e.x / a, this.y = e.y / h, this.isAttachedToDOM = !1, this.deleted = !1;
  }
  static get _resizerKeyboardManager() {
    const e = ut.prototype._resizeWithKeyboard, t = kl.TRANSLATE_SMALL, s = kl.TRANSLATE_BIG;
    return ht(this, "_resizerKeyboardManager", new Oc([[["ArrowLeft", "mac+ArrowLeft"], e, {
      args: [-t, 0]
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], e, {
      args: [-s, 0]
    }], [["ArrowRight", "mac+ArrowRight"], e, {
      args: [t, 0]
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], e, {
      args: [s, 0]
    }], [["ArrowUp", "mac+ArrowUp"], e, {
      args: [0, -t]
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], e, {
      args: [0, -s]
    }], [["ArrowDown", "mac+ArrowDown"], e, {
      args: [0, t]
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], e, {
      args: [0, s]
    }], [["Escape", "mac+Escape"], ut.prototype._stopResizingWithKeyboard]]));
  }
  get editorType() {
    return Object.getPrototypeOf(this).constructor._type;
  }
  static get _defaultLineColor() {
    return ht(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
  }
  static deleteAnnotationElement(e) {
    const t = new zy({
      id: e.parent.getNextId(),
      parent: e.parent,
      uiManager: e._uiManager
    });
    t.annotationElementId = e.annotationElementId, t.deleted = !0, t._uiManager.addToAnnotationStorage(t);
  }
  static initialize(e, t, s) {
    if (ut._l10nResizer || (ut._l10nResizer = Object.freeze({
      topLeft: "pdfjs-editor-resizer-top-left",
      topMiddle: "pdfjs-editor-resizer-top-middle",
      topRight: "pdfjs-editor-resizer-top-right",
      middleRight: "pdfjs-editor-resizer-middle-right",
      bottomRight: "pdfjs-editor-resizer-bottom-right",
      bottomMiddle: "pdfjs-editor-resizer-bottom-middle",
      bottomLeft: "pdfjs-editor-resizer-bottom-left",
      middleLeft: "pdfjs-editor-resizer-middle-left"
    })), ut._l10nPromise || (ut._l10nPromise = new Map([...["pdfjs-editor-alt-text-button-label", "pdfjs-editor-alt-text-edit-button-label", "pdfjs-editor-alt-text-decorative-tooltip", "pdfjs-editor-new-alt-text-added-button-label", "pdfjs-editor-new-alt-text-missing-button-label", "pdfjs-editor-new-alt-text-to-review-button-label"].map((n) => [n, e.get(n)]), ...["pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer"].map((n) => [n, e.get.bind(e, n)])])), s != null && s.strings)
      for (const n of s.strings)
        ut._l10nPromise.set(n, e.get(n));
    if (ut._borderLineWidth !== -1)
      return;
    const i = getComputedStyle(document.documentElement);
    ut._borderLineWidth = parseFloat(i.getPropertyValue("--outline-width")) || 0;
  }
  static updateDefaultParams(e, t) {
  }
  static get defaultPropertiesToUpdate() {
    return [];
  }
  static isHandlingMimeForPasting(e) {
    return !1;
  }
  static paste(e, t) {
    Ut("Not implemented");
  }
  get propertiesToUpdate() {
    return [];
  }
  get _isDraggable() {
    return o(this, nh);
  }
  set _isDraggable(e) {
    var t;
    v(this, nh, e), (t = this.div) == null || t.classList.toggle("draggable", e);
  }
  get isEnterHandled() {
    return !0;
  }
  center() {
    const [e, t] = this.pageDimensions;
    switch (this.parentRotation) {
      case 90:
        this.x -= this.height * t / (e * 2), this.y += this.width * e / (t * 2);
        break;
      case 180:
        this.x += this.width / 2, this.y += this.height / 2;
        break;
      case 270:
        this.x += this.height * t / (e * 2), this.y -= this.width * e / (t * 2);
        break;
      default:
        this.x -= this.width / 2, this.y -= this.height / 2;
        break;
    }
    this.fixAndSetPosition();
  }
  addCommands(e) {
    this._uiManager.addCommands(e);
  }
  get currentLayer() {
    return this._uiManager.currentLayer;
  }
  setInBackground() {
    this.div.style.zIndex = 0;
  }
  setInForeground() {
    this.div.style.zIndex = o(this, Zd);
  }
  setParent(e) {
    e !== null ? (this.pageIndex = e.pageIndex, this.pageDimensions = e.pageDimensions) : m(this, rt, pl).call(this), this.parent = e;
  }
  focusin(e) {
    this._focusEventsAllowed && (o(this, gr) ? v(this, gr, !1) : this.parent.setSelected(this));
  }
  focusout(e) {
    var s;
    if (!this._focusEventsAllowed || !this.isAttachedToDOM)
      return;
    const t = e.relatedTarget;
    t != null && t.closest(`#${this.id}`) || (e.preventDefault(), (s = this.parent) != null && s.isMultipleSelection || this.commitOrRemove());
  }
  commitOrRemove() {
    this.isEmpty() ? this.remove() : this.commit();
  }
  commit() {
    this.addToAnnotationStorage();
  }
  addToAnnotationStorage() {
    this._uiManager.addToAnnotationStorage(this);
  }
  setAt(e, t, s, i) {
    const [n, r] = this.parentDimensions;
    [s, i] = this.screenToPageTranslation(s, i), this.x = (e + s) / n, this.y = (t + i) / r, this.fixAndSetPosition();
  }
  translate(e, t) {
    m(this, rt, rf).call(this, this.parentDimensions, e, t);
  }
  translateInPage(e, t) {
    o(this, ln) || v(this, ln, [this.x, this.y]), m(this, rt, rf).call(this, this.pageDimensions, e, t), this.div.scrollIntoView({
      block: "nearest"
    });
  }
  drag(e, t) {
    o(this, ln) || v(this, ln, [this.x, this.y]);
    const [s, i] = this.parentDimensions;
    if (this.x += e / s, this.y += t / i, this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
      const {
        x: c,
        y: d
      } = this.div.getBoundingClientRect();
      this.parent.findNewParent(this, c, d) && (this.x -= Math.floor(this.x), this.y -= Math.floor(this.y));
    }
    let {
      x: n,
      y: r
    } = this;
    const [a, h] = this.getBaseTranslation();
    n += a, r += h, this.div.style.left = `${(100 * n).toFixed(2)}%`, this.div.style.top = `${(100 * r).toFixed(2)}%`, this.div.scrollIntoView({
      block: "nearest"
    });
  }
  get _hasBeenMoved() {
    return !!o(this, ln) && (o(this, ln)[0] !== this.x || o(this, ln)[1] !== this.y);
  }
  getBaseTranslation() {
    const [e, t] = this.parentDimensions, {
      _borderLineWidth: s
    } = ut, i = s / e, n = s / t;
    switch (this.rotation) {
      case 90:
        return [-i, n];
      case 180:
        return [i, n];
      case 270:
        return [i, -n];
      default:
        return [-i, -n];
    }
  }
  get _mustFixPosition() {
    return !0;
  }
  fixAndSetPosition(e = this.rotation) {
    const [t, s] = this.pageDimensions;
    let {
      x: i,
      y: n,
      width: r,
      height: a
    } = this;
    if (r *= t, a *= s, i *= t, n *= s, this._mustFixPosition)
      switch (e) {
        case 0:
          i = Math.max(0, Math.min(t - r, i)), n = Math.max(0, Math.min(s - a, n));
          break;
        case 90:
          i = Math.max(0, Math.min(t - a, i)), n = Math.min(s, Math.max(r, n));
          break;
        case 180:
          i = Math.min(t, Math.max(r, i)), n = Math.min(s, Math.max(a, n));
          break;
        case 270:
          i = Math.min(t, Math.max(a, i)), n = Math.max(0, Math.min(s - r, n));
          break;
      }
    this.x = i /= t, this.y = n /= s;
    const [h, c] = this.getBaseTranslation();
    i += h, n += c;
    const {
      style: d
    } = this.div;
    d.left = `${(100 * i).toFixed(2)}%`, d.top = `${(100 * n).toFixed(2)}%`, this.moveInDOM();
  }
  screenToPageTranslation(e, t) {
    var s;
    return m(s = ut, rh, af).call(s, e, t, this.parentRotation);
  }
  pageTranslationToScreen(e, t) {
    var s;
    return m(s = ut, rh, af).call(s, e, t, 360 - this.parentRotation);
  }
  get parentScale() {
    return this._uiManager.viewParameters.realScale;
  }
  get parentRotation() {
    return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
  }
  get parentDimensions() {
    const {
      parentScale: e,
      pageDimensions: [t, s]
    } = this;
    return [t * e, s * e];
  }
  setDims(e, t) {
    const [s, i] = this.parentDimensions;
    this.div.style.width = `${(100 * e / s).toFixed(2)}%`, o(this, fr) || (this.div.style.height = `${(100 * t / i).toFixed(2)}%`);
  }
  fixDims() {
    const {
      style: e
    } = this.div, {
      height: t,
      width: s
    } = e, i = s.endsWith("%"), n = !o(this, fr) && t.endsWith("%");
    if (i && n)
      return;
    const [r, a] = this.parentDimensions;
    i || (e.width = `${(100 * parseFloat(s) / r).toFixed(2)}%`), !o(this, fr) && !n && (e.height = `${(100 * parseFloat(t) / a).toFixed(2)}%`);
  }
  getInitialTranslation() {
    return [0, 0];
  }
  altTextFinish() {
    var e;
    (e = o(this, Ct)) == null || e.finish();
  }
  async addEditToolbar() {
    return this._editToolbar || o(this, mr) ? this._editToolbar : (this._editToolbar = new Ku(this), this.div.append(this._editToolbar.render()), o(this, Ct) && await this._editToolbar.addAltText(o(this, Ct)), this._editToolbar);
  }
  removeEditToolbar() {
    var e;
    this._editToolbar && (this._editToolbar.remove(), this._editToolbar = null, (e = o(this, Ct)) == null || e.destroy());
  }
  addContainer(e) {
    var s;
    const t = (s = this._editToolbar) == null ? void 0 : s.div;
    t ? t.before(e) : this.div.append(e);
  }
  getClientDimensions() {
    return this.div.getBoundingClientRect();
  }
  async addAltTextButton() {
    o(this, Ct) || (Bd.initialize(ut._l10nPromise), v(this, Ct, new Bd(this)), o(this, ur) && (o(this, Ct).data = o(this, ur), v(this, ur, null)), await this.addEditToolbar());
  }
  get altTextData() {
    var e;
    return (e = o(this, Ct)) == null ? void 0 : e.data;
  }
  set altTextData(e) {
    o(this, Ct) && (o(this, Ct).data = e);
  }
  get guessedAltText() {
    var e;
    return (e = o(this, Ct)) == null ? void 0 : e.guessedText;
  }
  async setGuessedAltText(e) {
    var t;
    await ((t = o(this, Ct)) == null ? void 0 : t.setGuessedText(e));
  }
  serializeAltText(e) {
    var t;
    return (t = o(this, Ct)) == null ? void 0 : t.serialize(e);
  }
  hasAltText() {
    return !!o(this, Ct) && !o(this, Ct).isEmpty();
  }
  hasAltTextData() {
    var e;
    return ((e = o(this, Ct)) == null ? void 0 : e.hasData()) ?? !1;
  }
  render() {
    this.div = document.createElement("div"), this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360), this.div.className = this.name, this.div.setAttribute("id", this.id), this.div.tabIndex = o(this, za) ? -1 : 0, this._isVisible || this.div.classList.add("hidden"), this.setInForeground(), m(this, rt, df).call(this);
    const [e, t] = this.parentDimensions;
    this.parentRotation % 180 !== 0 && (this.div.style.maxWidth = `${(100 * t / e).toFixed(2)}%`, this.div.style.maxHeight = `${(100 * e / t).toFixed(2)}%`);
    const [s, i] = this.getInitialTranslation();
    return this.translate(s, i), jd(this, this.div, ["pointerdown"]), this.div;
  }
  pointerdown(e) {
    const {
      isMac: t
    } = ke.platform;
    if (e.button !== 0 || e.ctrlKey && t) {
      e.preventDefault();
      return;
    }
    if (v(this, gr, !0), this._isDraggable) {
      m(this, rt, Wm).call(this, e);
      return;
    }
    m(this, rt, cf).call(this, e);
  }
  moveInDOM() {
    o(this, ks) && clearTimeout(o(this, ks)), v(this, ks, setTimeout(() => {
      var e;
      v(this, ks, null), (e = this.parent) == null || e.moveEditorInDOM(this);
    }, 0));
  }
  _setParentAndPosition(e, t, s) {
    e.changeParent(this), this.x = t, this.y = s, this.fixAndSetPosition();
  }
  getRect(e, t, s = this.rotation) {
    const i = this.parentScale, [n, r] = this.pageDimensions, [a, h] = this.pageTranslation, c = e / i, d = t / i, u = this.x * n, f = this.y * r, p = this.width * n, g = this.height * r;
    switch (s) {
      case 0:
        return [u + c + a, r - f - d - g + h, u + c + p + a, r - f - d + h];
      case 90:
        return [u + d + a, r - f + c + h, u + d + g + a, r - f + c + p + h];
      case 180:
        return [u - c - p + a, r - f + d + h, u - c + a, r - f + d + g + h];
      case 270:
        return [u - d - g + a, r - f - c - p + h, u - d + a, r - f - c + h];
      default:
        throw new Error("Invalid rotation");
    }
  }
  getRectInCurrentCoords(e, t) {
    const [s, i, n, r] = e, a = n - s, h = r - i;
    switch (this.rotation) {
      case 0:
        return [s, t - r, a, h];
      case 90:
        return [s, t - i, h, a];
      case 180:
        return [n, t - i, a, h];
      case 270:
        return [n, t - r, h, a];
      default:
        throw new Error("Invalid rotation");
    }
  }
  onceAdded() {
  }
  isEmpty() {
    return !1;
  }
  enableEditMode() {
    v(this, mr, !0);
  }
  disableEditMode() {
    v(this, mr, !1);
  }
  isInEditMode() {
    return o(this, mr);
  }
  shouldGetKeyboardEvents() {
    return o(this, pi);
  }
  needsToBeRebuilt() {
    return this.div && !this.isAttachedToDOM;
  }
  rebuild() {
    m(this, rt, df).call(this);
  }
  rotate(e) {
  }
  serializeDeleted() {
    var e;
    return {
      id: this.annotationElementId,
      deleted: !0,
      pageIndex: this.pageIndex,
      popupRef: ((e = this._initialData) == null ? void 0 : e.popupRef) || ""
    };
  }
  serialize(e = !1, t = null) {
    Ut("An editor must be serializable");
  }
  static async deserialize(e, t, s) {
    const i = new this.prototype.constructor({
      parent: t,
      id: t.getNextId(),
      uiManager: s
    });
    i.rotation = e.rotation, v(i, ur, e.accessibilityData);
    const [n, r] = i.pageDimensions, [a, h, c, d] = i.getRectInCurrentCoords(e.rect, r);
    return i.x = a / n, i.y = h / r, i.width = c / n, i.height = d / r, i;
  }
  get hasBeenModified() {
    return !!this.annotationElementId && (this.deleted || this.serialize() !== null);
  }
  remove() {
    var e;
    if ((e = o(this, on)) == null || e.abort(), v(this, on, null), this.isEmpty() || this.commit(), this.parent ? this.parent.remove(this) : this._uiManager.removeEditor(this), o(this, ks) && (clearTimeout(o(this, ks)), v(this, ks, null)), m(this, rt, pl).call(this), this.removeEditToolbar(), o(this, qe)) {
      for (const t of o(this, qe).values())
        clearTimeout(t);
      v(this, qe, null);
    }
    this.parent = null;
  }
  get isResizable() {
    return !1;
  }
  makeResizable() {
    this.isResizable && (m(this, rt, Um).call(this), o(this, oe).classList.remove("hidden"), jd(this, this.div, ["keydown"]));
  }
  get toolbarPosition() {
    return null;
  }
  keydown(e) {
    if (!this.isResizable || e.target !== this.div || e.key !== "Enter")
      return;
    this._uiManager.setSelected(this), v(this, pr, {
      savedX: this.x,
      savedY: this.y,
      savedWidth: this.width,
      savedHeight: this.height
    });
    const t = o(this, oe).children;
    if (!o(this, ps)) {
      v(this, ps, Array.from(t));
      const r = m(this, rt, Gm).bind(this), a = m(this, rt, Xm).bind(this), h = this._uiManager._signal;
      for (const c of o(this, ps)) {
        const d = c.getAttribute("data-resizer-name");
        c.setAttribute("role", "spinbutton"), c.addEventListener("keydown", r, {
          signal: h
        }), c.addEventListener("blur", a, {
          signal: h
        }), c.addEventListener("focus", m(this, rt, Km).bind(this, d), {
          signal: h
        }), c.setAttribute("data-l10n-id", ut._l10nResizer[d]);
      }
    }
    const s = o(this, ps)[0];
    let i = 0;
    for (const r of t) {
      if (r === s)
        break;
      i++;
    }
    const n = (360 - this.rotation + this.parentRotation) % 360 / 90 * (o(this, ps).length / 4);
    if (n !== i) {
      if (n < i)
        for (let a = 0; a < i - n; a++)
          o(this, oe).append(o(this, oe).firstChild);
      else if (n > i)
        for (let a = 0; a < n - i; a++)
          o(this, oe).firstChild.before(o(this, oe).lastChild);
      let r = 0;
      for (const a of t) {
        const c = o(this, ps)[r++].getAttribute("data-resizer-name");
        a.setAttribute("data-l10n-id", ut._l10nResizer[c]);
      }
    }
    m(this, rt, uf).call(this, 0), v(this, pi, !0), o(this, oe).firstChild.focus({
      focusVisible: !0
    }), e.preventDefault(), e.stopImmediatePropagation();
  }
  _resizeWithKeyboard(e, t) {
    o(this, pi) && m(this, rt, hf).call(this, o(this, sh), {
      movementX: e,
      movementY: t
    });
  }
  _stopResizingWithKeyboard() {
    m(this, rt, pl).call(this), this.div.focus();
  }
  select() {
    var e, t, s;
    if (this.makeResizable(), (e = this.div) == null || e.classList.add("selectedEditor"), !this._editToolbar) {
      this.addEditToolbar().then(() => {
        var i, n;
        (i = this.div) != null && i.classList.contains("selectedEditor") && ((n = this._editToolbar) == null || n.show());
      });
      return;
    }
    (t = this._editToolbar) == null || t.show(), (s = o(this, Ct)) == null || s.toggleAltTextBadge(!1);
  }
  unselect() {
    var e, t, s, i, n;
    (e = o(this, oe)) == null || e.classList.add("hidden"), (t = this.div) == null || t.classList.remove("selectedEditor"), (s = this.div) != null && s.contains(document.activeElement) && this._uiManager.currentLayer.div.focus({
      preventScroll: !0
    }), (i = this._editToolbar) == null || i.hide(), (n = o(this, Ct)) == null || n.toggleAltTextBadge(!0);
  }
  updateParams(e, t) {
  }
  disableEditing() {
  }
  enableEditing() {
  }
  enterInEditMode() {
  }
  getImageForAltText() {
    return null;
  }
  get contentDiv() {
    return this.div;
  }
  get isEditing() {
    return o(this, ih);
  }
  set isEditing(e) {
    v(this, ih, e), this.parent && (e ? (this.parent.setSelected(this), this.parent.setActiveEditor(this)) : this.parent.setActiveEditor(null));
  }
  setAspectRatio(e, t) {
    v(this, fr, !0);
    const s = e / t, {
      style: i
    } = this.div;
    i.aspectRatio = s, i.height = "auto";
  }
  static get MIN_SIZE() {
    return 16;
  }
  static canCreateNewEmptyEditor() {
    return !0;
  }
  get telemetryInitialData() {
    return {
      action: "added"
    };
  }
  get telemetryFinalData() {
    return null;
  }
  _reportTelemetry(e, t = !1) {
    if (t) {
      o(this, qe) || v(this, qe, /* @__PURE__ */ new Map());
      const {
        action: s
      } = e;
      let i = o(this, qe).get(s);
      i && clearTimeout(i), i = setTimeout(() => {
        this._reportTelemetry(e), o(this, qe).delete(s), o(this, qe).size === 0 && v(this, qe, null);
      }, ut._telemetryTimeout), o(this, qe).set(s, i);
      return;
    }
    e.type || (e.type = this.editorType), this._uiManager._eventBus.dispatch("reporttelemetry", {
      source: this,
      details: {
        type: "editing",
        data: e
      }
    });
  }
  show(e = this._isVisible) {
    this.div.classList.toggle("hidden", !e), this._isVisible = e;
  }
  enable() {
    this.div && (this.div.tabIndex = 0), v(this, za, !1);
  }
  disable() {
    this.div && (this.div.tabIndex = -1), v(this, za, !0);
  }
  renderAnnotationElement(e) {
    let t = e.container.querySelector(".annotationContent");
    if (!t)
      t = document.createElement("div"), t.classList.add("annotationContent", this.editorType), e.container.prepend(t);
    else if (t.nodeName === "CANVAS") {
      const s = t;
      t = document.createElement("div"), t.classList.add("annotationContent", this.editorType), s.before(t);
    }
    return t;
  }
  resetAnnotationElement(e) {
    const {
      firstChild: t
    } = e.container;
    (t == null ? void 0 : t.nodeName) === "DIV" && t.classList.contains("annotationContent") && t.remove();
  }
};
ur = new WeakMap(), ps = new WeakMap(), Ct = new WeakMap(), za = new WeakMap(), fr = new WeakMap(), oe = new WeakMap(), pr = new WeakMap(), on = new WeakMap(), sh = new WeakMap(), gr = new WeakMap(), ln = new WeakMap(), ih = new WeakMap(), mr = new WeakMap(), pi = new WeakMap(), ks = new WeakMap(), Wa = new WeakMap(), Ga = new WeakMap(), qe = new WeakMap(), nh = new WeakMap(), Zd = new WeakMap(), rt = new WeakSet(), rf = function([e, t], s, i) {
  [s, i] = this.screenToPageTranslation(s, i), this.x += s / e, this.y += i / t, this.fixAndSetPosition();
}, rh = new WeakSet(), af = function(e, t, s) {
  switch (s) {
    case 90:
      return [t, -e];
    case 180:
      return [-e, -t];
    case 270:
      return [-t, e];
    default:
      return [e, t];
  }
}, of = function(e) {
  switch (e) {
    case 90: {
      const [t, s] = this.pageDimensions;
      return [0, -t / s, s / t, 0];
    }
    case 180:
      return [-1, 0, 0, -1];
    case 270: {
      const [t, s] = this.pageDimensions;
      return [0, t / s, -s / t, 0];
    }
    default:
      return [1, 0, 0, 1];
  }
}, Um = function() {
  if (o(this, oe))
    return;
  v(this, oe, document.createElement("div")), o(this, oe).classList.add("resizers");
  const e = this._willKeepAspectRatio ? ["topLeft", "topRight", "bottomRight", "bottomLeft"] : ["topLeft", "topMiddle", "topRight", "middleRight", "bottomRight", "bottomMiddle", "bottomLeft", "middleLeft"], t = this._uiManager._signal;
  for (const s of e) {
    const i = document.createElement("div");
    o(this, oe).append(i), i.classList.add("resizer", s), i.setAttribute("data-resizer-name", s), i.addEventListener("pointerdown", m(this, rt, zm).bind(this, s), {
      signal: t
    }), i.addEventListener("contextmenu", os, {
      signal: t
    }), i.tabIndex = -1;
  }
  this.div.prepend(o(this, oe));
}, zm = function(e, t) {
  var g;
  t.preventDefault();
  const {
    isMac: s
  } = ke.platform;
  if (t.button !== 0 || t.ctrlKey && s)
    return;
  (g = o(this, Ct)) == null || g.toggle(!1);
  const i = this._isDraggable;
  this._isDraggable = !1;
  const n = new AbortController(), r = this._uiManager.combinedSignal(n);
  this.parent.togglePointerEvents(!1), window.addEventListener("pointermove", m(this, rt, hf).bind(this, e), {
    passive: !0,
    capture: !0,
    signal: r
  }), window.addEventListener("contextmenu", os, {
    signal: r
  });
  const a = this.x, h = this.y, c = this.width, d = this.height, u = this.parent.div.style.cursor, f = this.div.style.cursor;
  this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(t.target).cursor;
  const p = () => {
    var b;
    n.abort(), this.parent.togglePointerEvents(!0), (b = o(this, Ct)) == null || b.toggle(!0), this._isDraggable = i, this.parent.div.style.cursor = u, this.div.style.cursor = f, m(this, rt, lf).call(this, a, h, c, d);
  };
  window.addEventListener("pointerup", p, {
    signal: r
  }), window.addEventListener("blur", p, {
    signal: r
  });
}, lf = function(e, t, s, i) {
  const n = this.x, r = this.y, a = this.width, h = this.height;
  n === e && r === t && a === s && h === i || this.addCommands({
    cmd: () => {
      this.width = a, this.height = h, this.x = n, this.y = r;
      const [c, d] = this.parentDimensions;
      this.setDims(c * a, d * h), this.fixAndSetPosition();
    },
    undo: () => {
      this.width = s, this.height = i, this.x = e, this.y = t;
      const [c, d] = this.parentDimensions;
      this.setDims(c * s, d * i), this.fixAndSetPosition();
    },
    mustExec: !0
  });
}, hf = function(e, t) {
  const [s, i] = this.parentDimensions, n = this.x, r = this.y, a = this.width, h = this.height, c = ut.MIN_SIZE / s, d = ut.MIN_SIZE / i, u = (F) => Math.round(F * 1e4) / 1e4, f = m(this, rt, of).call(this, this.rotation), p = (F, z) => [f[0] * F + f[2] * z, f[1] * F + f[3] * z], g = m(this, rt, of).call(this, 360 - this.rotation), b = (F, z) => [g[0] * F + g[2] * z, g[1] * F + g[3] * z];
  let E, A, w = !1, x = !1;
  switch (e) {
    case "topLeft":
      w = !0, E = (F, z) => [0, 0], A = (F, z) => [F, z];
      break;
    case "topMiddle":
      E = (F, z) => [F / 2, 0], A = (F, z) => [F / 2, z];
      break;
    case "topRight":
      w = !0, E = (F, z) => [F, 0], A = (F, z) => [0, z];
      break;
    case "middleRight":
      x = !0, E = (F, z) => [F, z / 2], A = (F, z) => [0, z / 2];
      break;
    case "bottomRight":
      w = !0, E = (F, z) => [F, z], A = (F, z) => [0, 0];
      break;
    case "bottomMiddle":
      E = (F, z) => [F / 2, z], A = (F, z) => [F / 2, 0];
      break;
    case "bottomLeft":
      w = !0, E = (F, z) => [0, z], A = (F, z) => [F, 0];
      break;
    case "middleLeft":
      x = !0, E = (F, z) => [0, z / 2], A = (F, z) => [F, z / 2];
      break;
  }
  const P = E(a, h), T = A(a, h);
  let C = p(...T);
  const R = u(n + C[0]), M = u(r + C[1]);
  let S = 1, I = 1, [_, D] = this.screenToPageTranslation(t.movementX, t.movementY);
  if ([_, D] = b(_ / s, D / i), w) {
    const F = Math.hypot(a, h);
    S = I = Math.max(Math.min(Math.hypot(T[0] - P[0] - _, T[1] - P[1] - D) / F, 1 / a, 1 / h), c / a, d / h);
  } else x ? S = Math.max(c, Math.min(1, Math.abs(T[0] - P[0] - _))) / a : I = Math.max(d, Math.min(1, Math.abs(T[1] - P[1] - D))) / h;
  const k = u(a * S), j = u(h * I);
  C = p(...A(k, j));
  const H = R - C[0], L = M - C[1];
  this.width = k, this.height = j, this.x = H, this.y = L, this.setDims(s * k, i * j), this.fixAndSetPosition();
}, cf = function(e) {
  const {
    isMac: t
  } = ke.platform;
  e.ctrlKey && !t || e.shiftKey || e.metaKey && t ? this.parent.toggleSelected(this) : this.parent.setSelected(this);
}, Wm = function(e) {
  const t = this._uiManager.isSelected(this);
  this._uiManager.setUpDragSession();
  const s = new AbortController(), i = this._uiManager.combinedSignal(s);
  if (t) {
    this.div.classList.add("moving"), v(this, Wa, e.clientX), v(this, Ga, e.clientY);
    const r = (a) => {
      const {
        clientX: h,
        clientY: c
      } = a, [d, u] = this.screenToPageTranslation(h - o(this, Wa), c - o(this, Ga));
      v(this, Wa, h), v(this, Ga, c), this._uiManager.dragSelectedEditors(d, u);
    };
    window.addEventListener("pointermove", r, {
      passive: !0,
      capture: !0,
      signal: i
    });
  }
  const n = () => {
    s.abort(), t && this.div.classList.remove("moving"), v(this, gr, !1), this._uiManager.endDragSession() || m(this, rt, cf).call(this, e);
  };
  window.addEventListener("pointerup", n, {
    signal: i
  }), window.addEventListener("blur", n, {
    signal: i
  });
}, df = function() {
  if (o(this, on) || !this.div)
    return;
  v(this, on, new AbortController());
  const e = this._uiManager.combinedSignal(o(this, on));
  this.div.addEventListener("focusin", this.focusin.bind(this), {
    signal: e
  }), this.div.addEventListener("focusout", this.focusout.bind(this), {
    signal: e
  });
}, Gm = function(e) {
  ut._resizerKeyboardManager.exec(this, e);
}, Xm = function(e) {
  var t;
  o(this, pi) && ((t = e.relatedTarget) == null ? void 0 : t.parentNode) !== o(this, oe) && m(this, rt, pl).call(this);
}, Km = function(e) {
  v(this, sh, o(this, pi) ? e : "");
}, uf = function(e) {
  if (o(this, ps))
    for (const t of o(this, ps))
      t.tabIndex = e;
}, pl = function() {
  if (v(this, pi, !1), m(this, rt, uf).call(this, -1), o(this, pr)) {
    const {
      savedX: e,
      savedY: t,
      savedWidth: s,
      savedHeight: i
    } = o(this, pr);
    m(this, rt, lf).call(this, e, t, s, i), v(this, pr, null);
  }
}, y(ut, rh), Z(ut, "_l10nPromise", null), Z(ut, "_l10nResizer", null), Z(ut, "_borderLineWidth", -1), Z(ut, "_colorManager", new Zu()), Z(ut, "_zIndex", 1), Z(ut, "_telemetryTimeout", 1e3);
let mt = ut;
class zy extends mt {
  constructor(e) {
    super(e), this.annotationElementId = e.annotationElementId, this.deleted = !0;
  }
  serialize() {
    return this.serializeDeleted();
  }
}
const dg = 3285377520, Ze = 4294901760, Ts = 65535;
class Ym {
  constructor(e) {
    this.h1 = e ? e & 4294967295 : dg, this.h2 = e ? e & 4294967295 : dg;
  }
  update(e) {
    let t, s;
    if (typeof e == "string") {
      t = new Uint8Array(e.length * 2), s = 0;
      for (let b = 0, E = e.length; b < E; b++) {
        const A = e.charCodeAt(b);
        A <= 255 ? t[s++] = A : (t[s++] = A >>> 8, t[s++] = A & 255);
      }
    } else if (ArrayBuffer.isView(e))
      t = e.slice(), s = t.byteLength;
    else
      throw new Error("Invalid data format, must be a string or TypedArray.");
    const i = s >> 2, n = s - i * 4, r = new Uint32Array(t.buffer, 0, i);
    let a = 0, h = 0, c = this.h1, d = this.h2;
    const u = 3432918353, f = 461845907, p = u & Ts, g = f & Ts;
    for (let b = 0; b < i; b++)
      b & 1 ? (a = r[b], a = a * u & Ze | a * p & Ts, a = a << 15 | a >>> 17, a = a * f & Ze | a * g & Ts, c ^= a, c = c << 13 | c >>> 19, c = c * 5 + 3864292196) : (h = r[b], h = h * u & Ze | h * p & Ts, h = h << 15 | h >>> 17, h = h * f & Ze | h * g & Ts, d ^= h, d = d << 13 | d >>> 19, d = d * 5 + 3864292196);
    switch (a = 0, n) {
      case 3:
        a ^= t[i * 4 + 2] << 16;
      case 2:
        a ^= t[i * 4 + 1] << 8;
      case 1:
        a ^= t[i * 4], a = a * u & Ze | a * p & Ts, a = a << 15 | a >>> 17, a = a * f & Ze | a * g & Ts, i & 1 ? c ^= a : d ^= a;
    }
    this.h1 = c, this.h2 = d;
  }
  hexdigest() {
    let e = this.h1, t = this.h2;
    return e ^= t >>> 1, e = e * 3981806797 & Ze | e * 36045 & Ts, t = t * 4283543511 & Ze | ((t << 16 | e >>> 16) * 2950163797 & Ze) >>> 16, e ^= t >>> 1, e = e * 444984403 & Ze | e * 60499 & Ts, t = t * 3301882366 & Ze | ((t << 16 | e >>> 16) * 3120437893 & Ze) >>> 16, e ^= t >>> 1, (e >>> 0).toString(16).padStart(8, "0") + (t >>> 0).toString(16).padStart(8, "0");
  }
}
const ff = Object.freeze({
  map: null,
  hash: "",
  transfer: void 0
});
var vr, br, ie, Jd, Qm;
class Wp {
  constructor() {
    y(this, Jd);
    y(this, vr, !1);
    y(this, br, null);
    y(this, ie, /* @__PURE__ */ new Map());
    this.onSetModified = null, this.onResetModified = null, this.onAnnotationEditor = null;
  }
  getValue(e, t) {
    const s = o(this, ie).get(e);
    return s === void 0 ? t : Object.assign(t, s);
  }
  getRawValue(e) {
    return o(this, ie).get(e);
  }
  remove(e) {
    if (o(this, ie).delete(e), o(this, ie).size === 0 && this.resetModified(), typeof this.onAnnotationEditor == "function") {
      for (const t of o(this, ie).values())
        if (t instanceof mt)
          return;
      this.onAnnotationEditor(null);
    }
  }
  setValue(e, t) {
    const s = o(this, ie).get(e);
    let i = !1;
    if (s !== void 0)
      for (const [n, r] of Object.entries(t))
        s[n] !== r && (i = !0, s[n] = r);
    else
      i = !0, o(this, ie).set(e, t);
    i && m(this, Jd, Qm).call(this), t instanceof mt && typeof this.onAnnotationEditor == "function" && this.onAnnotationEditor(t.constructor._type);
  }
  has(e) {
    return o(this, ie).has(e);
  }
  getAll() {
    return o(this, ie).size > 0 ? Bp(o(this, ie)) : null;
  }
  setAll(e) {
    for (const [t, s] of Object.entries(e))
      this.setValue(t, s);
  }
  get size() {
    return o(this, ie).size;
  }
  resetModified() {
    o(this, vr) && (v(this, vr, !1), typeof this.onResetModified == "function" && this.onResetModified());
  }
  get print() {
    return new Zm(this);
  }
  get serializable() {
    if (o(this, ie).size === 0)
      return ff;
    const e = /* @__PURE__ */ new Map(), t = new Ym(), s = [], i = /* @__PURE__ */ Object.create(null);
    let n = !1;
    for (const [r, a] of o(this, ie)) {
      const h = a instanceof mt ? a.serialize(!1, i) : a;
      h && (e.set(r, h), t.update(`${r}:${JSON.stringify(h)}`), n || (n = !!h.bitmap));
    }
    if (n)
      for (const r of e.values())
        r.bitmap && s.push(r.bitmap);
    return e.size > 0 ? {
      map: e,
      hash: t.hexdigest(),
      transfer: s
    } : ff;
  }
  get editorStats() {
    let e = null;
    const t = /* @__PURE__ */ new Map();
    for (const s of o(this, ie).values()) {
      if (!(s instanceof mt))
        continue;
      const i = s.telemetryFinalData;
      if (!i)
        continue;
      const {
        type: n
      } = i;
      t.has(n) || t.set(n, Object.getPrototypeOf(s).constructor), e || (e = /* @__PURE__ */ Object.create(null));
      const r = e[n] || (e[n] = /* @__PURE__ */ new Map());
      for (const [a, h] of Object.entries(i)) {
        if (a === "type")
          continue;
        let c = r.get(a);
        c || (c = /* @__PURE__ */ new Map(), r.set(a, c));
        const d = c.get(h) ?? 0;
        c.set(h, d + 1);
      }
    }
    for (const [s, i] of t)
      e[s] = i.computeTelemetryFinalData(e[s]);
    return e;
  }
  resetModifiedIds() {
    v(this, br, null);
  }
  get modifiedIds() {
    if (o(this, br))
      return o(this, br);
    const e = [];
    for (const t of o(this, ie).values())
      !(t instanceof mt) || !t.annotationElementId || !t.serialize() || e.push(t.annotationElementId);
    return v(this, br, {
      ids: new Set(e),
      hash: e.join(",")
    });
  }
}
vr = new WeakMap(), br = new WeakMap(), ie = new WeakMap(), Jd = new WeakSet(), Qm = function() {
  o(this, vr) || (v(this, vr, !0), typeof this.onSetModified == "function" && this.onSetModified());
};
var ah;
class Zm extends Wp {
  constructor(t) {
    super();
    y(this, ah);
    const {
      map: s,
      hash: i,
      transfer: n
    } = t.serializable, r = structuredClone(s, n ? {
      transfer: n
    } : null);
    v(this, ah, {
      map: r,
      hash: i,
      transfer: n
    });
  }
  get print() {
    Ut("Should not call PrintAnnotationStorage.print");
  }
  get serializable() {
    return o(this, ah);
  }
  get modifiedIds() {
    return ht(this, "modifiedIds", {
      ids: /* @__PURE__ */ new Set(),
      hash: ""
    });
  }
}
ah = new WeakMap();
var Xa;
class Wy {
  constructor({
    ownerDocument: e = globalThis.document,
    styleElement: t = null
  }) {
    y(this, Xa, /* @__PURE__ */ new Set());
    this._document = e, this.nativeFontFaces = /* @__PURE__ */ new Set(), this.styleElement = null, this.loadingRequests = [], this.loadTestFontId = 0;
  }
  addNativeFontFace(e) {
    this.nativeFontFaces.add(e), this._document.fonts.add(e);
  }
  removeNativeFontFace(e) {
    this.nativeFontFaces.delete(e), this._document.fonts.delete(e);
  }
  insertRule(e) {
    this.styleElement || (this.styleElement = this._document.createElement("style"), this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement));
    const t = this.styleElement.sheet;
    t.insertRule(e, t.cssRules.length);
  }
  clear() {
    for (const e of this.nativeFontFaces)
      this._document.fonts.delete(e);
    this.nativeFontFaces.clear(), o(this, Xa).clear(), this.styleElement && (this.styleElement.remove(), this.styleElement = null);
  }
  async loadSystemFont({
    systemFontInfo: e,
    _inspectFont: t
  }) {
    if (!(!e || o(this, Xa).has(e.loadedName))) {
      if (Qt(!this.disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set."), this.isFontLoadingAPISupported) {
        const {
          loadedName: s,
          src: i,
          style: n
        } = e, r = new FontFace(s, i, n);
        this.addNativeFontFace(r);
        try {
          await r.load(), o(this, Xa).add(s), t == null || t(e);
        } catch {
          nt(`Cannot load system font: ${e.baseFontName}, installing it could help to improve PDF rendering.`), this.removeNativeFontFace(r);
        }
        return;
      }
      Ut("Not implemented: loadSystemFont without the Font Loading API.");
    }
  }
  async bind(e) {
    if (e.attached || e.missingFile && !e.systemFontInfo)
      return;
    if (e.attached = !0, e.systemFontInfo) {
      await this.loadSystemFont(e);
      return;
    }
    if (this.isFontLoadingAPISupported) {
      const s = e.createNativeFontFace();
      if (s) {
        this.addNativeFontFace(s);
        try {
          await s.loaded;
        } catch (i) {
          throw nt(`Failed to load font '${s.family}': '${i}'.`), e.disableFontFace = !0, i;
        }
      }
      return;
    }
    const t = e.createFontFaceRule();
    if (t) {
      if (this.insertRule(t), this.isSyncFontLoadingSupported)
        return;
      await new Promise((s) => {
        const i = this._queueLoadingCallback(s);
        this._prepareFontLoadEvent(e, i);
      });
    }
  }
  get isFontLoadingAPISupported() {
    var t;
    const e = !!((t = this._document) != null && t.fonts);
    return ht(this, "isFontLoadingAPISupported", e);
  }
  get isSyncFontLoadingSupported() {
    let e = !1;
    return (ye || typeof navigator < "u" && typeof (navigator == null ? void 0 : navigator.userAgent) == "string" && /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)) && (e = !0), ht(this, "isSyncFontLoadingSupported", e);
  }
  _queueLoadingCallback(e) {
    function t() {
      for (Qt(!i.done, "completeRequest() cannot be called twice."), i.done = !0; s.length > 0 && s[0].done; ) {
        const n = s.shift();
        setTimeout(n.callback, 0);
      }
    }
    const {
      loadingRequests: s
    } = this, i = {
      done: !1,
      complete: t,
      callback: e
    };
    return s.push(i), i;
  }
  get _loadTestFont() {
    const e = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
    return ht(this, "_loadTestFont", e);
  }
  _prepareFontLoadEvent(e, t) {
    function s(P, T) {
      return P.charCodeAt(T) << 24 | P.charCodeAt(T + 1) << 16 | P.charCodeAt(T + 2) << 8 | P.charCodeAt(T + 3) & 255;
    }
    function i(P, T, C, R) {
      const M = P.substring(0, T), S = P.substring(T + C);
      return M + R + S;
    }
    let n, r;
    const a = this._document.createElement("canvas");
    a.width = 1, a.height = 1;
    const h = a.getContext("2d");
    let c = 0;
    function d(P, T) {
      if (++c > 30) {
        nt("Load test font never loaded."), T();
        return;
      }
      if (h.font = "30px " + P, h.fillText(".", 0, 20), h.getImageData(0, 0, 1, 1).data[3] > 0) {
        T();
        return;
      }
      setTimeout(d.bind(null, P, T));
    }
    const u = `lt${Date.now()}${this.loadTestFontId++}`;
    let f = this._loadTestFont;
    f = i(f, 976, u.length, u);
    const g = 16, b = 1482184792;
    let E = s(f, g);
    for (n = 0, r = u.length - 3; n < r; n += 4)
      E = E - b + s(u, n) | 0;
    n < u.length && (E = E - b + s(u + "XXX", n) | 0), f = i(f, g, 4, Cy(E));
    const A = `url(data:font/opentype;base64,${btoa(f)});`, w = `@font-face {font-family:"${u}";src:${A}}`;
    this.insertRule(w);
    const x = this._document.createElement("div");
    x.style.visibility = "hidden", x.style.width = x.style.height = "10px", x.style.position = "absolute", x.style.top = x.style.left = "0px";
    for (const P of [e.loadedName, u]) {
      const T = this._document.createElement("span");
      T.textContent = "Hi", T.style.fontFamily = P, x.append(T);
    }
    this._document.body.append(x), d(u, () => {
      x.remove(), t.complete();
    });
  }
}
Xa = new WeakMap();
class Gy {
  constructor(e, {
    disableFontFace: t = !1,
    inspectFont: s = null
  }) {
    this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
    for (const i in e)
      this[i] = e[i];
    this.disableFontFace = t === !0, this._inspectFont = s;
  }
  createNativeFontFace() {
    var t;
    if (!this.data || this.disableFontFace)
      return null;
    let e;
    if (!this.cssFontInfo)
      e = new FontFace(this.loadedName, this.data, {});
    else {
      const s = {
        weight: this.cssFontInfo.fontWeight
      };
      this.cssFontInfo.italicAngle && (s.style = `oblique ${this.cssFontInfo.italicAngle}deg`), e = new FontFace(this.cssFontInfo.fontFamily, this.data, s);
    }
    return (t = this._inspectFont) == null || t.call(this, this), e;
  }
  createFontFaceRule() {
    var i;
    if (!this.data || this.disableFontFace)
      return null;
    const e = mm(this.data), t = `url(data:${this.mimetype};base64,${btoa(e)});`;
    let s;
    if (!this.cssFontInfo)
      s = `@font-face {font-family:"${this.loadedName}";src:${t}}`;
    else {
      let n = `font-weight: ${this.cssFontInfo.fontWeight};`;
      this.cssFontInfo.italicAngle && (n += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`), s = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${n}src:${t}}`;
    }
    return (i = this._inspectFont) == null || i.call(this, this, t), s;
  }
  getPathGenerator(e, t) {
    if (this.compiledGlyphs[t] !== void 0)
      return this.compiledGlyphs[t];
    let s;
    try {
      s = e.get(this.loadedName + "_path_" + t);
    } catch (n) {
      nt(`getPathGenerator - ignoring character: "${n}".`);
    }
    if (!Array.isArray(s) || s.length === 0)
      return this.compiledGlyphs[t] = function(n, r) {
      };
    const i = [];
    for (let n = 0, r = s.length; n < r; )
      switch (s[n++]) {
        case si.BEZIER_CURVE_TO:
          {
            const [a, h, c, d, u, f] = s.slice(n, n + 6);
            i.push((p) => p.bezierCurveTo(a, h, c, d, u, f)), n += 6;
          }
          break;
        case si.MOVE_TO:
          {
            const [a, h] = s.slice(n, n + 2);
            i.push((c) => c.moveTo(a, h)), n += 2;
          }
          break;
        case si.LINE_TO:
          {
            const [a, h] = s.slice(n, n + 2);
            i.push((c) => c.lineTo(a, h)), n += 2;
          }
          break;
        case si.QUADRATIC_CURVE_TO:
          {
            const [a, h, c, d] = s.slice(n, n + 4);
            i.push((u) => u.quadraticCurveTo(a, h, c, d)), n += 4;
          }
          break;
        case si.RESTORE:
          i.push((a) => a.restore());
          break;
        case si.SAVE:
          i.push((a) => a.save());
          break;
        case si.SCALE:
          Qt(i.length === 2, "Scale command is only valid at the third position.");
          break;
        case si.TRANSFORM:
          {
            const [a, h, c, d, u, f] = s.slice(n, n + 6);
            i.push((p) => p.transform(a, h, c, d, u, f)), n += 6;
          }
          break;
        case si.TRANSLATE:
          {
            const [a, h] = s.slice(n, n + 2);
            i.push((c) => c.translate(a, h)), n += 2;
          }
          break;
      }
    return this.compiledGlyphs[t] = function(r, a) {
      i[0](r), i[1](r), r.scale(a, -a);
      for (let h = 2, c = i.length; h < c; h++)
        i[h](r);
    };
  }
}
if (ye) {
  var pf = Promise.withResolvers(), Ll = null;
  (async () => {
    const e = await Promise.resolve().then(() => ol), t = await Promise.resolve().then(() => ol), s = await Promise.resolve().then(() => ol), i = await Promise.resolve().then(() => ol);
    let n, r;
    try {
      n = await Promise.resolve().then(() => ol);
    } catch {
    }
    try {
      r = await Promise.resolve().then(() => K0);
    } catch {
    }
    return new Map(Object.entries({
      fs: e,
      http: t,
      https: s,
      url: i,
      canvas: n,
      path2d: r
    }));
  })().then((e) => {
    var t, s, i, n;
    if (Ll = e, pf.resolve(), !globalThis.DOMMatrix) {
      const r = (t = e.get("canvas")) == null ? void 0 : t.DOMMatrix;
      r ? globalThis.DOMMatrix = r : nt("Cannot polyfill `DOMMatrix`, rendering may be broken.");
    }
    if (!globalThis.Path2D) {
      const r = (s = e.get("canvas")) == null ? void 0 : s.CanvasRenderingContext2D, a = (i = e.get("path2d")) == null ? void 0 : i.applyPath2DToCanvasRenderingContext, h = (n = e.get("path2d")) == null ? void 0 : n.Path2D;
      r && a && h ? (a(r), globalThis.Path2D = h) : nt("Cannot polyfill `Path2D`, rendering may be broken.");
    }
  }, (e) => {
    nt(`loadPackages: ${e}`), Ll = /* @__PURE__ */ new Map(), pf.resolve();
  });
}
class $n {
  static get promise() {
    return pf.promise;
  }
  static get(e) {
    return Ll == null ? void 0 : Ll.get(e);
  }
}
const Jm = function(l) {
  return $n.get("fs").promises.readFile(l).then((t) => new Uint8Array(t));
};
class Xy extends vm {
}
class Ky extends bm {
  _createCanvas(e, t) {
    return $n.get("canvas").createCanvas(e, t);
  }
}
class Yy extends ym {
  _fetchData(e, t) {
    return Jm(e).then((s) => ({
      cMapData: s,
      compressionType: t
    }));
  }
}
class Qy extends Am {
  _fetchData(e) {
    return Jm(e);
  }
}
const xe = {
  FILL: "Fill",
  STROKE: "Stroke",
  SHADING: "Shading"
};
function gf(l, e) {
  if (!e)
    return;
  const t = e[2] - e[0], s = e[3] - e[1], i = new Path2D();
  i.rect(e[0], e[1], t, s), l.clip(i);
}
class Gp {
  getPattern() {
    Ut("Abstract method `getPattern` called.");
  }
}
class Zy extends Gp {
  constructor(e) {
    super(), this._type = e[1], this._bbox = e[2], this._colorStops = e[3], this._p0 = e[4], this._p1 = e[5], this._r0 = e[6], this._r1 = e[7], this.matrix = null;
  }
  _createGradient(e) {
    let t;
    this._type === "axial" ? t = e.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]) : this._type === "radial" && (t = e.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1));
    for (const s of this._colorStops)
      t.addColorStop(s[0], s[1]);
    return t;
  }
  getPattern(e, t, s, i) {
    let n;
    if (i === xe.STROKE || i === xe.FILL) {
      const r = t.current.getClippedPathBoundingBox(i, It(e)) || [0, 0, 0, 0], a = Math.ceil(r[2] - r[0]) || 1, h = Math.ceil(r[3] - r[1]) || 1, c = t.cachedCanvases.getCanvas("pattern", a, h), d = c.context;
      d.clearRect(0, 0, d.canvas.width, d.canvas.height), d.beginPath(), d.rect(0, 0, d.canvas.width, d.canvas.height), d.translate(-r[0], -r[1]), s = X.transform(s, [1, 0, 0, 1, r[0], r[1]]), d.transform(...t.baseTransform), this.matrix && d.transform(...this.matrix), gf(d, this._bbox), d.fillStyle = this._createGradient(d), d.fill(), n = e.createPattern(c.canvas, "no-repeat");
      const u = new DOMMatrix(s);
      n.setTransform(u);
    } else
      gf(e, this._bbox), n = this._createGradient(e);
    return n;
  }
}
function Pu(l, e, t, s, i, n, r, a) {
  const h = e.coords, c = e.colors, d = l.data, u = l.width * 4;
  let f;
  h[t + 1] > h[s + 1] && (f = t, t = s, s = f, f = n, n = r, r = f), h[s + 1] > h[i + 1] && (f = s, s = i, i = f, f = r, r = a, a = f), h[t + 1] > h[s + 1] && (f = t, t = s, s = f, f = n, n = r, r = f);
  const p = (h[t] + e.offsetX) * e.scaleX, g = (h[t + 1] + e.offsetY) * e.scaleY, b = (h[s] + e.offsetX) * e.scaleX, E = (h[s + 1] + e.offsetY) * e.scaleY, A = (h[i] + e.offsetX) * e.scaleX, w = (h[i + 1] + e.offsetY) * e.scaleY;
  if (g >= w)
    return;
  const x = c[n], P = c[n + 1], T = c[n + 2], C = c[r], R = c[r + 1], M = c[r + 2], S = c[a], I = c[a + 1], _ = c[a + 2], D = Math.round(g), k = Math.round(w);
  let j, H, L, F, z, pt, gt, zt;
  for (let bt = D; bt <= k; bt++) {
    if (bt < E) {
      const N = bt < g ? 0 : (g - bt) / (g - E);
      j = p - (p - b) * N, H = x - (x - C) * N, L = P - (P - R) * N, F = T - (T - M) * N;
    } else {
      let N;
      bt > w ? N = 1 : E === w ? N = 0 : N = (E - bt) / (E - w), j = b - (b - A) * N, H = C - (C - S) * N, L = R - (R - I) * N, F = M - (M - _) * N;
    }
    let Et;
    bt < g ? Et = 0 : bt > w ? Et = 1 : Et = (g - bt) / (g - w), z = p - (p - A) * Et, pt = x - (x - S) * Et, gt = P - (P - I) * Et, zt = T - (T - _) * Et;
    const xs = Math.round(Math.min(j, z)), Pe = Math.round(Math.max(j, z));
    let U = u * bt + xs * 4;
    for (let N = xs; N <= Pe; N++)
      Et = (j - N) / (j - z), Et < 0 ? Et = 0 : Et > 1 && (Et = 1), d[U++] = H - (H - pt) * Et | 0, d[U++] = L - (L - gt) * Et | 0, d[U++] = F - (F - zt) * Et | 0, d[U++] = 255;
  }
}
function Jy(l, e, t) {
  const s = e.coords, i = e.colors;
  let n, r;
  switch (e.type) {
    case "lattice":
      const a = e.verticesPerRow, h = Math.floor(s.length / a) - 1, c = a - 1;
      for (n = 0; n < h; n++) {
        let d = n * a;
        for (let u = 0; u < c; u++, d++)
          Pu(l, t, s[d], s[d + 1], s[d + a], i[d], i[d + 1], i[d + a]), Pu(l, t, s[d + a + 1], s[d + 1], s[d + a], i[d + a + 1], i[d + 1], i[d + a]);
      }
      break;
    case "triangles":
      for (n = 0, r = s.length; n < r; n += 3)
        Pu(l, t, s[n], s[n + 1], s[n + 2], i[n], i[n + 1], i[n + 2]);
      break;
    default:
      throw new Error("illegal figure");
  }
}
class qy extends Gp {
  constructor(e) {
    super(), this._coords = e[2], this._colors = e[3], this._figures = e[4], this._bounds = e[5], this._bbox = e[7], this._background = e[8], this.matrix = null;
  }
  _createMeshCanvas(e, t, s) {
    const a = Math.floor(this._bounds[0]), h = Math.floor(this._bounds[1]), c = Math.ceil(this._bounds[2]) - a, d = Math.ceil(this._bounds[3]) - h, u = Math.min(Math.ceil(Math.abs(c * e[0] * 1.1)), 3e3), f = Math.min(Math.ceil(Math.abs(d * e[1] * 1.1)), 3e3), p = c / u, g = d / f, b = {
      coords: this._coords,
      colors: this._colors,
      offsetX: -a,
      offsetY: -h,
      scaleX: 1 / p,
      scaleY: 1 / g
    }, E = u + 2 * 2, A = f + 2 * 2, w = s.getCanvas("mesh", E, A), x = w.context, P = x.createImageData(u, f);
    if (t) {
      const C = P.data;
      for (let R = 0, M = C.length; R < M; R += 4)
        C[R] = t[0], C[R + 1] = t[1], C[R + 2] = t[2], C[R + 3] = 255;
    }
    for (const C of this._figures)
      Jy(P, C, b);
    return x.putImageData(P, 2, 2), {
      canvas: w.canvas,
      offsetX: a - 2 * p,
      offsetY: h - 2 * g,
      scaleX: p,
      scaleY: g
    };
  }
  getPattern(e, t, s, i) {
    gf(e, this._bbox);
    let n;
    if (i === xe.SHADING)
      n = X.singularValueDecompose2dScale(It(e));
    else if (n = X.singularValueDecompose2dScale(t.baseTransform), this.matrix) {
      const a = X.singularValueDecompose2dScale(this.matrix);
      n = [n[0] * a[0], n[1] * a[1]];
    }
    const r = this._createMeshCanvas(n, i === xe.SHADING ? null : this._background, t.cachedCanvases);
    return i !== xe.SHADING && (e.setTransform(...t.baseTransform), this.matrix && e.transform(...this.matrix)), e.translate(r.offsetX, r.offsetY), e.scale(r.scaleX, r.scaleY), e.createPattern(r.canvas, "no-repeat");
  }
}
class tA extends Gp {
  getPattern() {
    return "hotpink";
  }
}
function eA(l) {
  switch (l[0]) {
    case "RadialAxial":
      return new Zy(l);
    case "Mesh":
      return new qy(l);
    case "Dummy":
      return new tA();
  }
  throw new Error(`Unknown IR type: ${l[0]}`);
}
const ug = {
  COLORED: 1,
  UNCOLORED: 2
}, qd = class qd {
  constructor(e, t, s, i, n) {
    this.operatorList = e[2], this.matrix = e[3], this.bbox = e[4], this.xstep = e[5], this.ystep = e[6], this.paintType = e[7], this.tilingType = e[8], this.color = t, this.ctx = s, this.canvasGraphicsFactory = i, this.baseTransform = n;
  }
  createPatternCanvas(e) {
    const {
      bbox: t,
      operatorList: s,
      paintType: i,
      tilingType: n,
      color: r,
      canvasGraphicsFactory: a
    } = this;
    let {
      xstep: h,
      ystep: c
    } = this;
    h = Math.abs(h), c = Math.abs(c), fu("TilingType: " + n);
    const d = t[0], u = t[1], f = t[2], p = t[3], g = f - d, b = p - u, E = X.singularValueDecompose2dScale(this.matrix), A = X.singularValueDecompose2dScale(this.baseTransform), w = E[0] * A[0], x = E[1] * A[1];
    let P = g, T = b, C = !1, R = !1;
    const M = Math.ceil(h * w), S = Math.ceil(c * x), I = Math.ceil(g * w), _ = Math.ceil(b * x);
    M >= I ? P = h : C = !0, S >= _ ? T = c : R = !0;
    const D = this.getSizeAndScale(P, this.ctx.canvas.width, w), k = this.getSizeAndScale(T, this.ctx.canvas.height, x), j = e.cachedCanvases.getCanvas("pattern", D.size, k.size), H = j.context, L = a.createCanvasGraphics(H);
    if (L.groupLevel = e.groupLevel, this.setFillAndStrokeStyleToContext(L, i, r), H.translate(-D.scale * d, -k.scale * u), L.transform(D.scale, 0, 0, k.scale, 0, 0), H.save(), this.clipBbox(L, d, u, f, p), L.baseTransform = It(L.ctx), L.executeOperatorList(s), L.endDrawing(), H.restore(), C || R) {
      const F = j.canvas;
      C && (P = h), R && (T = c);
      const z = this.getSizeAndScale(P, this.ctx.canvas.width, w), pt = this.getSizeAndScale(T, this.ctx.canvas.height, x), gt = z.size, zt = pt.size, bt = e.cachedCanvases.getCanvas("pattern-workaround", gt, zt), Et = bt.context, xs = C ? Math.floor(g / h) : 0, Pe = R ? Math.floor(b / c) : 0;
      for (let U = 0; U <= xs; U++)
        for (let N = 0; N <= Pe; N++)
          Et.drawImage(F, gt * U, zt * N, gt, zt, 0, 0, gt, zt);
      return {
        canvas: bt.canvas,
        scaleX: z.scale,
        scaleY: pt.scale,
        offsetX: d,
        offsetY: u
      };
    }
    return {
      canvas: j.canvas,
      scaleX: D.scale,
      scaleY: k.scale,
      offsetX: d,
      offsetY: u
    };
  }
  getSizeAndScale(e, t, s) {
    const i = Math.max(qd.MAX_PATTERN_SIZE, t);
    let n = Math.ceil(e * s);
    return n >= i ? n = i : s = n / e, {
      scale: s,
      size: n
    };
  }
  clipBbox(e, t, s, i, n) {
    const r = i - t, a = n - s;
    e.ctx.rect(t, s, r, a), e.current.updateRectMinMax(It(e.ctx), [t, s, i, n]), e.clip(), e.endPath();
  }
  setFillAndStrokeStyleToContext(e, t, s) {
    const i = e.ctx, n = e.current;
    switch (t) {
      case ug.COLORED:
        const r = this.ctx;
        i.fillStyle = r.fillStyle, i.strokeStyle = r.strokeStyle, n.fillColor = r.fillStyle, n.strokeColor = r.strokeStyle;
        break;
      case ug.UNCOLORED:
        const a = X.makeHexColor(s[0], s[1], s[2]);
        i.fillStyle = a, i.strokeStyle = a, n.fillColor = a, n.strokeColor = a;
        break;
      default:
        throw new Py(`Unsupported paint type: ${t}`);
    }
  }
  getPattern(e, t, s, i) {
    let n = s;
    i !== xe.SHADING && (n = X.transform(n, t.baseTransform), this.matrix && (n = X.transform(n, this.matrix)));
    const r = this.createPatternCanvas(t);
    let a = new DOMMatrix(n);
    a = a.translate(r.offsetX, r.offsetY), a = a.scale(1 / r.scaleX, 1 / r.scaleY);
    const h = e.createPattern(r.canvas, "repeat");
    return h.setTransform(a), h;
  }
};
Z(qd, "MAX_PATTERN_SIZE", 3e3);
let mf = qd;
function sA({
  src: l,
  srcPos: e = 0,
  dest: t,
  width: s,
  height: i,
  nonBlackColor: n = 4294967295,
  inverseDecode: r = !1
}) {
  const a = ke.isLittleEndian ? 4278190080 : 255, [h, c] = r ? [n, a] : [a, n], d = s >> 3, u = s & 7, f = l.length;
  t = new Uint32Array(t.buffer);
  let p = 0;
  for (let g = 0; g < i; g++) {
    for (const E = e + d; e < E; e++) {
      const A = e < f ? l[e] : 255;
      t[p++] = A & 128 ? c : h, t[p++] = A & 64 ? c : h, t[p++] = A & 32 ? c : h, t[p++] = A & 16 ? c : h, t[p++] = A & 8 ? c : h, t[p++] = A & 4 ? c : h, t[p++] = A & 2 ? c : h, t[p++] = A & 1 ? c : h;
    }
    if (u === 0)
      continue;
    const b = e < f ? l[e++] : 255;
    for (let E = 0; E < u; E++)
      t[p++] = b & 1 << 7 - E ? c : h;
  }
  return {
    srcPos: e,
    destPos: p
  };
}
const fg = 16, pg = 100, iA = 15, gg = 10, mg = 1e3, Oe = 16;
function nA(l, e) {
  if (l._removeMirroring)
    throw new Error("Context is already forwarding operations.");
  l.__originalSave = l.save, l.__originalRestore = l.restore, l.__originalRotate = l.rotate, l.__originalScale = l.scale, l.__originalTranslate = l.translate, l.__originalTransform = l.transform, l.__originalSetTransform = l.setTransform, l.__originalResetTransform = l.resetTransform, l.__originalClip = l.clip, l.__originalMoveTo = l.moveTo, l.__originalLineTo = l.lineTo, l.__originalBezierCurveTo = l.bezierCurveTo, l.__originalRect = l.rect, l.__originalClosePath = l.closePath, l.__originalBeginPath = l.beginPath, l._removeMirroring = () => {
    l.save = l.__originalSave, l.restore = l.__originalRestore, l.rotate = l.__originalRotate, l.scale = l.__originalScale, l.translate = l.__originalTranslate, l.transform = l.__originalTransform, l.setTransform = l.__originalSetTransform, l.resetTransform = l.__originalResetTransform, l.clip = l.__originalClip, l.moveTo = l.__originalMoveTo, l.lineTo = l.__originalLineTo, l.bezierCurveTo = l.__originalBezierCurveTo, l.rect = l.__originalRect, l.closePath = l.__originalClosePath, l.beginPath = l.__originalBeginPath, delete l._removeMirroring;
  }, l.save = function() {
    e.save(), this.__originalSave();
  }, l.restore = function() {
    e.restore(), this.__originalRestore();
  }, l.translate = function(s, i) {
    e.translate(s, i), this.__originalTranslate(s, i);
  }, l.scale = function(s, i) {
    e.scale(s, i), this.__originalScale(s, i);
  }, l.transform = function(s, i, n, r, a, h) {
    e.transform(s, i, n, r, a, h), this.__originalTransform(s, i, n, r, a, h);
  }, l.setTransform = function(s, i, n, r, a, h) {
    e.setTransform(s, i, n, r, a, h), this.__originalSetTransform(s, i, n, r, a, h);
  }, l.resetTransform = function() {
    e.resetTransform(), this.__originalResetTransform();
  }, l.rotate = function(s) {
    e.rotate(s), this.__originalRotate(s);
  }, l.clip = function(s) {
    e.clip(s), this.__originalClip(s);
  }, l.moveTo = function(t, s) {
    e.moveTo(t, s), this.__originalMoveTo(t, s);
  }, l.lineTo = function(t, s) {
    e.lineTo(t, s), this.__originalLineTo(t, s);
  }, l.bezierCurveTo = function(t, s, i, n, r, a) {
    e.bezierCurveTo(t, s, i, n, r, a), this.__originalBezierCurveTo(t, s, i, n, r, a);
  }, l.rect = function(t, s, i, n) {
    e.rect(t, s, i, n), this.__originalRect(t, s, i, n);
  }, l.closePath = function() {
    e.closePath(), this.__originalClosePath();
  }, l.beginPath = function() {
    e.beginPath(), this.__originalBeginPath();
  };
}
class rA {
  constructor(e) {
    this.canvasFactory = e, this.cache = /* @__PURE__ */ Object.create(null);
  }
  getCanvas(e, t, s) {
    let i;
    return this.cache[e] !== void 0 ? (i = this.cache[e], this.canvasFactory.reset(i, t, s)) : (i = this.canvasFactory.create(t, s), this.cache[e] = i), i;
  }
  delete(e) {
    delete this.cache[e];
  }
  clear() {
    for (const e in this.cache) {
      const t = this.cache[e];
      this.canvasFactory.destroy(t), delete this.cache[e];
    }
  }
}
function kc(l, e, t, s, i, n, r, a, h, c) {
  const [d, u, f, p, g, b] = It(l);
  if (u === 0 && f === 0) {
    const w = r * d + g, x = Math.round(w), P = a * p + b, T = Math.round(P), C = (r + h) * d + g, R = Math.abs(Math.round(C) - x) || 1, M = (a + c) * p + b, S = Math.abs(Math.round(M) - T) || 1;
    return l.setTransform(Math.sign(d), 0, 0, Math.sign(p), x, T), l.drawImage(e, t, s, i, n, 0, 0, R, S), l.setTransform(d, u, f, p, g, b), [R, S];
  }
  if (d === 0 && p === 0) {
    const w = a * f + g, x = Math.round(w), P = r * u + b, T = Math.round(P), C = (a + c) * f + g, R = Math.abs(Math.round(C) - x) || 1, M = (r + h) * u + b, S = Math.abs(Math.round(M) - T) || 1;
    return l.setTransform(0, Math.sign(u), Math.sign(f), 0, x, T), l.drawImage(e, t, s, i, n, 0, 0, S, R), l.setTransform(d, u, f, p, g, b), [S, R];
  }
  l.drawImage(e, t, s, i, n, r, a, h, c);
  const E = Math.hypot(d, u), A = Math.hypot(f, p);
  return [E * h, A * c];
}
function aA(l) {
  const {
    width: e,
    height: t
  } = l;
  if (e > mg || t > mg)
    return null;
  const s = 1e3, i = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]), n = e + 1;
  let r = new Uint8Array(n * (t + 1)), a, h, c;
  const d = e + 7 & -8;
  let u = new Uint8Array(d * t), f = 0;
  for (const A of l.data) {
    let w = 128;
    for (; w > 0; )
      u[f++] = A & w ? 0 : 255, w >>= 1;
  }
  let p = 0;
  for (f = 0, u[f] !== 0 && (r[0] = 1, ++p), h = 1; h < e; h++)
    u[f] !== u[f + 1] && (r[h] = u[f] ? 2 : 1, ++p), f++;
  for (u[f] !== 0 && (r[h] = 2, ++p), a = 1; a < t; a++) {
    f = a * d, c = a * n, u[f - d] !== u[f] && (r[c] = u[f] ? 1 : 8, ++p);
    let A = (u[f] ? 4 : 0) + (u[f - d] ? 8 : 0);
    for (h = 1; h < e; h++)
      A = (A >> 2) + (u[f + 1] ? 4 : 0) + (u[f - d + 1] ? 8 : 0), i[A] && (r[c + h] = i[A], ++p), f++;
    if (u[f - d] !== u[f] && (r[c + h] = u[f] ? 2 : 4, ++p), p > s)
      return null;
  }
  for (f = d * (t - 1), c = a * n, u[f] !== 0 && (r[c] = 8, ++p), h = 1; h < e; h++)
    u[f] !== u[f + 1] && (r[c + h] = u[f] ? 4 : 8, ++p), f++;
  if (u[f] !== 0 && (r[c + h] = 4, ++p), p > s)
    return null;
  const g = new Int32Array([0, n, -1, 0, -n, 0, 0, 0, 1]), b = new Path2D();
  for (a = 0; p && a <= t; a++) {
    let A = a * n;
    const w = A + e;
    for (; A < w && !r[A]; )
      A++;
    if (A === w)
      continue;
    b.moveTo(A % n, a);
    const x = A;
    let P = r[A];
    do {
      const T = g[P];
      do
        A += T;
      while (!r[A]);
      const C = r[A];
      C !== 5 && C !== 10 ? (P = C, r[A] = 0) : (P = C & 51 * P >> 4, r[A] &= P >> 2 | P << 2), b.lineTo(A % n, A / n | 0), r[A] || --p;
    } while (x !== A);
    --a;
  }
  return u = null, r = null, function(A) {
    A.save(), A.scale(1 / e, -1 / t), A.translate(0, -t), A.fill(b), A.beginPath(), A.restore();
  };
}
class vg {
  constructor(e, t) {
    this.alphaIsShape = !1, this.fontSize = 0, this.fontSizeScale = 1, this.textMatrix = pm, this.textMatrixScale = 1, this.fontMatrix = Hu, this.leading = 0, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRenderingMode = ue.FILL, this.textRise = 0, this.fillColor = "#000000", this.strokeColor = "#000000", this.patternFill = !1, this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.activeSMask = null, this.transferMaps = "none", this.startNewPathAndClipBox([0, 0, e, t]);
  }
  clone() {
    const e = Object.create(this);
    return e.clipBox = this.clipBox.slice(), e;
  }
  setCurrentPoint(e, t) {
    this.x = e, this.y = t;
  }
  updatePathMinMax(e, t, s) {
    [t, s] = X.applyTransform([t, s], e), this.minX = Math.min(this.minX, t), this.minY = Math.min(this.minY, s), this.maxX = Math.max(this.maxX, t), this.maxY = Math.max(this.maxY, s);
  }
  updateRectMinMax(e, t) {
    const s = X.applyTransform(t, e), i = X.applyTransform(t.slice(2), e), n = X.applyTransform([t[0], t[3]], e), r = X.applyTransform([t[2], t[1]], e);
    this.minX = Math.min(this.minX, s[0], i[0], n[0], r[0]), this.minY = Math.min(this.minY, s[1], i[1], n[1], r[1]), this.maxX = Math.max(this.maxX, s[0], i[0], n[0], r[0]), this.maxY = Math.max(this.maxY, s[1], i[1], n[1], r[1]);
  }
  updateScalingPathMinMax(e, t) {
    X.scaleMinMax(e, t), this.minX = Math.min(this.minX, t[0]), this.minY = Math.min(this.minY, t[1]), this.maxX = Math.max(this.maxX, t[2]), this.maxY = Math.max(this.maxY, t[3]);
  }
  updateCurvePathMinMax(e, t, s, i, n, r, a, h, c, d) {
    const u = X.bezierBoundingBox(t, s, i, n, r, a, h, c, d);
    d || this.updateRectMinMax(e, u);
  }
  getPathBoundingBox(e = xe.FILL, t = null) {
    const s = [this.minX, this.minY, this.maxX, this.maxY];
    if (e === xe.STROKE) {
      t || Ut("Stroke bounding box must include transform.");
      const i = X.singularValueDecompose2dScale(t), n = i[0] * this.lineWidth / 2, r = i[1] * this.lineWidth / 2;
      s[0] -= n, s[1] -= r, s[2] += n, s[3] += r;
    }
    return s;
  }
  updateClipFromPath() {
    const e = X.intersect(this.clipBox, this.getPathBoundingBox());
    this.startNewPathAndClipBox(e || [0, 0, 0, 0]);
  }
  isEmptyClip() {
    return this.minX === 1 / 0;
  }
  startNewPathAndClipBox(e) {
    this.clipBox = e, this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = 0, this.maxY = 0;
  }
  getClippedPathBoundingBox(e = xe.FILL, t = null) {
    return X.intersect(this.clipBox, this.getPathBoundingBox(e, t));
  }
}
function bg(l, e) {
  if (typeof ImageData < "u" && e instanceof ImageData) {
    l.putImageData(e, 0, 0);
    return;
  }
  const t = e.height, s = e.width, i = t % Oe, n = (t - i) / Oe, r = i === 0 ? n : n + 1, a = l.createImageData(s, Oe);
  let h = 0, c;
  const d = e.data, u = a.data;
  let f, p, g, b;
  if (e.kind === Kc.GRAYSCALE_1BPP) {
    const E = d.byteLength, A = new Uint32Array(u.buffer, 0, u.byteLength >> 2), w = A.length, x = s + 7 >> 3, P = 4294967295, T = ke.isLittleEndian ? 4278190080 : 255;
    for (f = 0; f < r; f++) {
      for (g = f < n ? Oe : i, c = 0, p = 0; p < g; p++) {
        const C = E - h;
        let R = 0;
        const M = C > x ? s : C * 8 - 7, S = M & -8;
        let I = 0, _ = 0;
        for (; R < S; R += 8)
          _ = d[h++], A[c++] = _ & 128 ? P : T, A[c++] = _ & 64 ? P : T, A[c++] = _ & 32 ? P : T, A[c++] = _ & 16 ? P : T, A[c++] = _ & 8 ? P : T, A[c++] = _ & 4 ? P : T, A[c++] = _ & 2 ? P : T, A[c++] = _ & 1 ? P : T;
        for (; R < M; R++)
          I === 0 && (_ = d[h++], I = 128), A[c++] = _ & I ? P : T, I >>= 1;
      }
      for (; c < w; )
        A[c++] = 0;
      l.putImageData(a, 0, f * Oe);
    }
  } else if (e.kind === Kc.RGBA_32BPP) {
    for (p = 0, b = s * Oe * 4, f = 0; f < n; f++)
      u.set(d.subarray(h, h + b)), h += b, l.putImageData(a, 0, p), p += Oe;
    f < r && (b = s * i * 4, u.set(d.subarray(h, h + b)), l.putImageData(a, 0, p));
  } else if (e.kind === Kc.RGB_24BPP)
    for (g = Oe, b = s * g, f = 0; f < r; f++) {
      for (f >= n && (g = i, b = s * g), c = 0, p = b; p--; )
        u[c++] = d[h++], u[c++] = d[h++], u[c++] = d[h++], u[c++] = 255;
      l.putImageData(a, 0, f * Oe);
    }
  else
    throw new Error(`bad image kind: ${e.kind}`);
}
function yg(l, e) {
  if (e.bitmap) {
    l.drawImage(e.bitmap, 0, 0);
    return;
  }
  const t = e.height, s = e.width, i = t % Oe, n = (t - i) / Oe, r = i === 0 ? n : n + 1, a = l.createImageData(s, Oe);
  let h = 0;
  const c = e.data, d = a.data;
  for (let u = 0; u < r; u++) {
    const f = u < n ? Oe : i;
    ({
      srcPos: h
    } = sA({
      src: c,
      srcPos: h,
      dest: d,
      width: s,
      height: f,
      nonBlackColor: 0
    })), l.putImageData(a, 0, u * Oe);
  }
}
function nl(l, e) {
  const t = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
  for (const s of t)
    l[s] !== void 0 && (e[s] = l[s]);
  l.setLineDash !== void 0 && (e.setLineDash(l.getLineDash()), e.lineDashOffset = l.lineDashOffset);
}
function Fc(l) {
  if (l.strokeStyle = l.fillStyle = "#000000", l.fillRule = "nonzero", l.globalAlpha = 1, l.lineWidth = 1, l.lineCap = "butt", l.lineJoin = "miter", l.miterLimit = 10, l.globalCompositeOperation = "source-over", l.font = "10px sans-serif", l.setLineDash !== void 0 && (l.setLineDash([]), l.lineDashOffset = 0), !ye) {
    const {
      filter: e
    } = l;
    e !== "none" && e !== "" && (l.filter = "none");
  }
}
function Ag(l, e) {
  if (e)
    return !0;
  const t = X.singularValueDecompose2dScale(l);
  t[0] = Math.fround(t[0]), t[1] = Math.fround(t[1]);
  const s = Math.fround((globalThis.devicePixelRatio || 1) * Qo.PDF_TO_CSS_UNITS);
  return t[0] <= s && t[1] <= s;
}
const oA = ["butt", "round", "square"], lA = ["miter", "round", "bevel"], hA = {}, Eg = {};
var Un, vf, bf;
const tg = class tg {
  constructor(e, t, s, i, n, {
    optionalContentConfig: r,
    markedContentStack: a = null
  }, h, c) {
    y(this, Un);
    this.ctx = e, this.current = new vg(this.ctx.canvas.width, this.ctx.canvas.height), this.stateStack = [], this.pendingClip = null, this.pendingEOFill = !1, this.res = null, this.xobjs = null, this.commonObjs = t, this.objs = s, this.canvasFactory = i, this.filterFactory = n, this.groupStack = [], this.processingType3 = null, this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, this.suspendedCtx = null, this.contentVisible = !0, this.markedContentStack = a || [], this.optionalContentConfig = r, this.cachedCanvases = new rA(this.canvasFactory), this.cachedPatterns = /* @__PURE__ */ new Map(), this.annotationCanvasMap = h, this.viewportScale = 1, this.outputScaleX = 1, this.outputScaleY = 1, this.pageColors = c, this._cachedScaleForStroking = [-1, 0], this._cachedGetSinglePixelWidth = null, this._cachedBitmapsMap = /* @__PURE__ */ new Map();
  }
  getObject(e, t = null) {
    return typeof e == "string" ? e.startsWith("g_") ? this.commonObjs.get(e) : this.objs.get(e) : t;
  }
  beginDrawing({
    transform: e,
    viewport: t,
    transparency: s = !1,
    background: i = null
  }) {
    const n = this.ctx.canvas.width, r = this.ctx.canvas.height, a = this.ctx.fillStyle;
    if (this.ctx.fillStyle = i || "#ffffff", this.ctx.fillRect(0, 0, n, r), this.ctx.fillStyle = a, s) {
      const h = this.cachedCanvases.getCanvas("transparent", n, r);
      this.compositeCtx = this.ctx, this.transparentCanvas = h.canvas, this.ctx = h.context, this.ctx.save(), this.ctx.transform(...It(this.compositeCtx));
    }
    this.ctx.save(), Fc(this.ctx), e && (this.ctx.transform(...e), this.outputScaleX = e[0], this.outputScaleY = e[0]), this.ctx.transform(...t.transform), this.viewportScale = t.scale, this.baseTransform = It(this.ctx);
  }
  executeOperatorList(e, t, s, i) {
    const n = e.argsArray, r = e.fnArray;
    let a = t || 0;
    const h = n.length;
    if (h === a)
      return a;
    const c = h - a > gg && typeof s == "function", d = c ? Date.now() + iA : 0;
    let u = 0;
    const f = this.commonObjs, p = this.objs;
    let g;
    for (; ; ) {
      if (i !== void 0 && a === i.nextBreakPoint)
        return i.breakIt(a, s), a;
      if (g = r[a], g !== hs.dependency)
        this[g].apply(this, n[a]);
      else
        for (const b of n[a]) {
          const E = b.startsWith("g_") ? f : p;
          if (!E.has(b))
            return E.get(b, s), a;
        }
      if (a++, a === h)
        return a;
      if (c && ++u > gg) {
        if (Date.now() > d)
          return s(), a;
        u = 0;
      }
    }
  }
  endDrawing() {
    m(this, Un, vf).call(this), this.cachedCanvases.clear(), this.cachedPatterns.clear();
    for (const e of this._cachedBitmapsMap.values()) {
      for (const t of e.values())
        typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement && (t.width = t.height = 0);
      e.clear();
    }
    this._cachedBitmapsMap.clear(), m(this, Un, bf).call(this);
  }
  _scaleImage(e, t) {
    const s = e.width, i = e.height;
    let n = Math.max(Math.hypot(t[0], t[1]), 1), r = Math.max(Math.hypot(t[2], t[3]), 1), a = s, h = i, c = "prescale1", d, u;
    for (; n > 2 && a > 1 || r > 2 && h > 1; ) {
      let f = a, p = h;
      n > 2 && a > 1 && (f = a >= 16384 ? Math.floor(a / 2) - 1 || 1 : Math.ceil(a / 2), n /= a / f), r > 2 && h > 1 && (p = h >= 16384 ? Math.floor(h / 2) - 1 || 1 : Math.ceil(h) / 2, r /= h / p), d = this.cachedCanvases.getCanvas(c, f, p), u = d.context, u.clearRect(0, 0, f, p), u.drawImage(e, 0, 0, a, h, 0, 0, f, p), e = d.canvas, a = f, h = p, c = c === "prescale1" ? "prescale2" : "prescale1";
    }
    return {
      img: e,
      paintWidth: a,
      paintHeight: h
    };
  }
  _createMaskCanvas(e) {
    const t = this.ctx, {
      width: s,
      height: i
    } = e, n = this.current.fillColor, r = this.current.patternFill, a = It(t);
    let h, c, d, u;
    if ((e.bitmap || e.data) && e.count > 1) {
      const M = e.bitmap || e.data.buffer;
      c = JSON.stringify(r ? a : [a.slice(0, 4), n]), h = this._cachedBitmapsMap.get(M), h || (h = /* @__PURE__ */ new Map(), this._cachedBitmapsMap.set(M, h));
      const S = h.get(c);
      if (S && !r) {
        const I = Math.round(Math.min(a[0], a[2]) + a[4]), _ = Math.round(Math.min(a[1], a[3]) + a[5]);
        return {
          canvas: S,
          offsetX: I,
          offsetY: _
        };
      }
      d = S;
    }
    d || (u = this.cachedCanvases.getCanvas("maskCanvas", s, i), yg(u.context, e));
    let f = X.transform(a, [1 / s, 0, 0, -1 / i, 0, 0]);
    f = X.transform(f, [1, 0, 0, 1, 0, -i]);
    const [p, g, b, E] = X.getAxialAlignedBoundingBox([0, 0, s, i], f), A = Math.round(b - p) || 1, w = Math.round(E - g) || 1, x = this.cachedCanvases.getCanvas("fillCanvas", A, w), P = x.context, T = p, C = g;
    P.translate(-T, -C), P.transform(...f), d || (d = this._scaleImage(u.canvas, ii(P)), d = d.img, h && r && h.set(c, d)), P.imageSmoothingEnabled = Ag(It(P), e.interpolate), kc(P, d, 0, 0, d.width, d.height, 0, 0, s, i), P.globalCompositeOperation = "source-in";
    const R = X.transform(ii(P), [1, 0, 0, 1, -T, -C]);
    return P.fillStyle = r ? n.getPattern(t, this, R, xe.FILL) : n, P.fillRect(0, 0, s, i), h && !r && (this.cachedCanvases.delete("fillCanvas"), h.set(c, x.canvas)), {
      canvas: x.canvas,
      offsetX: Math.round(T),
      offsetY: Math.round(C)
    };
  }
  setLineWidth(e) {
    e !== this.current.lineWidth && (this._cachedScaleForStroking[0] = -1), this.current.lineWidth = e, this.ctx.lineWidth = e;
  }
  setLineCap(e) {
    this.ctx.lineCap = oA[e];
  }
  setLineJoin(e) {
    this.ctx.lineJoin = lA[e];
  }
  setMiterLimit(e) {
    this.ctx.miterLimit = e;
  }
  setDash(e, t) {
    const s = this.ctx;
    s.setLineDash !== void 0 && (s.setLineDash(e), s.lineDashOffset = t);
  }
  setRenderingIntent(e) {
  }
  setFlatness(e) {
  }
  setGState(e) {
    for (const [t, s] of e)
      switch (t) {
        case "LW":
          this.setLineWidth(s);
          break;
        case "LC":
          this.setLineCap(s);
          break;
        case "LJ":
          this.setLineJoin(s);
          break;
        case "ML":
          this.setMiterLimit(s);
          break;
        case "D":
          this.setDash(s[0], s[1]);
          break;
        case "RI":
          this.setRenderingIntent(s);
          break;
        case "FL":
          this.setFlatness(s);
          break;
        case "Font":
          this.setFont(s[0], s[1]);
          break;
        case "CA":
          this.current.strokeAlpha = s;
          break;
        case "ca":
          this.current.fillAlpha = s, this.ctx.globalAlpha = s;
          break;
        case "BM":
          this.ctx.globalCompositeOperation = s;
          break;
        case "SMask":
          this.current.activeSMask = s ? this.tempSMask : null, this.tempSMask = null, this.checkSMaskState();
          break;
        case "TR":
          this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(s);
          break;
      }
  }
  get inSMaskMode() {
    return !!this.suspendedCtx;
  }
  checkSMaskState() {
    const e = this.inSMaskMode;
    this.current.activeSMask && !e ? this.beginSMaskMode() : !this.current.activeSMask && e && this.endSMaskMode();
  }
  beginSMaskMode() {
    if (this.inSMaskMode)
      throw new Error("beginSMaskMode called while already in smask mode");
    const e = this.ctx.canvas.width, t = this.ctx.canvas.height, s = "smaskGroupAt" + this.groupLevel, i = this.cachedCanvases.getCanvas(s, e, t);
    this.suspendedCtx = this.ctx, this.ctx = i.context;
    const n = this.ctx;
    n.setTransform(...It(this.suspendedCtx)), nl(this.suspendedCtx, n), nA(n, this.suspendedCtx), this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
  }
  endSMaskMode() {
    if (!this.inSMaskMode)
      throw new Error("endSMaskMode called while not in smask mode");
    this.ctx._removeMirroring(), nl(this.ctx, this.suspendedCtx), this.ctx = this.suspendedCtx, this.suspendedCtx = null;
  }
  compose(e) {
    if (!this.current.activeSMask)
      return;
    e ? (e[0] = Math.floor(e[0]), e[1] = Math.floor(e[1]), e[2] = Math.ceil(e[2]), e[3] = Math.ceil(e[3])) : e = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
    const t = this.current.activeSMask, s = this.suspendedCtx;
    this.composeSMask(s, t, this.ctx, e), this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.ctx.restore();
  }
  composeSMask(e, t, s, i) {
    const n = i[0], r = i[1], a = i[2] - n, h = i[3] - r;
    a === 0 || h === 0 || (this.genericComposeSMask(t.context, s, a, h, t.subtype, t.backdrop, t.transferMap, n, r, t.offsetX, t.offsetY), e.save(), e.globalAlpha = 1, e.globalCompositeOperation = "source-over", e.setTransform(1, 0, 0, 1, 0, 0), e.drawImage(s.canvas, 0, 0), e.restore());
  }
  genericComposeSMask(e, t, s, i, n, r, a, h, c, d, u) {
    let f = e.canvas, p = h - d, g = c - u;
    if (r) {
      if (p < 0 || g < 0 || p + s > f.width || g + i > f.height) {
        const E = this.cachedCanvases.getCanvas("maskExtension", s, i), A = E.context;
        A.drawImage(f, -p, -g), r.some((w) => w !== 0) && (A.globalCompositeOperation = "destination-atop", A.fillStyle = X.makeHexColor(...r), A.fillRect(0, 0, s, i), A.globalCompositeOperation = "source-over"), f = E.canvas, p = g = 0;
      } else if (r.some((E) => E !== 0)) {
        e.save(), e.globalAlpha = 1, e.setTransform(1, 0, 0, 1, 0, 0);
        const E = new Path2D();
        E.rect(p, g, s, i), e.clip(E), e.globalCompositeOperation = "destination-atop", e.fillStyle = X.makeHexColor(...r), e.fillRect(p, g, s, i), e.restore();
      }
    }
    t.save(), t.globalAlpha = 1, t.setTransform(1, 0, 0, 1, 0, 0), n === "Alpha" && a ? t.filter = this.filterFactory.addAlphaFilter(a) : n === "Luminosity" && (t.filter = this.filterFactory.addLuminosityFilter(a));
    const b = new Path2D();
    b.rect(h, c, s, i), t.clip(b), t.globalCompositeOperation = "destination-in", t.drawImage(f, p, g, s, i, h, c, s, i), t.restore();
  }
  save() {
    this.inSMaskMode ? (nl(this.ctx, this.suspendedCtx), this.suspendedCtx.save()) : this.ctx.save();
    const e = this.current;
    this.stateStack.push(e), this.current = e.clone();
  }
  restore() {
    this.stateStack.length === 0 && this.inSMaskMode && this.endSMaskMode(), this.stateStack.length !== 0 && (this.current = this.stateStack.pop(), this.inSMaskMode ? (this.suspendedCtx.restore(), nl(this.suspendedCtx, this.ctx)) : this.ctx.restore(), this.checkSMaskState(), this.pendingClip = null, this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null);
  }
  transform(e, t, s, i, n, r) {
    this.ctx.transform(e, t, s, i, n, r), this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null;
  }
  constructPath(e, t, s) {
    const i = this.ctx, n = this.current;
    let r = n.x, a = n.y, h, c;
    const d = It(i), u = d[0] === 0 && d[3] === 0 || d[1] === 0 && d[2] === 0, f = u ? s.slice(0) : null;
    for (let p = 0, g = 0, b = e.length; p < b; p++)
      switch (e[p] | 0) {
        case hs.rectangle:
          r = t[g++], a = t[g++];
          const E = t[g++], A = t[g++], w = r + E, x = a + A;
          i.moveTo(r, a), E === 0 || A === 0 ? i.lineTo(w, x) : (i.lineTo(w, a), i.lineTo(w, x), i.lineTo(r, x)), u || n.updateRectMinMax(d, [r, a, w, x]), i.closePath();
          break;
        case hs.moveTo:
          r = t[g++], a = t[g++], i.moveTo(r, a), u || n.updatePathMinMax(d, r, a);
          break;
        case hs.lineTo:
          r = t[g++], a = t[g++], i.lineTo(r, a), u || n.updatePathMinMax(d, r, a);
          break;
        case hs.curveTo:
          h = r, c = a, r = t[g + 4], a = t[g + 5], i.bezierCurveTo(t[g], t[g + 1], t[g + 2], t[g + 3], r, a), n.updateCurvePathMinMax(d, h, c, t[g], t[g + 1], t[g + 2], t[g + 3], r, a, f), g += 6;
          break;
        case hs.curveTo2:
          h = r, c = a, i.bezierCurveTo(r, a, t[g], t[g + 1], t[g + 2], t[g + 3]), n.updateCurvePathMinMax(d, h, c, r, a, t[g], t[g + 1], t[g + 2], t[g + 3], f), r = t[g + 2], a = t[g + 3], g += 4;
          break;
        case hs.curveTo3:
          h = r, c = a, r = t[g + 2], a = t[g + 3], i.bezierCurveTo(t[g], t[g + 1], r, a, r, a), n.updateCurvePathMinMax(d, h, c, t[g], t[g + 1], r, a, r, a, f), g += 4;
          break;
        case hs.closePath:
          i.closePath();
          break;
      }
    u && n.updateScalingPathMinMax(d, f), n.setCurrentPoint(r, a);
  }
  closePath() {
    this.ctx.closePath();
  }
  stroke(e = !0) {
    const t = this.ctx, s = this.current.strokeColor;
    t.globalAlpha = this.current.strokeAlpha, this.contentVisible && (typeof s == "object" && (s != null && s.getPattern) ? (t.save(), t.strokeStyle = s.getPattern(t, this, ii(t), xe.STROKE), this.rescaleAndStroke(!1), t.restore()) : this.rescaleAndStroke(!0)), e && this.consumePath(this.current.getClippedPathBoundingBox()), t.globalAlpha = this.current.fillAlpha;
  }
  closeStroke() {
    this.closePath(), this.stroke();
  }
  fill(e = !0) {
    const t = this.ctx, s = this.current.fillColor, i = this.current.patternFill;
    let n = !1;
    i && (t.save(), t.fillStyle = s.getPattern(t, this, ii(t), xe.FILL), n = !0);
    const r = this.current.getClippedPathBoundingBox();
    this.contentVisible && r !== null && (this.pendingEOFill ? (t.fill("evenodd"), this.pendingEOFill = !1) : t.fill()), n && t.restore(), e && this.consumePath(r);
  }
  eoFill() {
    this.pendingEOFill = !0, this.fill();
  }
  fillStroke() {
    this.fill(!1), this.stroke(!1), this.consumePath();
  }
  eoFillStroke() {
    this.pendingEOFill = !0, this.fillStroke();
  }
  closeFillStroke() {
    this.closePath(), this.fillStroke();
  }
  closeEOFillStroke() {
    this.pendingEOFill = !0, this.closePath(), this.fillStroke();
  }
  endPath() {
    this.consumePath();
  }
  clip() {
    this.pendingClip = hA;
  }
  eoClip() {
    this.pendingClip = Eg;
  }
  beginText() {
    this.current.textMatrix = pm, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
  }
  endText() {
    const e = this.pendingTextPaths, t = this.ctx;
    if (e === void 0) {
      t.beginPath();
      return;
    }
    t.save(), t.beginPath();
    for (const s of e)
      t.setTransform(...s.transform), t.translate(s.x, s.y), s.addToPath(t, s.fontSize);
    t.restore(), t.clip(), t.beginPath(), delete this.pendingTextPaths;
  }
  setCharSpacing(e) {
    this.current.charSpacing = e;
  }
  setWordSpacing(e) {
    this.current.wordSpacing = e;
  }
  setHScale(e) {
    this.current.textHScale = e / 100;
  }
  setLeading(e) {
    this.current.leading = -e;
  }
  setFont(e, t) {
    var d;
    const s = this.commonObjs.get(e), i = this.current;
    if (!s)
      throw new Error(`Can't find font for ${e}`);
    if (i.fontMatrix = s.fontMatrix || Hu, (i.fontMatrix[0] === 0 || i.fontMatrix[3] === 0) && nt("Invalid font matrix for font " + e), t < 0 ? (t = -t, i.fontDirection = -1) : i.fontDirection = 1, this.current.font = s, this.current.fontSize = t, s.isType3Font)
      return;
    const n = s.loadedName || "sans-serif", r = ((d = s.systemFontInfo) == null ? void 0 : d.css) || `"${n}", ${s.fallbackName}`;
    let a = "normal";
    s.black ? a = "900" : s.bold && (a = "bold");
    const h = s.italic ? "italic" : "normal";
    let c = t;
    t < fg ? c = fg : t > pg && (c = pg), this.current.fontSizeScale = t / c, this.ctx.font = `${h} ${a} ${c}px ${r}`;
  }
  setTextRenderingMode(e) {
    this.current.textRenderingMode = e;
  }
  setTextRise(e) {
    this.current.textRise = e;
  }
  moveText(e, t) {
    this.current.x = this.current.lineX += e, this.current.y = this.current.lineY += t;
  }
  setLeadingMoveText(e, t) {
    this.setLeading(-t), this.moveText(e, t);
  }
  setTextMatrix(e, t, s, i, n, r) {
    this.current.textMatrix = [e, t, s, i, n, r], this.current.textMatrixScale = Math.hypot(e, t), this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
  }
  nextLine() {
    this.moveText(0, this.current.leading);
  }
  paintChar(e, t, s, i) {
    const n = this.ctx, r = this.current, a = r.font, h = r.textRenderingMode, c = r.fontSize / r.fontSizeScale, d = h & ue.FILL_STROKE_MASK, u = !!(h & ue.ADD_TO_PATH_FLAG), f = r.patternFill && !a.missingFile;
    let p;
    (a.disableFontFace || u || f) && (p = a.getPathGenerator(this.commonObjs, e)), a.disableFontFace || f ? (n.save(), n.translate(t, s), n.beginPath(), p(n, c), i && n.setTransform(...i), (d === ue.FILL || d === ue.FILL_STROKE) && n.fill(), (d === ue.STROKE || d === ue.FILL_STROKE) && n.stroke(), n.restore()) : ((d === ue.FILL || d === ue.FILL_STROKE) && n.fillText(e, t, s), (d === ue.STROKE || d === ue.FILL_STROKE) && n.strokeText(e, t, s)), u && (this.pendingTextPaths || (this.pendingTextPaths = [])).push({
      transform: It(n),
      x: t,
      y: s,
      fontSize: c,
      addToPath: p
    });
  }
  get isFontSubpixelAAEnabled() {
    const {
      context: e
    } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
    e.scale(1.5, 1), e.fillText("I", 0, 10);
    const t = e.getImageData(0, 0, 10, 10).data;
    let s = !1;
    for (let i = 3; i < t.length; i += 4)
      if (t[i] > 0 && t[i] < 255) {
        s = !0;
        break;
      }
    return ht(this, "isFontSubpixelAAEnabled", s);
  }
  showText(e) {
    const t = this.current, s = t.font;
    if (s.isType3Font)
      return this.showType3Text(e);
    const i = t.fontSize;
    if (i === 0)
      return;
    const n = this.ctx, r = t.fontSizeScale, a = t.charSpacing, h = t.wordSpacing, c = t.fontDirection, d = t.textHScale * c, u = e.length, f = s.vertical, p = f ? 1 : -1, g = s.defaultVMetrics, b = i * t.fontMatrix[0], E = t.textRenderingMode === ue.FILL && !s.disableFontFace && !t.patternFill;
    n.save(), n.transform(...t.textMatrix), n.translate(t.x, t.y + t.textRise), c > 0 ? n.scale(d, -1) : n.scale(d, 1);
    let A;
    if (t.patternFill) {
      n.save();
      const C = t.fillColor.getPattern(n, this, ii(n), xe.FILL);
      A = It(n), n.restore(), n.fillStyle = C;
    }
    let w = t.lineWidth;
    const x = t.textMatrixScale;
    if (x === 0 || w === 0) {
      const C = t.textRenderingMode & ue.FILL_STROKE_MASK;
      (C === ue.STROKE || C === ue.FILL_STROKE) && (w = this.getSinglePixelWidth());
    } else
      w /= x;
    if (r !== 1 && (n.scale(r, r), w /= r), n.lineWidth = w, s.isInvalidPDFjsFont) {
      const C = [];
      let R = 0;
      for (const M of e)
        C.push(M.unicode), R += M.width;
      n.fillText(C.join(""), 0, 0), t.x += R * b * d, n.restore(), this.compose();
      return;
    }
    let P = 0, T;
    for (T = 0; T < u; ++T) {
      const C = e[T];
      if (typeof C == "number") {
        P += p * C * i / 1e3;
        continue;
      }
      let R = !1;
      const M = (C.isSpace ? h : 0) + a, S = C.fontChar, I = C.accent;
      let _, D, k = C.width;
      if (f) {
        const H = C.vmetric || g, L = -(C.vmetric ? H[1] : k * 0.5) * b, F = H[2] * b;
        k = H ? -H[0] : k, _ = L / r, D = (P + F) / r;
      } else
        _ = P / r, D = 0;
      if (s.remeasure && k > 0) {
        const H = n.measureText(S).width * 1e3 / i * r;
        if (k < H && this.isFontSubpixelAAEnabled) {
          const L = k / H;
          R = !0, n.save(), n.scale(L, 1), _ /= L;
        } else k !== H && (_ += (k - H) / 2e3 * i / r);
      }
      if (this.contentVisible && (C.isInFont || s.missingFile)) {
        if (E && !I)
          n.fillText(S, _, D);
        else if (this.paintChar(S, _, D, A), I) {
          const H = _ + i * I.offset.x / r, L = D - i * I.offset.y / r;
          this.paintChar(I.fontChar, H, L, A);
        }
      }
      const j = f ? k * b - M * c : k * b + M * c;
      P += j, R && n.restore();
    }
    f ? t.y -= P : t.x += P * d, n.restore(), this.compose();
  }
  showType3Text(e) {
    const t = this.ctx, s = this.current, i = s.font, n = s.fontSize, r = s.fontDirection, a = i.vertical ? 1 : -1, h = s.charSpacing, c = s.wordSpacing, d = s.textHScale * r, u = s.fontMatrix || Hu, f = e.length, p = s.textRenderingMode === ue.INVISIBLE;
    let g, b, E, A;
    if (!(p || n === 0)) {
      for (this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null, t.save(), t.transform(...s.textMatrix), t.translate(s.x, s.y), t.scale(d, r), g = 0; g < f; ++g) {
        if (b = e[g], typeof b == "number") {
          A = a * b * n / 1e3, this.ctx.translate(A, 0), s.x += A * d;
          continue;
        }
        const w = (b.isSpace ? c : 0) + h, x = i.charProcOperatorList[b.operatorListId];
        if (!x) {
          nt(`Type3 character "${b.operatorListId}" is not available.`);
          continue;
        }
        this.contentVisible && (this.processingType3 = b, this.save(), t.scale(n, n), t.transform(...u), this.executeOperatorList(x), this.restore()), E = X.applyTransform([b.width, 0], u)[0] * n + w, t.translate(E, 0), s.x += E * d;
      }
      t.restore(), this.processingType3 = null;
    }
  }
  setCharWidth(e, t) {
  }
  setCharWidthAndBounds(e, t, s, i, n, r) {
    this.ctx.rect(s, i, n - s, r - i), this.ctx.clip(), this.endPath();
  }
  getColorN_Pattern(e) {
    let t;
    if (e[0] === "TilingPattern") {
      const s = e[1], i = this.baseTransform || It(this.ctx), n = {
        createCanvasGraphics: (r) => new tg(r, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
          optionalContentConfig: this.optionalContentConfig,
          markedContentStack: this.markedContentStack
        })
      };
      t = new mf(e, s, this.ctx, n, i);
    } else
      t = this._getPattern(e[1], e[2]);
    return t;
  }
  setStrokeColorN() {
    this.current.strokeColor = this.getColorN_Pattern(arguments);
  }
  setFillColorN() {
    this.current.fillColor = this.getColorN_Pattern(arguments), this.current.patternFill = !0;
  }
  setStrokeRGBColor(e, t, s) {
    this.ctx.strokeStyle = this.current.strokeColor = X.makeHexColor(e, t, s);
  }
  setStrokeTransparent() {
    this.ctx.strokeStyle = this.current.strokeColor = "transparent";
  }
  setFillRGBColor(e, t, s) {
    this.ctx.fillStyle = this.current.fillColor = X.makeHexColor(e, t, s), this.current.patternFill = !1;
  }
  setFillTransparent() {
    this.ctx.fillStyle = this.current.fillColor = "transparent", this.current.patternFill = !1;
  }
  _getPattern(e, t = null) {
    let s;
    return this.cachedPatterns.has(e) ? s = this.cachedPatterns.get(e) : (s = eA(this.getObject(e)), this.cachedPatterns.set(e, s)), t && (s.matrix = t), s;
  }
  shadingFill(e) {
    if (!this.contentVisible)
      return;
    const t = this.ctx;
    this.save();
    const s = this._getPattern(e);
    t.fillStyle = s.getPattern(t, this, ii(t), xe.SHADING);
    const i = ii(t);
    if (i) {
      const {
        width: n,
        height: r
      } = t.canvas, [a, h, c, d] = X.getAxialAlignedBoundingBox([0, 0, n, r], i);
      this.ctx.fillRect(a, h, c - a, d - h);
    } else
      this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
    this.compose(this.current.getClippedPathBoundingBox()), this.restore();
  }
  beginInlineImage() {
    Ut("Should not call beginInlineImage");
  }
  beginImageData() {
    Ut("Should not call beginImageData");
  }
  paintFormXObjectBegin(e, t) {
    if (this.contentVisible && (this.save(), this.baseTransformStack.push(this.baseTransform), e && this.transform(...e), this.baseTransform = It(this.ctx), t)) {
      const s = t[2] - t[0], i = t[3] - t[1];
      this.ctx.rect(t[0], t[1], s, i), this.current.updateRectMinMax(It(this.ctx), t), this.clip(), this.endPath();
    }
  }
  paintFormXObjectEnd() {
    this.contentVisible && (this.restore(), this.baseTransform = this.baseTransformStack.pop());
  }
  beginGroup(e) {
    if (!this.contentVisible)
      return;
    this.save(), this.inSMaskMode && (this.endSMaskMode(), this.current.activeSMask = null);
    const t = this.ctx;
    e.isolated || fu("TODO: Support non-isolated groups."), e.knockout && nt("Knockout groups not supported.");
    const s = It(t);
    if (e.matrix && t.transform(...e.matrix), !e.bbox)
      throw new Error("Bounding box is required.");
    let i = X.getAxialAlignedBoundingBox(e.bbox, It(t));
    const n = [0, 0, t.canvas.width, t.canvas.height];
    i = X.intersect(i, n) || [0, 0, 0, 0];
    const r = Math.floor(i[0]), a = Math.floor(i[1]), h = Math.max(Math.ceil(i[2]) - r, 1), c = Math.max(Math.ceil(i[3]) - a, 1);
    this.current.startNewPathAndClipBox([0, 0, h, c]);
    let d = "groupAt" + this.groupLevel;
    e.smask && (d += "_smask_" + this.smaskCounter++ % 2);
    const u = this.cachedCanvases.getCanvas(d, h, c), f = u.context;
    f.translate(-r, -a), f.transform(...s), e.smask ? this.smaskStack.push({
      canvas: u.canvas,
      context: f,
      offsetX: r,
      offsetY: a,
      subtype: e.smask.subtype,
      backdrop: e.smask.backdrop,
      transferMap: e.smask.transferMap || null,
      startTransformInverse: null
    }) : (t.setTransform(1, 0, 0, 1, 0, 0), t.translate(r, a), t.save()), nl(t, f), this.ctx = f, this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]), this.groupStack.push(t), this.groupLevel++;
  }
  endGroup(e) {
    if (!this.contentVisible)
      return;
    this.groupLevel--;
    const t = this.ctx, s = this.groupStack.pop();
    if (this.ctx = s, this.ctx.imageSmoothingEnabled = !1, e.smask)
      this.tempSMask = this.smaskStack.pop(), this.restore();
    else {
      this.ctx.restore();
      const i = It(this.ctx);
      this.restore(), this.ctx.save(), this.ctx.setTransform(...i);
      const n = X.getAxialAlignedBoundingBox([0, 0, t.canvas.width, t.canvas.height], i);
      this.ctx.drawImage(t.canvas, 0, 0), this.ctx.restore(), this.compose(n);
    }
  }
  beginAnnotation(e, t, s, i, n) {
    if (m(this, Un, vf).call(this), Fc(this.ctx), this.ctx.save(), this.save(), this.baseTransform && this.ctx.setTransform(...this.baseTransform), t) {
      const r = t[2] - t[0], a = t[3] - t[1];
      if (n && this.annotationCanvasMap) {
        s = s.slice(), s[4] -= t[0], s[5] -= t[1], t = t.slice(), t[0] = t[1] = 0, t[2] = r, t[3] = a;
        const [h, c] = X.singularValueDecompose2dScale(It(this.ctx)), {
          viewportScale: d
        } = this, u = Math.ceil(r * this.outputScaleX * d), f = Math.ceil(a * this.outputScaleY * d);
        this.annotationCanvas = this.canvasFactory.create(u, f);
        const {
          canvas: p,
          context: g
        } = this.annotationCanvas;
        this.annotationCanvasMap.set(e, p), this.annotationCanvas.savedCtx = this.ctx, this.ctx = g, this.ctx.save(), this.ctx.setTransform(h, 0, 0, -c, 0, a * c), Fc(this.ctx);
      } else
        Fc(this.ctx), this.endPath(), this.ctx.rect(t[0], t[1], r, a), this.ctx.clip(), this.ctx.beginPath();
    }
    this.current = new vg(this.ctx.canvas.width, this.ctx.canvas.height), this.transform(...s), this.transform(...i);
  }
  endAnnotation() {
    this.annotationCanvas && (this.ctx.restore(), m(this, Un, bf).call(this), this.ctx = this.annotationCanvas.savedCtx, delete this.annotationCanvas.savedCtx, delete this.annotationCanvas);
  }
  paintImageMaskXObject(e) {
    if (!this.contentVisible)
      return;
    const t = e.count;
    e = this.getObject(e.data, e), e.count = t;
    const s = this.ctx, i = this.processingType3;
    if (i && (i.compiled === void 0 && (i.compiled = aA(e)), i.compiled)) {
      i.compiled(s);
      return;
    }
    const n = this._createMaskCanvas(e), r = n.canvas;
    s.save(), s.setTransform(1, 0, 0, 1, 0, 0), s.drawImage(r, n.offsetX, n.offsetY), s.restore(), this.compose();
  }
  paintImageMaskXObjectRepeat(e, t, s = 0, i = 0, n, r) {
    if (!this.contentVisible)
      return;
    e = this.getObject(e.data, e);
    const a = this.ctx;
    a.save();
    const h = It(a);
    a.transform(t, s, i, n, 0, 0);
    const c = this._createMaskCanvas(e);
    a.setTransform(1, 0, 0, 1, c.offsetX - h[4], c.offsetY - h[5]);
    for (let d = 0, u = r.length; d < u; d += 2) {
      const f = X.transform(h, [t, s, i, n, r[d], r[d + 1]]), [p, g] = X.applyTransform([0, 0], f);
      a.drawImage(c.canvas, p, g);
    }
    a.restore(), this.compose();
  }
  paintImageMaskXObjectGroup(e) {
    if (!this.contentVisible)
      return;
    const t = this.ctx, s = this.current.fillColor, i = this.current.patternFill;
    for (const n of e) {
      const {
        data: r,
        width: a,
        height: h,
        transform: c
      } = n, d = this.cachedCanvases.getCanvas("maskCanvas", a, h), u = d.context;
      u.save();
      const f = this.getObject(r, n);
      yg(u, f), u.globalCompositeOperation = "source-in", u.fillStyle = i ? s.getPattern(u, this, ii(t), xe.FILL) : s, u.fillRect(0, 0, a, h), u.restore(), t.save(), t.transform(...c), t.scale(1, -1), kc(t, d.canvas, 0, 0, a, h, 0, -1, 1, 1), t.restore();
    }
    this.compose();
  }
  paintImageXObject(e) {
    if (!this.contentVisible)
      return;
    const t = this.getObject(e);
    if (!t) {
      nt("Dependent image isn't ready yet");
      return;
    }
    this.paintInlineImageXObject(t);
  }
  paintImageXObjectRepeat(e, t, s, i) {
    if (!this.contentVisible)
      return;
    const n = this.getObject(e);
    if (!n) {
      nt("Dependent image isn't ready yet");
      return;
    }
    const r = n.width, a = n.height, h = [];
    for (let c = 0, d = i.length; c < d; c += 2)
      h.push({
        transform: [t, 0, 0, s, i[c], i[c + 1]],
        x: 0,
        y: 0,
        w: r,
        h: a
      });
    this.paintInlineImageXObjectGroup(n, h);
  }
  applyTransferMapsToCanvas(e) {
    return this.current.transferMaps !== "none" && (e.filter = this.current.transferMaps, e.drawImage(e.canvas, 0, 0), e.filter = "none"), e.canvas;
  }
  applyTransferMapsToBitmap(e) {
    if (this.current.transferMaps === "none")
      return e.bitmap;
    const {
      bitmap: t,
      width: s,
      height: i
    } = e, n = this.cachedCanvases.getCanvas("inlineImage", s, i), r = n.context;
    return r.filter = this.current.transferMaps, r.drawImage(t, 0, 0), r.filter = "none", n.canvas;
  }
  paintInlineImageXObject(e) {
    if (!this.contentVisible)
      return;
    const t = e.width, s = e.height, i = this.ctx;
    if (this.save(), !ye) {
      const {
        filter: a
      } = i;
      a !== "none" && a !== "" && (i.filter = "none");
    }
    i.scale(1 / t, -1 / s);
    let n;
    if (e.bitmap)
      n = this.applyTransferMapsToBitmap(e);
    else if (typeof HTMLElement == "function" && e instanceof HTMLElement || !e.data)
      n = e;
    else {
      const h = this.cachedCanvases.getCanvas("inlineImage", t, s).context;
      bg(h, e), n = this.applyTransferMapsToCanvas(h);
    }
    const r = this._scaleImage(n, ii(i));
    i.imageSmoothingEnabled = Ag(It(i), e.interpolate), kc(i, r.img, 0, 0, r.paintWidth, r.paintHeight, 0, -s, t, s), this.compose(), this.restore();
  }
  paintInlineImageXObjectGroup(e, t) {
    if (!this.contentVisible)
      return;
    const s = this.ctx;
    let i;
    if (e.bitmap)
      i = e.bitmap;
    else {
      const n = e.width, r = e.height, h = this.cachedCanvases.getCanvas("inlineImage", n, r).context;
      bg(h, e), i = this.applyTransferMapsToCanvas(h);
    }
    for (const n of t)
      s.save(), s.transform(...n.transform), s.scale(1, -1), kc(s, i, n.x, n.y, n.w, n.h, 0, -1, 1, 1), s.restore();
    this.compose();
  }
  paintSolidColorImageMask() {
    this.contentVisible && (this.ctx.fillRect(0, 0, 1, 1), this.compose());
  }
  markPoint(e) {
  }
  markPointProps(e, t) {
  }
  beginMarkedContent(e) {
    this.markedContentStack.push({
      visible: !0
    });
  }
  beginMarkedContentProps(e, t) {
    e === "OC" ? this.markedContentStack.push({
      visible: this.optionalContentConfig.isVisible(t)
    }) : this.markedContentStack.push({
      visible: !0
    }), this.contentVisible = this.isContentVisible();
  }
  endMarkedContent() {
    this.markedContentStack.pop(), this.contentVisible = this.isContentVisible();
  }
  beginCompat() {
  }
  endCompat() {
  }
  consumePath(e) {
    const t = this.current.isEmptyClip();
    this.pendingClip && this.current.updateClipFromPath(), this.pendingClip || this.compose(e);
    const s = this.ctx;
    this.pendingClip && (t || (this.pendingClip === Eg ? s.clip("evenodd") : s.clip()), this.pendingClip = null), this.current.startNewPathAndClipBox(this.current.clipBox), s.beginPath();
  }
  getSinglePixelWidth() {
    if (!this._cachedGetSinglePixelWidth) {
      const e = It(this.ctx);
      if (e[1] === 0 && e[2] === 0)
        this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(e[0]), Math.abs(e[3]));
      else {
        const t = Math.abs(e[0] * e[3] - e[2] * e[1]), s = Math.hypot(e[0], e[2]), i = Math.hypot(e[1], e[3]);
        this._cachedGetSinglePixelWidth = Math.max(s, i) / t;
      }
    }
    return this._cachedGetSinglePixelWidth;
  }
  getScaleForStroking() {
    if (this._cachedScaleForStroking[0] === -1) {
      const {
        lineWidth: e
      } = this.current, {
        a: t,
        b: s,
        c: i,
        d: n
      } = this.ctx.getTransform();
      let r, a;
      if (s === 0 && i === 0) {
        const h = Math.abs(t), c = Math.abs(n);
        if (h === c)
          if (e === 0)
            r = a = 1 / h;
          else {
            const d = h * e;
            r = a = d < 1 ? 1 / d : 1;
          }
        else if (e === 0)
          r = 1 / h, a = 1 / c;
        else {
          const d = h * e, u = c * e;
          r = d < 1 ? 1 / d : 1, a = u < 1 ? 1 / u : 1;
        }
      } else {
        const h = Math.abs(t * n - s * i), c = Math.hypot(t, s), d = Math.hypot(i, n);
        if (e === 0)
          r = d / h, a = c / h;
        else {
          const u = e * h;
          r = d > u ? d / u : 1, a = c > u ? c / u : 1;
        }
      }
      this._cachedScaleForStroking[0] = r, this._cachedScaleForStroking[1] = a;
    }
    return this._cachedScaleForStroking;
  }
  rescaleAndStroke(e) {
    const {
      ctx: t
    } = this, {
      lineWidth: s
    } = this.current, [i, n] = this.getScaleForStroking();
    if (t.lineWidth = s || 1, i === 1 && n === 1) {
      t.stroke();
      return;
    }
    const r = t.getLineDash();
    if (e && t.save(), t.scale(i, n), r.length > 0) {
      const a = Math.max(i, n);
      t.setLineDash(r.map((h) => h / a)), t.lineDashOffset /= a;
    }
    t.stroke(), e && t.restore();
  }
  isContentVisible() {
    for (let e = this.markedContentStack.length - 1; e >= 0; e--)
      if (!this.markedContentStack[e].visible)
        return !1;
    return !0;
  }
};
Un = new WeakSet(), vf = function() {
  for (; this.stateStack.length || this.inSMaskMode; )
    this.restore();
  this.current.activeSMask = null, this.ctx.restore(), this.transparentCanvas && (this.ctx = this.compositeCtx, this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.drawImage(this.transparentCanvas, 0, 0), this.ctx.restore(), this.transparentCanvas = null);
}, bf = function() {
  if (this.pageColors) {
    const e = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
    if (e !== "none") {
      const t = this.ctx.filter;
      this.ctx.filter = e, this.ctx.drawImage(this.ctx.canvas, 0, 0), this.ctx.filter = t;
    }
  }
};
let _a = tg;
for (const l in hs)
  _a.prototype[l] !== void 0 && (_a.prototype[hs[l]] = _a.prototype[l]);
var Xc, oh, lh;
let Zn = (Xc = class {
  static get workerPort() {
    return o(this, oh);
  }
  static set workerPort(e) {
    if (!(typeof Worker < "u" && e instanceof Worker) && e !== null)
      throw new Error("Invalid `workerPort` type.");
    v(this, oh, e);
  }
  static get workerSrc() {
    return o(this, lh);
  }
  static set workerSrc(e) {
    if (typeof e != "string")
      throw new Error("Invalid `workerSrc` type.");
    v(this, lh, e);
  }
}, oh = new WeakMap(), lh = new WeakMap(), y(Xc, oh, null), y(Xc, lh, ""), Xc);
const jc = {
  UNKNOWN: 0,
  DATA: 1,
  ERROR: 2
}, jt = {
  UNKNOWN: 0,
  CANCEL: 1,
  CANCEL_COMPLETE: 2,
  CLOSE: 3,
  ENQUEUE: 4,
  ERROR: 5,
  PULL: 6,
  PULL_COMPLETE: 7,
  START_COMPLETE: 8
};
function Fe(l) {
  switch (l instanceof Error || typeof l == "object" && l !== null || Ut('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), l.name) {
    case "AbortException":
      return new ya(l.message);
    case "MissingPDFException":
      return new ba(l.message);
    case "PasswordException":
      return new Vu(l.message, l.code);
    case "UnexpectedResponseException":
      return new pu(l.message, l.status);
    case "UnknownErrorException":
      return new Uu(l.message, l.details);
    default:
      return new Uu(l.message, l.toString());
  }
}
var ti, qm, tv, id;
class gl {
  constructor(e, t, s) {
    y(this, ti);
    this.sourceName = e, this.targetName = t, this.comObj = s, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), this._onComObjOnMessage = (i) => {
      const n = i.data;
      if (n.targetName !== this.sourceName)
        return;
      if (n.stream) {
        m(this, ti, tv).call(this, n);
        return;
      }
      if (n.callback) {
        const a = n.callbackId, h = this.callbackCapabilities[a];
        if (!h)
          throw new Error(`Cannot resolve callback ${a}`);
        if (delete this.callbackCapabilities[a], n.callback === jc.DATA)
          h.resolve(n.data);
        else if (n.callback === jc.ERROR)
          h.reject(Fe(n.reason));
        else
          throw new Error("Unexpected callback case");
        return;
      }
      const r = this.actionHandler[n.action];
      if (!r)
        throw new Error(`Unknown action from worker: ${n.action}`);
      if (n.callbackId) {
        const a = this.sourceName, h = n.sourceName;
        new Promise(function(c) {
          c(r(n.data));
        }).then(function(c) {
          s.postMessage({
            sourceName: a,
            targetName: h,
            callback: jc.DATA,
            callbackId: n.callbackId,
            data: c
          });
        }, function(c) {
          s.postMessage({
            sourceName: a,
            targetName: h,
            callback: jc.ERROR,
            callbackId: n.callbackId,
            reason: Fe(c)
          });
        });
        return;
      }
      if (n.streamId) {
        m(this, ti, qm).call(this, n);
        return;
      }
      r(n.data);
    }, s.addEventListener("message", this._onComObjOnMessage);
  }
  on(e, t) {
    const s = this.actionHandler;
    if (s[e])
      throw new Error(`There is already an actionName called "${e}"`);
    s[e] = t;
  }
  send(e, t, s) {
    this.comObj.postMessage({
      sourceName: this.sourceName,
      targetName: this.targetName,
      action: e,
      data: t
    }, s);
  }
  sendWithPromise(e, t, s) {
    const i = this.callbackId++, n = Promise.withResolvers();
    this.callbackCapabilities[i] = n;
    try {
      this.comObj.postMessage({
        sourceName: this.sourceName,
        targetName: this.targetName,
        action: e,
        callbackId: i,
        data: t
      }, s);
    } catch (r) {
      n.reject(r);
    }
    return n.promise;
  }
  sendWithStream(e, t, s, i) {
    const n = this.streamId++, r = this.sourceName, a = this.targetName, h = this.comObj;
    return new ReadableStream({
      start: (c) => {
        const d = Promise.withResolvers();
        return this.streamControllers[n] = {
          controller: c,
          startCall: d,
          pullCall: null,
          cancelCall: null,
          isClosed: !1
        }, h.postMessage({
          sourceName: r,
          targetName: a,
          action: e,
          streamId: n,
          data: t,
          desiredSize: c.desiredSize
        }, i), d.promise;
      },
      pull: (c) => {
        const d = Promise.withResolvers();
        return this.streamControllers[n].pullCall = d, h.postMessage({
          sourceName: r,
          targetName: a,
          stream: jt.PULL,
          streamId: n,
          desiredSize: c.desiredSize
        }), d.promise;
      },
      cancel: (c) => {
        Qt(c instanceof Error, "cancel must have a valid reason");
        const d = Promise.withResolvers();
        return this.streamControllers[n].cancelCall = d, this.streamControllers[n].isClosed = !0, h.postMessage({
          sourceName: r,
          targetName: a,
          stream: jt.CANCEL,
          streamId: n,
          reason: Fe(c)
        }), d.promise;
      }
    }, s);
  }
  destroy() {
    this.comObj.removeEventListener("message", this._onComObjOnMessage);
  }
}
ti = new WeakSet(), qm = function(e) {
  const t = e.streamId, s = this.sourceName, i = e.sourceName, n = this.comObj, r = this, a = this.actionHandler[e.action], h = {
    enqueue(c, d = 1, u) {
      if (this.isCancelled)
        return;
      const f = this.desiredSize;
      this.desiredSize -= d, f > 0 && this.desiredSize <= 0 && (this.sinkCapability = Promise.withResolvers(), this.ready = this.sinkCapability.promise), n.postMessage({
        sourceName: s,
        targetName: i,
        stream: jt.ENQUEUE,
        streamId: t,
        chunk: c
      }, u);
    },
    close() {
      this.isCancelled || (this.isCancelled = !0, n.postMessage({
        sourceName: s,
        targetName: i,
        stream: jt.CLOSE,
        streamId: t
      }), delete r.streamSinks[t]);
    },
    error(c) {
      Qt(c instanceof Error, "error must have a valid reason"), !this.isCancelled && (this.isCancelled = !0, n.postMessage({
        sourceName: s,
        targetName: i,
        stream: jt.ERROR,
        streamId: t,
        reason: Fe(c)
      }));
    },
    sinkCapability: Promise.withResolvers(),
    onPull: null,
    onCancel: null,
    isCancelled: !1,
    desiredSize: e.desiredSize,
    ready: null
  };
  h.sinkCapability.resolve(), h.ready = h.sinkCapability.promise, this.streamSinks[t] = h, new Promise(function(c) {
    c(a(e.data, h));
  }).then(function() {
    n.postMessage({
      sourceName: s,
      targetName: i,
      stream: jt.START_COMPLETE,
      streamId: t,
      success: !0
    });
  }, function(c) {
    n.postMessage({
      sourceName: s,
      targetName: i,
      stream: jt.START_COMPLETE,
      streamId: t,
      reason: Fe(c)
    });
  });
}, tv = function(e) {
  const t = e.streamId, s = this.sourceName, i = e.sourceName, n = this.comObj, r = this.streamControllers[t], a = this.streamSinks[t];
  switch (e.stream) {
    case jt.START_COMPLETE:
      e.success ? r.startCall.resolve() : r.startCall.reject(Fe(e.reason));
      break;
    case jt.PULL_COMPLETE:
      e.success ? r.pullCall.resolve() : r.pullCall.reject(Fe(e.reason));
      break;
    case jt.PULL:
      if (!a) {
        n.postMessage({
          sourceName: s,
          targetName: i,
          stream: jt.PULL_COMPLETE,
          streamId: t,
          success: !0
        });
        break;
      }
      a.desiredSize <= 0 && e.desiredSize > 0 && a.sinkCapability.resolve(), a.desiredSize = e.desiredSize, new Promise(function(h) {
        var c;
        h((c = a.onPull) == null ? void 0 : c.call(a));
      }).then(function() {
        n.postMessage({
          sourceName: s,
          targetName: i,
          stream: jt.PULL_COMPLETE,
          streamId: t,
          success: !0
        });
      }, function(h) {
        n.postMessage({
          sourceName: s,
          targetName: i,
          stream: jt.PULL_COMPLETE,
          streamId: t,
          reason: Fe(h)
        });
      });
      break;
    case jt.ENQUEUE:
      if (Qt(r, "enqueue should have stream controller"), r.isClosed)
        break;
      r.controller.enqueue(e.chunk);
      break;
    case jt.CLOSE:
      if (Qt(r, "close should have stream controller"), r.isClosed)
        break;
      r.isClosed = !0, r.controller.close(), m(this, ti, id).call(this, r, t);
      break;
    case jt.ERROR:
      Qt(r, "error should have stream controller"), r.controller.error(Fe(e.reason)), m(this, ti, id).call(this, r, t);
      break;
    case jt.CANCEL_COMPLETE:
      e.success ? r.cancelCall.resolve() : r.cancelCall.reject(Fe(e.reason)), m(this, ti, id).call(this, r, t);
      break;
    case jt.CANCEL:
      if (!a)
        break;
      new Promise(function(h) {
        var c;
        h((c = a.onCancel) == null ? void 0 : c.call(a, Fe(e.reason)));
      }).then(function() {
        n.postMessage({
          sourceName: s,
          targetName: i,
          stream: jt.CANCEL_COMPLETE,
          streamId: t,
          success: !0
        });
      }, function(h) {
        n.postMessage({
          sourceName: s,
          targetName: i,
          stream: jt.CANCEL_COMPLETE,
          streamId: t,
          reason: Fe(h)
        });
      }), a.sinkCapability.reject(Fe(e.reason)), a.isCancelled = !0, delete this.streamSinks[t];
      break;
    default:
      throw new Error("Unexpected stream case");
  }
}, id = async function(e, t) {
  var s, i, n;
  await Promise.allSettled([(s = e.startCall) == null ? void 0 : s.promise, (i = e.pullCall) == null ? void 0 : i.promise, (n = e.cancelCall) == null ? void 0 : n.promise]), delete this.streamControllers[t];
};
var yr, hh;
class cA {
  constructor({
    parsedData: e,
    rawData: t
  }) {
    y(this, yr);
    y(this, hh);
    v(this, yr, e), v(this, hh, t);
  }
  getRaw() {
    return o(this, hh);
  }
  get(e) {
    return o(this, yr).get(e) ?? null;
  }
  getAll() {
    return Bp(o(this, yr));
  }
  has(e) {
    return o(this, yr).has(e);
  }
}
yr = new WeakMap(), hh = new WeakMap();
const Gi = Symbol("INTERNAL");
var ch, dh, uh, Ka;
class dA {
  constructor(e, {
    name: t,
    intent: s,
    usage: i
  }) {
    y(this, ch, !1);
    y(this, dh, !1);
    y(this, uh, !1);
    y(this, Ka, !0);
    v(this, ch, !!(e & Xe.DISPLAY)), v(this, dh, !!(e & Xe.PRINT)), this.name = t, this.intent = s, this.usage = i;
  }
  get visible() {
    if (o(this, uh))
      return o(this, Ka);
    if (!o(this, Ka))
      return !1;
    const {
      print: e,
      view: t
    } = this.usage;
    return o(this, ch) ? (t == null ? void 0 : t.viewState) !== "OFF" : o(this, dh) ? (e == null ? void 0 : e.printState) !== "OFF" : !0;
  }
  _setVisible(e, t, s = !1) {
    e !== Gi && Ut("Internal method `_setVisible` called."), v(this, uh, s), v(this, Ka, t);
  }
}
ch = new WeakMap(), dh = new WeakMap(), uh = new WeakMap(), Ka = new WeakMap();
var hn, yt, Ya, Qa, fh, yf;
class uA {
  constructor(e, t = Xe.DISPLAY) {
    y(this, fh);
    y(this, hn, null);
    y(this, yt, /* @__PURE__ */ new Map());
    y(this, Ya, null);
    y(this, Qa, null);
    if (this.renderingIntent = t, this.name = null, this.creator = null, e !== null) {
      this.name = e.name, this.creator = e.creator, v(this, Qa, e.order);
      for (const s of e.groups)
        o(this, yt).set(s.id, new dA(t, s));
      if (e.baseState === "OFF")
        for (const s of o(this, yt).values())
          s._setVisible(Gi, !1);
      for (const s of e.on)
        o(this, yt).get(s)._setVisible(Gi, !0);
      for (const s of e.off)
        o(this, yt).get(s)._setVisible(Gi, !1);
      v(this, Ya, this.getHash());
    }
  }
  isVisible(e) {
    if (o(this, yt).size === 0)
      return !0;
    if (!e)
      return fu("Optional content group not defined."), !0;
    if (e.type === "OCG")
      return o(this, yt).has(e.id) ? o(this, yt).get(e.id).visible : (nt(`Optional content group not found: ${e.id}`), !0);
    if (e.type === "OCMD") {
      if (e.expression)
        return m(this, fh, yf).call(this, e.expression);
      if (!e.policy || e.policy === "AnyOn") {
        for (const t of e.ids) {
          if (!o(this, yt).has(t))
            return nt(`Optional content group not found: ${t}`), !0;
          if (o(this, yt).get(t).visible)
            return !0;
        }
        return !1;
      } else if (e.policy === "AllOn") {
        for (const t of e.ids) {
          if (!o(this, yt).has(t))
            return nt(`Optional content group not found: ${t}`), !0;
          if (!o(this, yt).get(t).visible)
            return !1;
        }
        return !0;
      } else if (e.policy === "AnyOff") {
        for (const t of e.ids) {
          if (!o(this, yt).has(t))
            return nt(`Optional content group not found: ${t}`), !0;
          if (!o(this, yt).get(t).visible)
            return !0;
        }
        return !1;
      } else if (e.policy === "AllOff") {
        for (const t of e.ids) {
          if (!o(this, yt).has(t))
            return nt(`Optional content group not found: ${t}`), !0;
          if (o(this, yt).get(t).visible)
            return !1;
        }
        return !0;
      }
      return nt(`Unknown optional content policy ${e.policy}.`), !0;
    }
    return nt(`Unknown group type ${e.type}.`), !0;
  }
  setVisibility(e, t = !0) {
    const s = o(this, yt).get(e);
    if (!s) {
      nt(`Optional content group not found: ${e}`);
      return;
    }
    s._setVisible(Gi, !!t, !0), v(this, hn, null);
  }
  setOCGState({
    state: e,
    preserveRB: t
  }) {
    let s;
    for (const i of e) {
      switch (i) {
        case "ON":
        case "OFF":
        case "Toggle":
          s = i;
          continue;
      }
      const n = o(this, yt).get(i);
      if (n)
        switch (s) {
          case "ON":
            n._setVisible(Gi, !0);
            break;
          case "OFF":
            n._setVisible(Gi, !1);
            break;
          case "Toggle":
            n._setVisible(Gi, !n.visible);
            break;
        }
    }
    v(this, hn, null);
  }
  get hasInitialVisibility() {
    return o(this, Ya) === null || this.getHash() === o(this, Ya);
  }
  getOrder() {
    return o(this, yt).size ? o(this, Qa) ? o(this, Qa).slice() : [...o(this, yt).keys()] : null;
  }
  getGroups() {
    return o(this, yt).size > 0 ? Bp(o(this, yt)) : null;
  }
  getGroup(e) {
    return o(this, yt).get(e) || null;
  }
  getHash() {
    if (o(this, hn) !== null)
      return o(this, hn);
    const e = new Ym();
    for (const [t, s] of o(this, yt))
      e.update(`${t}:${s.visible}`);
    return v(this, hn, e.hexdigest());
  }
}
hn = new WeakMap(), yt = new WeakMap(), Ya = new WeakMap(), Qa = new WeakMap(), fh = new WeakSet(), yf = function(e) {
  const t = e.length;
  if (t < 2)
    return !0;
  const s = e[0];
  for (let i = 1; i < t; i++) {
    const n = e[i];
    let r;
    if (Array.isArray(n))
      r = m(this, fh, yf).call(this, n);
    else if (o(this, yt).has(n))
      r = o(this, yt).get(n).visible;
    else
      return nt(`Optional content group not found: ${n}`), !0;
    switch (s) {
      case "And":
        if (!r)
          return !1;
        break;
      case "Or":
        if (r)
          return !0;
        break;
      case "Not":
        return !r;
      default:
        return !0;
    }
  }
  return s === "And";
};
class fA {
  constructor(e, {
    disableRange: t = !1,
    disableStream: s = !1
  }) {
    Qt(e, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
    const {
      length: i,
      initialData: n,
      progressiveDone: r,
      contentDispositionFilename: a
    } = e;
    if (this._queuedChunks = [], this._progressiveDone = r, this._contentDispositionFilename = a, (n == null ? void 0 : n.length) > 0) {
      const h = n instanceof Uint8Array && n.byteLength === n.buffer.byteLength ? n.buffer : new Uint8Array(n).buffer;
      this._queuedChunks.push(h);
    }
    this._pdfDataRangeTransport = e, this._isStreamingSupported = !s, this._isRangeSupported = !t, this._contentLength = i, this._fullRequestReader = null, this._rangeReaders = [], e.addRangeListener((h, c) => {
      this._onReceiveData({
        begin: h,
        chunk: c
      });
    }), e.addProgressListener((h, c) => {
      this._onProgress({
        loaded: h,
        total: c
      });
    }), e.addProgressiveReadListener((h) => {
      this._onReceiveData({
        chunk: h
      });
    }), e.addProgressiveDoneListener(() => {
      this._onProgressiveDone();
    }), e.transportReady();
  }
  _onReceiveData({
    begin: e,
    chunk: t
  }) {
    const s = t instanceof Uint8Array && t.byteLength === t.buffer.byteLength ? t.buffer : new Uint8Array(t).buffer;
    if (e === void 0)
      this._fullRequestReader ? this._fullRequestReader._enqueue(s) : this._queuedChunks.push(s);
    else {
      const i = this._rangeReaders.some(function(n) {
        return n._begin !== e ? !1 : (n._enqueue(s), !0);
      });
      Qt(i, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
    }
  }
  get _progressiveDataLength() {
    var e;
    return ((e = this._fullRequestReader) == null ? void 0 : e._loaded) ?? 0;
  }
  _onProgress(e) {
    var t, s, i, n;
    e.total === void 0 ? (s = (t = this._rangeReaders[0]) == null ? void 0 : t.onProgress) == null || s.call(t, {
      loaded: e.loaded
    }) : (n = (i = this._fullRequestReader) == null ? void 0 : i.onProgress) == null || n.call(i, {
      loaded: e.loaded,
      total: e.total
    });
  }
  _onProgressiveDone() {
    var e;
    (e = this._fullRequestReader) == null || e.progressiveDone(), this._progressiveDone = !0;
  }
  _removeRangeReader(e) {
    const t = this._rangeReaders.indexOf(e);
    t >= 0 && this._rangeReaders.splice(t, 1);
  }
  getFullReader() {
    Qt(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
    const e = this._queuedChunks;
    return this._queuedChunks = null, new pA(this, e, this._progressiveDone, this._contentDispositionFilename);
  }
  getRangeReader(e, t) {
    if (t <= this._progressiveDataLength)
      return null;
    const s = new gA(this, e, t);
    return this._pdfDataRangeTransport.requestDataRange(e, t), this._rangeReaders.push(s), s;
  }
  cancelAllRequests(e) {
    var t;
    (t = this._fullRequestReader) == null || t.cancel(e);
    for (const s of this._rangeReaders.slice(0))
      s.cancel(e);
    this._pdfDataRangeTransport.abort();
  }
}
class pA {
  constructor(e, t, s = !1, i = null) {
    this._stream = e, this._done = s || !1, this._filename = Up(i) ? i : null, this._queuedChunks = t || [], this._loaded = 0;
    for (const n of this._queuedChunks)
      this._loaded += n.byteLength;
    this._requests = [], this._headersReady = Promise.resolve(), e._fullRequestReader = this, this.onProgress = null;
  }
  _enqueue(e) {
    this._done || (this._requests.length > 0 ? this._requests.shift().resolve({
      value: e,
      done: !1
    }) : this._queuedChunks.push(e), this._loaded += e.byteLength);
  }
  get headersReady() {
    return this._headersReady;
  }
  get filename() {
    return this._filename;
  }
  get isRangeSupported() {
    return this._stream._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._stream._isStreamingSupported;
  }
  get contentLength() {
    return this._stream._contentLength;
  }
  async read() {
    if (this._queuedChunks.length > 0)
      return {
        value: this._queuedChunks.shift(),
        done: !1
      };
    if (this._done)
      return {
        value: void 0,
        done: !0
      };
    const e = Promise.withResolvers();
    return this._requests.push(e), e.promise;
  }
  cancel(e) {
    this._done = !0;
    for (const t of this._requests)
      t.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0;
  }
  progressiveDone() {
    this._done || (this._done = !0);
  }
}
class gA {
  constructor(e, t, s) {
    this._stream = e, this._begin = t, this._end = s, this._queuedChunk = null, this._requests = [], this._done = !1, this.onProgress = null;
  }
  _enqueue(e) {
    if (!this._done) {
      if (this._requests.length === 0)
        this._queuedChunk = e;
      else {
        this._requests.shift().resolve({
          value: e,
          done: !1
        });
        for (const s of this._requests)
          s.resolve({
            value: void 0,
            done: !0
          });
        this._requests.length = 0;
      }
      this._done = !0, this._stream._removeRangeReader(this);
    }
  }
  get isStreamingSupported() {
    return !1;
  }
  async read() {
    if (this._queuedChunk) {
      const t = this._queuedChunk;
      return this._queuedChunk = null, {
        value: t,
        done: !1
      };
    }
    if (this._done)
      return {
        value: void 0,
        done: !0
      };
    const e = Promise.withResolvers();
    return this._requests.push(e), e.promise;
  }
  cancel(e) {
    this._done = !0;
    for (const t of this._requests)
      t.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0, this._stream._removeRangeReader(this);
  }
}
function mA(l) {
  let e = !0, t = s("filename\\*", "i").exec(l);
  if (t) {
    t = t[1];
    let d = a(t);
    return d = unescape(d), d = h(d), d = c(d), n(d);
  }
  if (t = r(l), t) {
    const d = c(t);
    return n(d);
  }
  if (t = s("filename", "i").exec(l), t) {
    t = t[1];
    let d = a(t);
    return d = c(d), n(d);
  }
  function s(d, u) {
    return new RegExp("(?:^|;)\\s*" + d + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', u);
  }
  function i(d, u) {
    if (d) {
      if (!/^[\x00-\xFF]+$/.test(u))
        return u;
      try {
        const f = new TextDecoder(d, {
          fatal: !0
        }), p = gu(u);
        u = f.decode(p), e = !1;
      } catch {
      }
    }
    return u;
  }
  function n(d) {
    return e && /[\x80-\xff]/.test(d) && (d = i("utf-8", d), e && (d = i("iso-8859-1", d))), d;
  }
  function r(d) {
    const u = [];
    let f;
    const p = s("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
    for (; (f = p.exec(d)) !== null; ) {
      let [, b, E, A] = f;
      if (b = parseInt(b, 10), b in u) {
        if (b === 0)
          break;
        continue;
      }
      u[b] = [E, A];
    }
    const g = [];
    for (let b = 0; b < u.length && b in u; ++b) {
      let [E, A] = u[b];
      A = a(A), E && (A = unescape(A), b === 0 && (A = h(A))), g.push(A);
    }
    return g.join("");
  }
  function a(d) {
    if (d.startsWith('"')) {
      const u = d.slice(1).split('\\"');
      for (let f = 0; f < u.length; ++f) {
        const p = u[f].indexOf('"');
        p !== -1 && (u[f] = u[f].slice(0, p), u.length = f + 1), u[f] = u[f].replaceAll(/\\(.)/g, "$1");
      }
      d = u.join('"');
    }
    return d;
  }
  function h(d) {
    const u = d.indexOf("'");
    if (u === -1)
      return d;
    const f = d.slice(0, u), g = d.slice(u + 1).replace(/^[^']*'/, "");
    return i(f, g);
  }
  function c(d) {
    return !d.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(d) ? d : d.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(u, f, p, g) {
      if (p === "q" || p === "Q")
        return g = g.replaceAll("_", " "), g = g.replaceAll(/=([0-9a-fA-F]{2})/g, function(b, E) {
          return String.fromCharCode(parseInt(E, 16));
        }), i(f, g);
      try {
        g = atob(g);
      } catch {
      }
      return i(f, g);
    });
  }
  return "";
}
function Xp(l, e) {
  const t = new Headers();
  if (!l || !e || typeof e != "object")
    return t;
  for (const s in e) {
    const i = e[s];
    i !== void 0 && t.append(s, i);
  }
  return t;
}
function Kp({
  responseHeaders: l,
  isHttp: e,
  rangeChunkSize: t,
  disableRange: s
}) {
  const i = {
    allowRangeRequests: !1,
    suggestedLength: void 0
  }, n = parseInt(l.get("Content-Length"), 10);
  return !Number.isInteger(n) || (i.suggestedLength = n, n <= 2 * t) || s || !e || l.get("Accept-Ranges") !== "bytes" || (l.get("Content-Encoding") || "identity") !== "identity" || (i.allowRangeRequests = !0), i;
}
function Yp(l) {
  const e = l.get("Content-Disposition");
  if (e) {
    let t = mA(e);
    if (t.includes("%"))
      try {
        t = decodeURIComponent(t);
      } catch {
      }
    if (Up(t))
      return t;
  }
  return null;
}
function bu(l, e) {
  return l === 404 || l === 0 && e.startsWith("file:") ? new ba('Missing PDF "' + e + '".') : new pu(`Unexpected server response (${l}) while retrieving PDF "${e}".`, l);
}
function ev(l) {
  return l === 200 || l === 206;
}
function sv(l, e, t) {
  return {
    method: "GET",
    headers: l,
    signal: t.signal,
    mode: "cors",
    credentials: e ? "include" : "same-origin",
    redirect: "follow"
  };
}
function iv(l) {
  return l instanceof Uint8Array ? l.buffer : l instanceof ArrayBuffer ? l : (nt(`getArrayBuffer - unexpected data format: ${l}`), new Uint8Array(l).buffer);
}
class wg {
  constructor(e) {
    this.source = e, this.isHttp = /^https?:/i.test(e.url), this.headers = Xp(this.isHttp, e.httpHeaders), this._fullRequestReader = null, this._rangeRequestReaders = [];
  }
  get _progressiveDataLength() {
    var e;
    return ((e = this._fullRequestReader) == null ? void 0 : e._loaded) ?? 0;
  }
  getFullReader() {
    return Qt(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."), this._fullRequestReader = new vA(this), this._fullRequestReader;
  }
  getRangeReader(e, t) {
    if (t <= this._progressiveDataLength)
      return null;
    const s = new bA(this, e, t);
    return this._rangeRequestReaders.push(s), s;
  }
  cancelAllRequests(e) {
    var t;
    (t = this._fullRequestReader) == null || t.cancel(e);
    for (const s of this._rangeRequestReaders.slice(0))
      s.cancel(e);
  }
}
class vA {
  constructor(e) {
    this._stream = e, this._reader = null, this._loaded = 0, this._filename = null;
    const t = e.source;
    this._withCredentials = t.withCredentials || !1, this._contentLength = t.length, this._headersCapability = Promise.withResolvers(), this._disableRange = t.disableRange || !1, this._rangeChunkSize = t.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._abortController = new AbortController(), this._isStreamingSupported = !t.disableStream, this._isRangeSupported = !t.disableRange;
    const s = new Headers(e.headers), i = t.url;
    fetch(i, sv(s, this._withCredentials, this._abortController)).then((n) => {
      if (!ev(n.status))
        throw bu(n.status, i);
      this._reader = n.body.getReader(), this._headersCapability.resolve();
      const r = n.headers, {
        allowRangeRequests: a,
        suggestedLength: h
      } = Kp({
        responseHeaders: r,
        isHttp: e.isHttp,
        rangeChunkSize: this._rangeChunkSize,
        disableRange: this._disableRange
      });
      this._isRangeSupported = a, this._contentLength = h || this._contentLength, this._filename = Yp(r), !this._isStreamingSupported && this._isRangeSupported && this.cancel(new ya("Streaming is disabled."));
    }).catch(this._headersCapability.reject), this.onProgress = null;
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  get filename() {
    return this._filename;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var s;
    await this._headersCapability.promise;
    const {
      value: e,
      done: t
    } = await this._reader.read();
    return t ? {
      value: e,
      done: t
    } : (this._loaded += e.byteLength, (s = this.onProgress) == null || s.call(this, {
      loaded: this._loaded,
      total: this._contentLength
    }), {
      value: iv(e),
      done: !1
    });
  }
  cancel(e) {
    var t;
    (t = this._reader) == null || t.cancel(e), this._abortController.abort();
  }
}
class bA {
  constructor(e, t, s) {
    this._stream = e, this._reader = null, this._loaded = 0;
    const i = e.source;
    this._withCredentials = i.withCredentials || !1, this._readCapability = Promise.withResolvers(), this._isStreamingSupported = !i.disableStream, this._abortController = new AbortController();
    const n = new Headers(e.headers);
    n.append("Range", `bytes=${t}-${s - 1}`);
    const r = i.url;
    fetch(r, sv(n, this._withCredentials, this._abortController)).then((a) => {
      if (!ev(a.status))
        throw bu(a.status, r);
      this._readCapability.resolve(), this._reader = a.body.getReader();
    }).catch(this._readCapability.reject), this.onProgress = null;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var s;
    await this._readCapability.promise;
    const {
      value: e,
      done: t
    } = await this._reader.read();
    return t ? {
      value: e,
      done: t
    } : (this._loaded += e.byteLength, (s = this.onProgress) == null || s.call(this, {
      loaded: this._loaded
    }), {
      value: iv(e),
      done: !1
    });
  }
  cancel(e) {
    var t;
    (t = this._reader) == null || t.cancel(e), this._abortController.abort();
  }
}
const Cu = 200, Ru = 206;
function yA(l) {
  const e = l.response;
  return typeof e != "string" ? e : gu(e).buffer;
}
class AA {
  constructor({
    url: e,
    httpHeaders: t,
    withCredentials: s
  }) {
    this.url = e, this.isHttp = /^https?:/i.test(e), this.headers = Xp(this.isHttp, t), this.withCredentials = s || !1, this.currXhrId = 0, this.pendingRequests = /* @__PURE__ */ Object.create(null);
  }
  requestRange(e, t, s) {
    const i = {
      begin: e,
      end: t
    };
    for (const n in s)
      i[n] = s[n];
    return this.request(i);
  }
  requestFull(e) {
    return this.request(e);
  }
  request(e) {
    const t = new XMLHttpRequest(), s = this.currXhrId++, i = this.pendingRequests[s] = {
      xhr: t
    };
    t.open("GET", this.url), t.withCredentials = this.withCredentials;
    for (const [n, r] of this.headers)
      t.setRequestHeader(n, r);
    return this.isHttp && "begin" in e && "end" in e ? (t.setRequestHeader("Range", `bytes=${e.begin}-${e.end - 1}`), i.expectedStatus = Ru) : i.expectedStatus = Cu, t.responseType = "arraybuffer", e.onError && (t.onerror = function(n) {
      e.onError(t.status);
    }), t.onreadystatechange = this.onStateChange.bind(this, s), t.onprogress = this.onProgress.bind(this, s), i.onHeadersReceived = e.onHeadersReceived, i.onDone = e.onDone, i.onError = e.onError, i.onProgress = e.onProgress, t.send(null), s;
  }
  onProgress(e, t) {
    var i;
    const s = this.pendingRequests[e];
    s && ((i = s.onProgress) == null || i.call(s, t));
  }
  onStateChange(e, t) {
    var h, c, d;
    const s = this.pendingRequests[e];
    if (!s)
      return;
    const i = s.xhr;
    if (i.readyState >= 2 && s.onHeadersReceived && (s.onHeadersReceived(), delete s.onHeadersReceived), i.readyState !== 4 || !(e in this.pendingRequests))
      return;
    if (delete this.pendingRequests[e], i.status === 0 && this.isHttp) {
      (h = s.onError) == null || h.call(s, i.status);
      return;
    }
    const n = i.status || Cu;
    if (!(n === Cu && s.expectedStatus === Ru) && n !== s.expectedStatus) {
      (c = s.onError) == null || c.call(s, i.status);
      return;
    }
    const a = yA(i);
    if (n === Ru) {
      const u = i.getResponseHeader("Content-Range"), f = /bytes (\d+)-(\d+)\/(\d+)/.exec(u);
      s.onDone({
        begin: parseInt(f[1], 10),
        chunk: a
      });
    } else a ? s.onDone({
      begin: 0,
      chunk: a
    }) : (d = s.onError) == null || d.call(s, i.status);
  }
  getRequestXhr(e) {
    return this.pendingRequests[e].xhr;
  }
  isPendingRequest(e) {
    return e in this.pendingRequests;
  }
  abortRequest(e) {
    const t = this.pendingRequests[e].xhr;
    delete this.pendingRequests[e], t.abort();
  }
}
class EA {
  constructor(e) {
    this._source = e, this._manager = new AA(e), this._rangeChunkSize = e.rangeChunkSize, this._fullRequestReader = null, this._rangeRequestReaders = [];
  }
  _onRangeRequestReaderClosed(e) {
    const t = this._rangeRequestReaders.indexOf(e);
    t >= 0 && this._rangeRequestReaders.splice(t, 1);
  }
  getFullReader() {
    return Qt(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."), this._fullRequestReader = new wA(this._manager, this._source), this._fullRequestReader;
  }
  getRangeReader(e, t) {
    const s = new xA(this._manager, e, t);
    return s.onClosed = this._onRangeRequestReaderClosed.bind(this), this._rangeRequestReaders.push(s), s;
  }
  cancelAllRequests(e) {
    var t;
    (t = this._fullRequestReader) == null || t.cancel(e);
    for (const s of this._rangeRequestReaders.slice(0))
      s.cancel(e);
  }
}
class wA {
  constructor(e, t) {
    this._manager = e;
    const s = {
      onHeadersReceived: this._onHeadersReceived.bind(this),
      onDone: this._onDone.bind(this),
      onError: this._onError.bind(this),
      onProgress: this._onProgress.bind(this)
    };
    this._url = t.url, this._fullRequestId = e.requestFull(s), this._headersCapability = Promise.withResolvers(), this._disableRange = t.disableRange || !1, this._contentLength = t.length, this._rangeChunkSize = t.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !1, this._isRangeSupported = !1, this._cachedChunks = [], this._requests = [], this._done = !1, this._storedError = void 0, this._filename = null, this.onProgress = null;
  }
  _onHeadersReceived() {
    const e = this._fullRequestId, t = this._manager.getRequestXhr(e), s = new Headers(t.getAllResponseHeaders().trim().split(/[\r\n]+/).map((r) => {
      const [a, ...h] = r.split(": ");
      return [a, h.join(": ")];
    })), {
      allowRangeRequests: i,
      suggestedLength: n
    } = Kp({
      responseHeaders: s,
      isHttp: this._manager.isHttp,
      rangeChunkSize: this._rangeChunkSize,
      disableRange: this._disableRange
    });
    i && (this._isRangeSupported = !0), this._contentLength = n || this._contentLength, this._filename = Yp(s), this._isRangeSupported && this._manager.abortRequest(e), this._headersCapability.resolve();
  }
  _onDone(e) {
    if (e && (this._requests.length > 0 ? this._requests.shift().resolve({
      value: e.chunk,
      done: !1
    }) : this._cachedChunks.push(e.chunk)), this._done = !0, !(this._cachedChunks.length > 0)) {
      for (const t of this._requests)
        t.resolve({
          value: void 0,
          done: !0
        });
      this._requests.length = 0;
    }
  }
  _onError(e) {
    this._storedError = bu(e, this._url), this._headersCapability.reject(this._storedError);
    for (const t of this._requests)
      t.reject(this._storedError);
    this._requests.length = 0, this._cachedChunks.length = 0;
  }
  _onProgress(e) {
    var t;
    (t = this.onProgress) == null || t.call(this, {
      loaded: e.loaded,
      total: e.lengthComputable ? e.total : this._contentLength
    });
  }
  get filename() {
    return this._filename;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  get contentLength() {
    return this._contentLength;
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  async read() {
    if (this._storedError)
      throw this._storedError;
    if (this._cachedChunks.length > 0)
      return {
        value: this._cachedChunks.shift(),
        done: !1
      };
    if (this._done)
      return {
        value: void 0,
        done: !0
      };
    const e = Promise.withResolvers();
    return this._requests.push(e), e.promise;
  }
  cancel(e) {
    this._done = !0, this._headersCapability.reject(e);
    for (const t of this._requests)
      t.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0, this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId), this._fullRequestReader = null;
  }
}
class xA {
  constructor(e, t, s) {
    this._manager = e;
    const i = {
      onDone: this._onDone.bind(this),
      onError: this._onError.bind(this),
      onProgress: this._onProgress.bind(this)
    };
    this._url = e.url, this._requestId = e.requestRange(t, s, i), this._requests = [], this._queuedChunk = null, this._done = !1, this._storedError = void 0, this.onProgress = null, this.onClosed = null;
  }
  _close() {
    var e;
    (e = this.onClosed) == null || e.call(this, this);
  }
  _onDone(e) {
    const t = e.chunk;
    this._requests.length > 0 ? this._requests.shift().resolve({
      value: t,
      done: !1
    }) : this._queuedChunk = t, this._done = !0;
    for (const s of this._requests)
      s.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0, this._close();
  }
  _onError(e) {
    this._storedError = bu(e, this._url);
    for (const t of this._requests)
      t.reject(this._storedError);
    this._requests.length = 0, this._queuedChunk = null;
  }
  _onProgress(e) {
    var t;
    this.isStreamingSupported || (t = this.onProgress) == null || t.call(this, {
      loaded: e.loaded
    });
  }
  get isStreamingSupported() {
    return !1;
  }
  async read() {
    if (this._storedError)
      throw this._storedError;
    if (this._queuedChunk !== null) {
      const t = this._queuedChunk;
      return this._queuedChunk = null, {
        value: t,
        done: !1
      };
    }
    if (this._done)
      return {
        value: void 0,
        done: !0
      };
    const e = Promise.withResolvers();
    return this._requests.push(e), e.promise;
  }
  cancel(e) {
    this._done = !0;
    for (const t of this._requests)
      t.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0, this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId), this._close();
  }
}
const SA = /^[a-z][a-z0-9\-+.]+:/i;
function TA(l) {
  if (SA.test(l))
    return new URL(l);
  const e = $n.get("url");
  return new URL(e.pathToFileURL(l));
}
function nv(l, e, t) {
  return l.protocol === "http:" ? $n.get("http").request(l, {
    headers: e
  }, t) : $n.get("https").request(l, {
    headers: e
  }, t);
}
class PA {
  constructor(e) {
    this.source = e, this.url = TA(e.url), this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:", this.isFsUrl = this.url.protocol === "file:", this.headers = Xp(this.isHttp, e.httpHeaders), this._fullRequestReader = null, this._rangeRequestReaders = [];
  }
  get _progressiveDataLength() {
    var e;
    return ((e = this._fullRequestReader) == null ? void 0 : e._loaded) ?? 0;
  }
  getFullReader() {
    return Qt(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."), this._fullRequestReader = this.isFsUrl ? new IA(this) : new CA(this), this._fullRequestReader;
  }
  getRangeReader(e, t) {
    if (t <= this._progressiveDataLength)
      return null;
    const s = this.isFsUrl ? new LA(this, e, t) : new RA(this, e, t);
    return this._rangeRequestReaders.push(s), s;
  }
  cancelAllRequests(e) {
    var t;
    (t = this._fullRequestReader) == null || t.cancel(e);
    for (const s of this._rangeRequestReaders.slice(0))
      s.cancel(e);
  }
}
class rv {
  constructor(e) {
    this._url = e.url, this._done = !1, this._storedError = null, this.onProgress = null;
    const t = e.source;
    this._contentLength = t.length, this._loaded = 0, this._filename = null, this._disableRange = t.disableRange || !1, this._rangeChunkSize = t.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !t.disableStream, this._isRangeSupported = !t.disableRange, this._readableStream = null, this._readCapability = Promise.withResolvers(), this._headersCapability = Promise.withResolvers();
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  get filename() {
    return this._filename;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var s;
    if (await this._readCapability.promise, this._done)
      return {
        value: void 0,
        done: !0
      };
    if (this._storedError)
      throw this._storedError;
    const e = this._readableStream.read();
    return e === null ? (this._readCapability = Promise.withResolvers(), this.read()) : (this._loaded += e.length, (s = this.onProgress) == null || s.call(this, {
      loaded: this._loaded,
      total: this._contentLength
    }), {
      value: new Uint8Array(e).buffer,
      done: !1
    });
  }
  cancel(e) {
    if (!this._readableStream) {
      this._error(e);
      return;
    }
    this._readableStream.destroy(e);
  }
  _error(e) {
    this._storedError = e, this._readCapability.resolve();
  }
  _setReadableStream(e) {
    this._readableStream = e, e.on("readable", () => {
      this._readCapability.resolve();
    }), e.on("end", () => {
      e.destroy(), this._done = !0, this._readCapability.resolve();
    }), e.on("error", (t) => {
      this._error(t);
    }), !this._isStreamingSupported && this._isRangeSupported && this._error(new ya("streaming is disabled")), this._storedError && this._readableStream.destroy(this._storedError);
  }
}
class av {
  constructor(e) {
    this._url = e.url, this._done = !1, this._storedError = null, this.onProgress = null, this._loaded = 0, this._readableStream = null, this._readCapability = Promise.withResolvers();
    const t = e.source;
    this._isStreamingSupported = !t.disableStream;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var s;
    if (await this._readCapability.promise, this._done)
      return {
        value: void 0,
        done: !0
      };
    if (this._storedError)
      throw this._storedError;
    const e = this._readableStream.read();
    return e === null ? (this._readCapability = Promise.withResolvers(), this.read()) : (this._loaded += e.length, (s = this.onProgress) == null || s.call(this, {
      loaded: this._loaded
    }), {
      value: new Uint8Array(e).buffer,
      done: !1
    });
  }
  cancel(e) {
    if (!this._readableStream) {
      this._error(e);
      return;
    }
    this._readableStream.destroy(e);
  }
  _error(e) {
    this._storedError = e, this._readCapability.resolve();
  }
  _setReadableStream(e) {
    this._readableStream = e, e.on("readable", () => {
      this._readCapability.resolve();
    }), e.on("end", () => {
      e.destroy(), this._done = !0, this._readCapability.resolve();
    }), e.on("error", (t) => {
      this._error(t);
    }), this._storedError && this._readableStream.destroy(this._storedError);
  }
}
class CA extends rv {
  constructor(e) {
    super(e);
    const t = Object.fromEntries(e.headers), s = (i) => {
      if (i.statusCode === 404) {
        const h = new ba(`Missing PDF "${this._url}".`);
        this._storedError = h, this._headersCapability.reject(h);
        return;
      }
      this._headersCapability.resolve(), this._setReadableStream(i);
      const n = new Headers(this._readableStream.headers), {
        allowRangeRequests: r,
        suggestedLength: a
      } = Kp({
        responseHeaders: n,
        isHttp: e.isHttp,
        rangeChunkSize: this._rangeChunkSize,
        disableRange: this._disableRange
      });
      this._isRangeSupported = r, this._contentLength = a || this._contentLength, this._filename = Yp(n);
    };
    this._request = nv(this._url, t, s), this._request.on("error", (i) => {
      this._storedError = i, this._headersCapability.reject(i);
    }), this._request.end();
  }
}
class RA extends av {
  constructor(e, t, s) {
    super(e);
    const i = Object.fromEntries(e.headers);
    i.Range = `bytes=${t}-${s - 1}`;
    const n = (r) => {
      if (r.statusCode === 404) {
        const a = new ba(`Missing PDF "${this._url}".`);
        this._storedError = a;
        return;
      }
      this._setReadableStream(r);
    };
    this._request = nv(this._url, i, n), this._request.on("error", (r) => {
      this._storedError = r;
    }), this._request.end();
  }
}
class IA extends rv {
  constructor(e) {
    super(e);
    const t = $n.get("fs");
    t.promises.lstat(this._url).then((s) => {
      this._contentLength = s.size, this._setReadableStream(t.createReadStream(this._url)), this._headersCapability.resolve();
    }, (s) => {
      s.code === "ENOENT" && (s = new ba(`Missing PDF "${this._url}".`)), this._storedError = s, this._headersCapability.reject(s);
    });
  }
}
class LA extends av {
  constructor(e, t, s) {
    super(e);
    const i = $n.get("fs");
    this._setReadableStream(i.createReadStream(this._url, {
      start: t,
      end: s - 1
    }));
  }
}
const MA = 1e5, Ce = 30, _A = 0.8;
var cm, cn, Ie, ph, gh, Ar, gi, mh, vh, Er, Za, Ja, dn, qa, bh, to, wr, yh, Ah, Dt, xr, Sr, Eh, un, eo, Ui, ov, lv, Ef, Ye, nd, wf, hv, cv;
let Af = (Dt = class {
  constructor({
    textContentSource: e,
    container: t,
    viewport: s
  }) {
    y(this, Ui);
    y(this, cn, Promise.withResolvers());
    y(this, Ie, null);
    y(this, ph, !1);
    y(this, gh, !!((cm = globalThis.FontInspector) != null && cm.enabled));
    y(this, Ar, null);
    y(this, gi, null);
    y(this, mh, 0);
    y(this, vh, 0);
    y(this, Er, null);
    y(this, Za, null);
    y(this, Ja, 0);
    y(this, dn, 0);
    y(this, qa, /* @__PURE__ */ Object.create(null));
    y(this, bh, []);
    y(this, to, null);
    y(this, wr, []);
    y(this, yh, /* @__PURE__ */ new WeakMap());
    y(this, Ah, null);
    var h;
    if (e instanceof ReadableStream)
      v(this, to, e);
    else if (typeof e == "object")
      v(this, to, new ReadableStream({
        start(c) {
          c.enqueue(e), c.close();
        }
      }));
    else
      throw new Error('No "textContentSource" parameter specified.');
    v(this, Ie, v(this, Za, t)), v(this, dn, s.scale * (globalThis.devicePixelRatio || 1)), v(this, Ja, s.rotation), v(this, gi, {
      div: null,
      properties: null,
      ctx: null
    });
    const {
      pageWidth: i,
      pageHeight: n,
      pageX: r,
      pageY: a
    } = s.rawDims;
    v(this, Ah, [1, 0, 0, -1, -r, a + n]), v(this, vh, i), v(this, mh, n), m(h = Dt, Ye, hv).call(h), pa(t, s), o(this, cn).promise.finally(() => {
      o(Dt, eo).delete(this), v(this, gi, null), v(this, qa, null);
    }).catch(() => {
    });
  }
  static get fontFamilyMap() {
    const {
      isWindows: e,
      isFirefox: t
    } = ke.platform;
    return ht(this, "fontFamilyMap", /* @__PURE__ */ new Map([["sans-serif", `${e && t ? "Calibri, " : ""}sans-serif`], ["monospace", `${e && t ? "Lucida Console, " : ""}monospace`]]));
  }
  render() {
    const e = () => {
      o(this, Er).read().then(({
        value: t,
        done: s
      }) => {
        if (s) {
          o(this, cn).resolve();
          return;
        }
        o(this, Ar) ?? v(this, Ar, t.lang), Object.assign(o(this, qa), t.styles), m(this, Ui, ov).call(this, t.items), e();
      }, o(this, cn).reject);
    };
    return v(this, Er, o(this, to).getReader()), o(Dt, eo).add(this), e(), o(this, cn).promise;
  }
  update({
    viewport: e,
    onBefore: t = null
  }) {
    var n;
    const s = e.scale * (globalThis.devicePixelRatio || 1), i = e.rotation;
    if (i !== o(this, Ja) && (t == null || t(), v(this, Ja, i), pa(o(this, Za), {
      rotation: i
    })), s !== o(this, dn)) {
      t == null || t(), v(this, dn, s);
      const r = {
        div: null,
        properties: null,
        ctx: m(n = Dt, Ye, nd).call(n, o(this, Ar))
      };
      for (const a of o(this, wr))
        r.properties = o(this, yh).get(a), r.div = a, m(this, Ui, Ef).call(this, r);
    }
  }
  cancel() {
    var t;
    const e = new ya("TextLayer task cancelled.");
    (t = o(this, Er)) == null || t.cancel(e).catch(() => {
    }), v(this, Er, null), o(this, cn).reject(e);
  }
  get textDivs() {
    return o(this, wr);
  }
  get textContentItemsStr() {
    return o(this, bh);
  }
  static cleanup() {
    if (!(o(this, eo).size > 0)) {
      o(this, xr).clear();
      for (const {
        canvas: e
      } of o(this, Sr).values())
        e.remove();
      o(this, Sr).clear();
    }
  }
}, cn = new WeakMap(), Ie = new WeakMap(), ph = new WeakMap(), gh = new WeakMap(), Ar = new WeakMap(), gi = new WeakMap(), mh = new WeakMap(), vh = new WeakMap(), Er = new WeakMap(), Za = new WeakMap(), Ja = new WeakMap(), dn = new WeakMap(), qa = new WeakMap(), bh = new WeakMap(), to = new WeakMap(), wr = new WeakMap(), yh = new WeakMap(), Ah = new WeakMap(), xr = new WeakMap(), Sr = new WeakMap(), Eh = new WeakMap(), un = new WeakMap(), eo = new WeakMap(), Ui = new WeakSet(), ov = function(e) {
  var i, n;
  if (o(this, ph))
    return;
  (n = o(this, gi)).ctx ?? (n.ctx = m(i = Dt, Ye, nd).call(i, o(this, Ar)));
  const t = o(this, wr), s = o(this, bh);
  for (const r of e) {
    if (t.length > MA) {
      nt("Ignoring additional textDivs for performance reasons."), v(this, ph, !0);
      return;
    }
    if (r.str === void 0) {
      if (r.type === "beginMarkedContentProps" || r.type === "beginMarkedContent") {
        const a = o(this, Ie);
        v(this, Ie, document.createElement("span")), o(this, Ie).classList.add("markedContent"), r.id !== null && o(this, Ie).setAttribute("id", `${r.id}`), a.append(o(this, Ie));
      } else r.type === "endMarkedContent" && v(this, Ie, o(this, Ie).parentNode);
      continue;
    }
    s.push(r.str), m(this, Ui, lv).call(this, r);
  }
}, lv = function(e) {
  var b;
  const t = document.createElement("span"), s = {
    angle: 0,
    canvasWidth: 0,
    hasText: e.str !== "",
    hasEOL: e.hasEOL,
    fontSize: 0
  };
  o(this, wr).push(t);
  const i = X.transform(o(this, Ah), e.transform);
  let n = Math.atan2(i[1], i[0]);
  const r = o(this, qa)[e.fontName];
  r.vertical && (n += Math.PI / 2);
  let a = o(this, gh) && r.fontSubstitution || r.fontFamily;
  a = Dt.fontFamilyMap.get(a) || a;
  const h = Math.hypot(i[2], i[3]), c = h * m(b = Dt, Ye, cv).call(b, a, o(this, Ar));
  let d, u;
  n === 0 ? (d = i[4], u = i[5] - c) : (d = i[4] + c * Math.sin(n), u = i[5] - c * Math.cos(n));
  const f = "calc(var(--scale-factor)*", p = t.style;
  o(this, Ie) === o(this, Za) ? (p.left = `${(100 * d / o(this, vh)).toFixed(2)}%`, p.top = `${(100 * u / o(this, mh)).toFixed(2)}%`) : (p.left = `${f}${d.toFixed(2)}px)`, p.top = `${f}${u.toFixed(2)}px)`), p.fontSize = `${f}${(o(Dt, un) * h).toFixed(2)}px)`, p.fontFamily = a, s.fontSize = h, t.setAttribute("role", "presentation"), t.textContent = e.str, t.dir = e.dir, o(this, gh) && (t.dataset.fontName = r.fontSubstitutionLoadedName || e.fontName), n !== 0 && (s.angle = n * (180 / Math.PI));
  let g = !1;
  if (e.str.length > 1)
    g = !0;
  else if (e.str !== " " && e.transform[0] !== e.transform[3]) {
    const E = Math.abs(e.transform[0]), A = Math.abs(e.transform[3]);
    E !== A && Math.max(E, A) / Math.min(E, A) > 1.5 && (g = !0);
  }
  if (g && (s.canvasWidth = r.vertical ? e.height : e.width), o(this, yh).set(t, s), o(this, gi).div = t, o(this, gi).properties = s, m(this, Ui, Ef).call(this, o(this, gi)), s.hasText && o(this, Ie).append(t), s.hasEOL) {
    const E = document.createElement("br");
    E.setAttribute("role", "presentation"), o(this, Ie).append(E);
  }
}, Ef = function(e) {
  var a;
  const {
    div: t,
    properties: s,
    ctx: i
  } = e, {
    style: n
  } = t;
  let r = "";
  if (o(Dt, un) > 1 && (r = `scale(${1 / o(Dt, un)})`), s.canvasWidth !== 0 && s.hasText) {
    const {
      fontFamily: h
    } = n, {
      canvasWidth: c,
      fontSize: d
    } = s;
    m(a = Dt, Ye, wf).call(a, i, d * o(this, dn), h);
    const {
      width: u
    } = i.measureText(t.textContent);
    u > 0 && (r = `scaleX(${c * o(this, dn) / u}) ${r}`);
  }
  s.angle !== 0 && (r = `rotate(${s.angle}deg) ${r}`), r.length > 0 && (n.transform = r);
}, Ye = new WeakSet(), nd = function(e = null) {
  let t = o(this, Sr).get(e || (e = ""));
  if (!t) {
    const s = document.createElement("canvas");
    s.className = "hiddenCanvasElement", s.lang = e, document.body.append(s), t = s.getContext("2d", {
      alpha: !1,
      willReadFrequently: !0
    }), o(this, Sr).set(e, t), o(this, Eh).set(t, {
      size: 0,
      family: ""
    });
  }
  return t;
}, wf = function(e, t, s) {
  const i = o(this, Eh).get(e);
  t === i.size && s === i.family || (e.font = `${t}px ${s}`, i.size = t, i.family = s);
}, hv = function() {
  if (o(this, un) !== null)
    return;
  const e = document.createElement("div");
  e.style.opacity = 0, e.style.lineHeight = 1, e.style.fontSize = "1px", e.style.position = "absolute", e.textContent = "X", document.body.append(e), v(this, un, e.getBoundingClientRect().height), e.remove();
}, cv = function(e, t) {
  const s = o(this, xr).get(e);
  if (s)
    return s;
  const i = m(this, Ye, nd).call(this, t);
  i.canvas.width = i.canvas.height = Ce, m(this, Ye, wf).call(this, i, Ce, e);
  const n = i.measureText("");
  let r = n.fontBoundingBoxAscent, a = Math.abs(n.fontBoundingBoxDescent);
  if (r) {
    const d = r / (r + a);
    return o(this, xr).set(e, d), i.canvas.width = i.canvas.height = 0, d;
  }
  i.strokeStyle = "red", i.clearRect(0, 0, Ce, Ce), i.strokeText("g", 0, 0);
  let h = i.getImageData(0, 0, Ce, Ce).data;
  a = 0;
  for (let d = h.length - 1 - 3; d >= 0; d -= 4)
    if (h[d] > 0) {
      a = Math.ceil(d / 4 / Ce);
      break;
    }
  i.clearRect(0, 0, Ce, Ce), i.strokeText("A", 0, Ce), h = i.getImageData(0, 0, Ce, Ce).data, r = 0;
  for (let d = 0, u = h.length; d < u; d += 4)
    if (h[d] > 0) {
      r = Ce - Math.floor(d / 4 / Ce);
      break;
    }
  i.canvas.width = i.canvas.height = 0;
  const c = r ? r / (r + a) : _A;
  return o(this, xr).set(e, c), c;
}, y(Dt, Ye), y(Dt, xr, /* @__PURE__ */ new Map()), y(Dt, Sr, /* @__PURE__ */ new Map()), y(Dt, Eh, /* @__PURE__ */ new WeakMap()), y(Dt, un, null), y(Dt, eo, /* @__PURE__ */ new Set()), Dt);
class Fl {
  static textContent(e) {
    const t = [], s = {
      items: t,
      styles: /* @__PURE__ */ Object.create(null)
    };
    function i(n) {
      var h;
      if (!n)
        return;
      let r = null;
      const a = n.name;
      if (a === "#text")
        r = n.value;
      else if (Fl.shouldBuildText(a))
        (h = n == null ? void 0 : n.attributes) != null && h.textContent ? r = n.attributes.textContent : n.value && (r = n.value);
      else return;
      if (r !== null && t.push({
        str: r
      }), !!n.children)
        for (const c of n.children)
          i(c);
    }
    return i(e), s;
  }
  static shouldBuildText(e) {
    return !(e === "textarea" || e === "input" || e === "option" || e === "select");
  }
}
const OA = 65536, NA = 100, DA = 5e3, kA = ye ? Ky : Dy, FA = ye ? Yy : wm, jA = ye ? Xy : Ny, BA = ye ? Qy : xm;
function HA(l = {}) {
  typeof l == "string" || l instanceof URL ? l = {
    url: l
  } : (l instanceof ArrayBuffer || ArrayBuffer.isView(l)) && (l = {
    data: l
  });
  const e = new xf(), {
    docId: t
  } = e, s = l.url ? $A(l.url) : null, i = l.data ? VA(l.data) : null, n = l.httpHeaders || null, r = l.withCredentials === !0, a = l.password ?? null, h = l.range instanceof dv ? l.range : null, c = Number.isInteger(l.rangeChunkSize) && l.rangeChunkSize > 0 ? l.rangeChunkSize : OA;
  let d = l.worker instanceof ad ? l.worker : null;
  const u = l.verbosity, f = typeof l.docBaseUrl == "string" && !vu(l.docBaseUrl) ? l.docBaseUrl : null, p = typeof l.cMapUrl == "string" ? l.cMapUrl : null, g = l.cMapPacked !== !1, b = l.CMapReaderFactory || FA, E = typeof l.standardFontDataUrl == "string" ? l.standardFontDataUrl : null, A = l.StandardFontDataFactory || BA, w = l.stopAtErrors !== !0, x = Number.isInteger(l.maxImageSize) && l.maxImageSize > -1 ? l.maxImageSize : -1, P = l.isEvalSupported !== !1, T = typeof l.isOffscreenCanvasSupported == "boolean" ? l.isOffscreenCanvasSupported : !ye, C = Number.isInteger(l.canvasMaxAreaInBytes) ? l.canvasMaxAreaInBytes : -1, R = typeof l.disableFontFace == "boolean" ? l.disableFontFace : ye, M = l.fontExtraProperties === !0, S = l.enableXfa === !0, I = l.ownerDocument || globalThis.document, _ = l.disableRange === !0, D = l.disableStream === !0, k = l.disableAutoFetch === !0, j = l.pdfBug === !0, H = l.CanvasFactory || kA, L = l.FilterFactory || jA, F = l.enableHWA === !0, z = h ? h.length : l.length ?? NaN, pt = typeof l.useSystemFonts == "boolean" ? l.useSystemFonts : !ye && !R, gt = typeof l.useWorkerFetch == "boolean" ? l.useWorkerFetch : b === wm && A === xm && p && E && ul(p, document.baseURI) && ul(E, document.baseURI);
  l.canvasFactory && hg("`canvasFactory`-instance option, please use `CanvasFactory` instead."), l.filterFactory && hg("`filterFactory`-instance option, please use `FilterFactory` instead.");
  const zt = null;
  wy(u);
  const bt = {
    canvasFactory: new H({
      ownerDocument: I,
      enableHWA: F
    }),
    filterFactory: new L({
      docId: t,
      ownerDocument: I
    }),
    cMapReaderFactory: gt ? null : new b({
      baseUrl: p,
      isCompressed: g
    }),
    standardFontDataFactory: gt ? null : new A({
      baseUrl: E
    })
  };
  if (!d) {
    const Pe = {
      verbosity: u,
      port: Zn.workerPort
    };
    d = Pe.port ? ad.fromPort(Pe) : new ad(Pe), e._worker = d;
  }
  const Et = {
    docId: t,
    apiVersion: "4.7.76",
    data: i,
    password: a,
    disableAutoFetch: k,
    rangeChunkSize: c,
    length: z,
    docBaseUrl: f,
    enableXfa: S,
    evaluatorOptions: {
      maxImageSize: x,
      disableFontFace: R,
      ignoreErrors: w,
      isEvalSupported: P,
      isOffscreenCanvasSupported: T,
      canvasMaxAreaInBytes: C,
      fontExtraProperties: M,
      useSystemFonts: pt,
      cMapUrl: gt ? p : null,
      standardFontDataUrl: gt ? E : null
    }
  }, xs = {
    disableFontFace: R,
    fontExtraProperties: M,
    ownerDocument: I,
    pdfBug: j,
    styleElement: zt,
    loadingParams: {
      disableAutoFetch: k,
      enableXfa: S
    }
  };
  return d.promise.then(function() {
    if (e.destroyed)
      throw new Error("Loading aborted");
    if (d.destroyed)
      throw new Error("Worker was destroyed");
    const Pe = d.messageHandler.sendWithPromise("GetDocRequest", Et, i ? [i.buffer] : null);
    let U;
    if (h)
      U = new fA(h, {
        disableRange: _,
        disableStream: D
      });
    else if (!i) {
      if (!s)
        throw new Error("getDocument - no `url` parameter provided.");
      let N;
      ye ? N = typeof fetch < "u" && typeof Response < "u" && "body" in Response.prototype && ul(s) ? wg : PA : N = ul(s) ? wg : EA, U = new N({
        url: s,
        length: z,
        httpHeaders: n,
        withCredentials: r,
        rangeChunkSize: c,
        disableRange: _,
        disableStream: D
      });
    }
    return Pe.then((N) => {
      if (e.destroyed)
        throw new Error("Loading aborted");
      if (d.destroyed)
        throw new Error("Worker was destroyed");
      const V = new gl(t, N, d.port), st = new GA(V, e, U, xs, bt);
      e._transport = st, V.send("Ready", null);
    });
  }).catch(e._capability.reject), e;
}
function $A(l) {
  if (l instanceof URL)
    return l.href;
  try {
    return new URL(l, window.location).href;
  } catch {
    if (ye && typeof l == "string")
      return l;
  }
  throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
}
function VA(l) {
  if (ye && typeof Buffer < "u" && l instanceof Buffer)
    throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
  if (l instanceof Uint8Array && l.byteLength === l.buffer.byteLength)
    return l;
  if (typeof l == "string")
    return gu(l);
  if (l instanceof ArrayBuffer || ArrayBuffer.isView(l) || typeof l == "object" && !isNaN(l == null ? void 0 : l.length))
    return new Uint8Array(l);
  throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
}
function xg(l) {
  return typeof l == "object" && Number.isInteger(l == null ? void 0 : l.num) && l.num >= 0 && Number.isInteger(l == null ? void 0 : l.gen) && l.gen >= 0;
}
var tu;
const eu = class eu {
  constructor() {
    this._capability = Promise.withResolvers(), this._transport = null, this._worker = null, this.docId = `d${de(eu, tu)._++}`, this.destroyed = !1, this.onPassword = null, this.onProgress = null;
  }
  get promise() {
    return this._capability.promise;
  }
  async destroy() {
    var e, t, s;
    this.destroyed = !0;
    try {
      (e = this._worker) != null && e.port && (this._worker._pendingDestroy = !0), await ((t = this._transport) == null ? void 0 : t.destroy());
    } catch (i) {
      throw (s = this._worker) != null && s.port && delete this._worker._pendingDestroy, i;
    }
    this._transport = null, this._worker && (this._worker.destroy(), this._worker = null);
  }
};
tu = new WeakMap(), y(eu, tu, 0);
let xf = eu, dv = class {
  constructor(e, t, s = !1, i = null) {
    this.length = e, this.initialData = t, this.progressiveDone = s, this.contentDispositionFilename = i, this._rangeListeners = [], this._progressListeners = [], this._progressiveReadListeners = [], this._progressiveDoneListeners = [], this._readyCapability = Promise.withResolvers();
  }
  addRangeListener(e) {
    this._rangeListeners.push(e);
  }
  addProgressListener(e) {
    this._progressListeners.push(e);
  }
  addProgressiveReadListener(e) {
    this._progressiveReadListeners.push(e);
  }
  addProgressiveDoneListener(e) {
    this._progressiveDoneListeners.push(e);
  }
  onDataRange(e, t) {
    for (const s of this._rangeListeners)
      s(e, t);
  }
  onDataProgress(e, t) {
    this._readyCapability.promise.then(() => {
      for (const s of this._progressListeners)
        s(e, t);
    });
  }
  onDataProgressiveRead(e) {
    this._readyCapability.promise.then(() => {
      for (const t of this._progressiveReadListeners)
        t(e);
    });
  }
  onDataProgressiveDone() {
    this._readyCapability.promise.then(() => {
      for (const e of this._progressiveDoneListeners)
        e();
    });
  }
  transportReady() {
    this._readyCapability.resolve();
  }
  requestDataRange(e, t) {
    Ut("Abstract method PDFDataRangeTransport.requestDataRange");
  }
  abort() {
  }
};
class UA {
  constructor(e, t) {
    this._pdfInfo = e, this._transport = t;
  }
  get annotationStorage() {
    return this._transport.annotationStorage;
  }
  get canvasFactory() {
    return this._transport.canvasFactory;
  }
  get filterFactory() {
    return this._transport.filterFactory;
  }
  get numPages() {
    return this._pdfInfo.numPages;
  }
  get fingerprints() {
    return this._pdfInfo.fingerprints;
  }
  get isPureXfa() {
    return ht(this, "isPureXfa", !!this._transport._htmlForXfa);
  }
  get allXfaHtml() {
    return this._transport._htmlForXfa;
  }
  getPage(e) {
    return this._transport.getPage(e);
  }
  getPageIndex(e) {
    return this._transport.getPageIndex(e);
  }
  getDestinations() {
    return this._transport.getDestinations();
  }
  getDestination(e) {
    return this._transport.getDestination(e);
  }
  getPageLabels() {
    return this._transport.getPageLabels();
  }
  getPageLayout() {
    return this._transport.getPageLayout();
  }
  getPageMode() {
    return this._transport.getPageMode();
  }
  getViewerPreferences() {
    return this._transport.getViewerPreferences();
  }
  getOpenAction() {
    return this._transport.getOpenAction();
  }
  getAttachments() {
    return this._transport.getAttachments();
  }
  getJSActions() {
    return this._transport.getDocJSActions();
  }
  getOutline() {
    return this._transport.getOutline();
  }
  getOptionalContentConfig({
    intent: e = "display"
  } = {}) {
    const {
      renderingIntent: t
    } = this._transport.getRenderingIntent(e);
    return this._transport.getOptionalContentConfig(t);
  }
  getPermissions() {
    return this._transport.getPermissions();
  }
  getMetadata() {
    return this._transport.getMetadata();
  }
  getMarkInfo() {
    return this._transport.getMarkInfo();
  }
  getData() {
    return this._transport.getData();
  }
  saveDocument() {
    return this._transport.saveDocument();
  }
  getDownloadInfo() {
    return this._transport.downloadInfoCapability.promise;
  }
  cleanup(e = !1) {
    return this._transport.startCleanup(e || this.isPureXfa);
  }
  destroy() {
    return this.loadingTask.destroy();
  }
  cachedPageNumber(e) {
    return this._transport.cachedPageNumber(e);
  }
  get loadingParams() {
    return this._transport.loadingParams;
  }
  get loadingTask() {
    return this._transport.loadingTask;
  }
  getFieldObjects() {
    return this._transport.getFieldObjects();
  }
  hasJSActions() {
    return this._transport.hasJSActions();
  }
  getCalculationOrderIds() {
    return this._transport.getCalculationOrderIds();
  }
}
var fn, mi, rs, Pa, rd;
class zA {
  constructor(e, t, s, i = !1) {
    y(this, rs);
    y(this, fn, null);
    y(this, mi, !1);
    this._pageIndex = e, this._pageInfo = t, this._transport = s, this._stats = i ? new lg() : null, this._pdfBug = i, this.commonObjs = s.commonObjs, this.objs = new uv(), this._maybeCleanupAfterRender = !1, this._intentStates = /* @__PURE__ */ new Map(), this.destroyed = !1;
  }
  get pageNumber() {
    return this._pageIndex + 1;
  }
  get rotate() {
    return this._pageInfo.rotate;
  }
  get ref() {
    return this._pageInfo.ref;
  }
  get userUnit() {
    return this._pageInfo.userUnit;
  }
  get view() {
    return this._pageInfo.view;
  }
  getViewport({
    scale: e,
    rotation: t = this.rotate,
    offsetX: s = 0,
    offsetY: i = 0,
    dontFlip: n = !1
  } = {}) {
    return new _c({
      viewBox: this.view,
      scale: e,
      rotation: t,
      offsetX: s,
      offsetY: i,
      dontFlip: n
    });
  }
  getAnnotations({
    intent: e = "display"
  } = {}) {
    const {
      renderingIntent: t
    } = this._transport.getRenderingIntent(e);
    return this._transport.getAnnotations(this._pageIndex, t);
  }
  getJSActions() {
    return this._transport.getPageJSActions(this._pageIndex);
  }
  get filterFactory() {
    return this._transport.filterFactory;
  }
  get isPureXfa() {
    return ht(this, "isPureXfa", !!this._transport._htmlForXfa);
  }
  async getXfa() {
    var e;
    return ((e = this._transport._htmlForXfa) == null ? void 0 : e.children[this._pageIndex]) || null;
  }
  render({
    canvasContext: e,
    viewport: t,
    intent: s = "display",
    annotationMode: i = Zi.ENABLE,
    transform: n = null,
    background: r = null,
    optionalContentConfigPromise: a = null,
    annotationCanvasMap: h = null,
    pageColors: c = null,
    printAnnotationStorage: d = null,
    isEditing: u = !1
  }) {
    var P, T;
    (P = this._stats) == null || P.time("Overall");
    const f = this._transport.getRenderingIntent(s, i, d, u), {
      renderingIntent: p,
      cacheKey: g
    } = f;
    v(this, mi, !1), m(this, rs, rd).call(this), a || (a = this._transport.getOptionalContentConfig(p));
    let b = this._intentStates.get(g);
    b || (b = /* @__PURE__ */ Object.create(null), this._intentStates.set(g, b)), b.streamReaderCancelTimeout && (clearTimeout(b.streamReaderCancelTimeout), b.streamReaderCancelTimeout = null);
    const E = !!(p & Xe.PRINT);
    b.displayReadyCapability || (b.displayReadyCapability = Promise.withResolvers(), b.operatorList = {
      fnArray: [],
      argsArray: [],
      lastChunk: !1,
      separateAnnots: null
    }, (T = this._stats) == null || T.time("Page Request"), this._pumpOperatorList(f));
    const A = (C) => {
      var R;
      b.renderTasks.delete(w), (this._maybeCleanupAfterRender || E) && v(this, mi, !0), m(this, rs, Pa).call(this, !E), C ? (w.capability.reject(C), this._abortOperatorList({
        intentState: b,
        reason: C instanceof Error ? C : new Error(C)
      })) : w.capability.resolve(), this._stats && (this._stats.timeEnd("Rendering"), this._stats.timeEnd("Overall"), (R = globalThis.Stats) != null && R.enabled && globalThis.Stats.add(this.pageNumber, this._stats));
    }, w = new Tf({
      callback: A,
      params: {
        canvasContext: e,
        viewport: t,
        transform: n,
        background: r
      },
      objs: this.objs,
      commonObjs: this.commonObjs,
      annotationCanvasMap: h,
      operatorList: b.operatorList,
      pageIndex: this._pageIndex,
      canvasFactory: this._transport.canvasFactory,
      filterFactory: this._transport.filterFactory,
      useRequestAnimationFrame: !E,
      pdfBug: this._pdfBug,
      pageColors: c
    });
    (b.renderTasks || (b.renderTasks = /* @__PURE__ */ new Set())).add(w);
    const x = w.task;
    return Promise.all([b.displayReadyCapability.promise, a]).then(([C, R]) => {
      var M;
      if (this.destroyed) {
        A();
        return;
      }
      if ((M = this._stats) == null || M.time("Rendering"), !(R.renderingIntent & p))
        throw new Error("Must use the same `intent`-argument when calling the `PDFPageProxy.render` and `PDFDocumentProxy.getOptionalContentConfig` methods.");
      w.initializeGraphics({
        transparency: C,
        optionalContentConfig: R
      }), w.operatorListChanged();
    }).catch(A), x;
  }
  getOperatorList({
    intent: e = "display",
    annotationMode: t = Zi.ENABLE,
    printAnnotationStorage: s = null,
    isEditing: i = !1
  } = {}) {
    var c;
    function n() {
      a.operatorList.lastChunk && (a.opListReadCapability.resolve(a.operatorList), a.renderTasks.delete(h));
    }
    const r = this._transport.getRenderingIntent(e, t, s, i, !0);
    let a = this._intentStates.get(r.cacheKey);
    a || (a = /* @__PURE__ */ Object.create(null), this._intentStates.set(r.cacheKey, a));
    let h;
    return a.opListReadCapability || (h = /* @__PURE__ */ Object.create(null), h.operatorListChanged = n, a.opListReadCapability = Promise.withResolvers(), (a.renderTasks || (a.renderTasks = /* @__PURE__ */ new Set())).add(h), a.operatorList = {
      fnArray: [],
      argsArray: [],
      lastChunk: !1,
      separateAnnots: null
    }, (c = this._stats) == null || c.time("Page Request"), this._pumpOperatorList(r)), a.opListReadCapability.promise;
  }
  streamTextContent({
    includeMarkedContent: e = !1,
    disableNormalization: t = !1
  } = {}) {
    return this._transport.messageHandler.sendWithStream("GetTextContent", {
      pageIndex: this._pageIndex,
      includeMarkedContent: e === !0,
      disableNormalization: t === !0
    }, {
      highWaterMark: 100,
      size(i) {
        return i.items.length;
      }
    });
  }
  getTextContent(e = {}) {
    if (this._transport._htmlForXfa)
      return this.getXfa().then((s) => Fl.textContent(s));
    const t = this.streamTextContent(e);
    return new Promise(function(s, i) {
      function n() {
        r.read().then(function({
          value: h,
          done: c
        }) {
          if (c) {
            s(a);
            return;
          }
          a.lang ?? (a.lang = h.lang), Object.assign(a.styles, h.styles), a.items.push(...h.items), n();
        }, i);
      }
      const r = t.getReader(), a = {
        items: [],
        styles: /* @__PURE__ */ Object.create(null),
        lang: null
      };
      n();
    });
  }
  getStructTree() {
    return this._transport.getStructTree(this._pageIndex);
  }
  _destroy() {
    this.destroyed = !0;
    const e = [];
    for (const t of this._intentStates.values())
      if (this._abortOperatorList({
        intentState: t,
        reason: new Error("Page was destroyed."),
        force: !0
      }), !t.opListReadCapability)
        for (const s of t.renderTasks)
          e.push(s.completed), s.cancel();
    return this.objs.clear(), v(this, mi, !1), m(this, rs, rd).call(this), Promise.all(e);
  }
  cleanup(e = !1) {
    v(this, mi, !0);
    const t = m(this, rs, Pa).call(this, !1);
    return e && t && this._stats && (this._stats = new lg()), t;
  }
  _startRenderPage(e, t) {
    var i, n;
    const s = this._intentStates.get(t);
    s && ((i = this._stats) == null || i.timeEnd("Page Request"), (n = s.displayReadyCapability) == null || n.resolve(e));
  }
  _renderPageChunk(e, t) {
    for (let s = 0, i = e.length; s < i; s++)
      t.operatorList.fnArray.push(e.fnArray[s]), t.operatorList.argsArray.push(e.argsArray[s]);
    t.operatorList.lastChunk = e.lastChunk, t.operatorList.separateAnnots = e.separateAnnots;
    for (const s of t.renderTasks)
      s.operatorListChanged();
    e.lastChunk && m(this, rs, Pa).call(this, !0);
  }
  _pumpOperatorList({
    renderingIntent: e,
    cacheKey: t,
    annotationStorageSerializable: s,
    modifiedIds: i
  }) {
    const {
      map: n,
      transfer: r
    } = s, h = this._transport.messageHandler.sendWithStream("GetOperatorList", {
      pageIndex: this._pageIndex,
      intent: e,
      cacheKey: t,
      annotationStorage: n,
      modifiedIds: i
    }, r).getReader(), c = this._intentStates.get(t);
    c.streamReader = h;
    const d = () => {
      h.read().then(({
        value: u,
        done: f
      }) => {
        if (f) {
          c.streamReader = null;
          return;
        }
        this._transport.destroyed || (this._renderPageChunk(u, c), d());
      }, (u) => {
        if (c.streamReader = null, !this._transport.destroyed) {
          if (c.operatorList) {
            c.operatorList.lastChunk = !0;
            for (const f of c.renderTasks)
              f.operatorListChanged();
            m(this, rs, Pa).call(this, !0);
          }
          if (c.displayReadyCapability)
            c.displayReadyCapability.reject(u);
          else if (c.opListReadCapability)
            c.opListReadCapability.reject(u);
          else
            throw u;
        }
      });
    };
    d();
  }
  _abortOperatorList({
    intentState: e,
    reason: t,
    force: s = !1
  }) {
    if (e.streamReader) {
      if (e.streamReaderCancelTimeout && (clearTimeout(e.streamReaderCancelTimeout), e.streamReaderCancelTimeout = null), !s) {
        if (e.renderTasks.size > 0)
          return;
        if (t instanceof Vp) {
          let i = NA;
          t.extraDelay > 0 && t.extraDelay < 1e3 && (i += t.extraDelay), e.streamReaderCancelTimeout = setTimeout(() => {
            e.streamReaderCancelTimeout = null, this._abortOperatorList({
              intentState: e,
              reason: t,
              force: !0
            });
          }, i);
          return;
        }
      }
      if (e.streamReader.cancel(new ya(t.message)).catch(() => {
      }), e.streamReader = null, !this._transport.destroyed) {
        for (const [i, n] of this._intentStates)
          if (n === e) {
            this._intentStates.delete(i);
            break;
          }
        this.cleanup();
      }
    }
  }
  get stats() {
    return this._stats;
  }
}
fn = new WeakMap(), mi = new WeakMap(), rs = new WeakSet(), Pa = function(e = !1) {
  if (m(this, rs, rd).call(this), !o(this, mi) || this.destroyed)
    return !1;
  if (e)
    return v(this, fn, setTimeout(() => {
      v(this, fn, null), m(this, rs, Pa).call(this, !1);
    }, DA)), !1;
  for (const {
    renderTasks: t,
    operatorList: s
  } of this._intentStates.values())
    if (t.size > 0 || !s.lastChunk)
      return !1;
  return this._intentStates.clear(), this.objs.clear(), v(this, mi, !1), !0;
}, rd = function() {
  o(this, fn) && (clearTimeout(o(this, fn)), v(this, fn, null));
};
var Tr, su;
class WA {
  constructor() {
    y(this, Tr, /* @__PURE__ */ new Set());
    y(this, su, Promise.resolve());
  }
  postMessage(e, t) {
    const s = {
      data: structuredClone(e, t ? {
        transfer: t
      } : null)
    };
    o(this, su).then(() => {
      for (const i of o(this, Tr))
        i.call(this, s);
    });
  }
  addEventListener(e, t) {
    o(this, Tr).add(t);
  }
  removeEventListener(e, t) {
    o(this, Tr).delete(t);
  }
  terminate() {
    o(this, Tr).clear();
  }
}
Tr = new WeakMap(), su = new WeakMap();
var wt, iu, Pr, Cr, so, od, io, ld;
let ad = (wt = class {
  constructor({
    name: e = null,
    port: t = null,
    verbosity: s = xy()
  } = {}) {
    y(this, so);
    var i;
    if (this.name = e, this.destroyed = !1, this.verbosity = s, this._readyCapability = Promise.withResolvers(), this._port = null, this._webWorker = null, this._messageHandler = null, t) {
      if ((i = o(wt, Cr)) != null && i.has(t))
        throw new Error("Cannot use more than one PDFWorker per port.");
      (o(wt, Cr) || v(wt, Cr, /* @__PURE__ */ new WeakMap())).set(t, this), this._initializeFromPort(t);
      return;
    }
    this._initialize();
  }
  get promise() {
    return ye ? Promise.all([$n.promise, this._readyCapability.promise]) : this._readyCapability.promise;
  }
  get port() {
    return this._port;
  }
  get messageHandler() {
    return this._messageHandler;
  }
  _initializeFromPort(e) {
    this._port = e, this._messageHandler = new gl("main", "worker", e), this._messageHandler.on("ready", function() {
    }), m(this, so, od).call(this);
  }
  _initialize() {
    if (o(wt, Pr) || o(wt, io, ld)) {
      this._setupFakeWorker();
      return;
    }
    let {
      workerSrc: e
    } = wt;
    try {
      wt._isSameOrigin(window.location.href, e) || (e = wt._createCDNWrapper(new URL(e, window.location).href));
      const t = new Worker(e, {
        type: "module"
      }), s = new gl("main", "worker", t), i = () => {
        n.abort(), s.destroy(), t.terminate(), this.destroyed ? this._readyCapability.reject(new Error("Worker was destroyed")) : this._setupFakeWorker();
      }, n = new AbortController();
      t.addEventListener("error", () => {
        this._webWorker || i();
      }, {
        signal: n.signal
      }), s.on("test", (a) => {
        if (n.abort(), this.destroyed || !a) {
          i();
          return;
        }
        this._messageHandler = s, this._port = t, this._webWorker = t, m(this, so, od).call(this);
      }), s.on("ready", (a) => {
        if (n.abort(), this.destroyed) {
          i();
          return;
        }
        try {
          r();
        } catch {
          this._setupFakeWorker();
        }
      });
      const r = () => {
        const a = new Uint8Array();
        s.send("test", a, [a.buffer]);
      };
      r();
      return;
    } catch {
      fu("The worker has been disabled.");
    }
    this._setupFakeWorker();
  }
  _setupFakeWorker() {
    o(wt, Pr) || (nt("Setting up fake worker."), v(wt, Pr, !0)), wt._setupFakeWorkerGlobal.then((e) => {
      if (this.destroyed) {
        this._readyCapability.reject(new Error("Worker was destroyed"));
        return;
      }
      const t = new WA();
      this._port = t;
      const s = `fake${de(wt, iu)._++}`, i = new gl(s + "_worker", s, t);
      e.setup(i, t), this._messageHandler = new gl(s, s + "_worker", t), m(this, so, od).call(this);
    }).catch((e) => {
      this._readyCapability.reject(new Error(`Setting up fake worker failed: "${e.message}".`));
    });
  }
  destroy() {
    var e;
    this.destroyed = !0, this._webWorker && (this._webWorker.terminate(), this._webWorker = null), (e = o(wt, Cr)) == null || e.delete(this._port), this._port = null, this._messageHandler && (this._messageHandler.destroy(), this._messageHandler = null);
  }
  static fromPort(e) {
    var s;
    if (!(e != null && e.port))
      throw new Error("PDFWorker.fromPort - invalid method signature.");
    const t = (s = o(this, Cr)) == null ? void 0 : s.get(e.port);
    if (t) {
      if (t._pendingDestroy)
        throw new Error("PDFWorker.fromPort - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
      return t;
    }
    return new wt(e);
  }
  static get workerSrc() {
    if (Zn.workerSrc)
      return Zn.workerSrc;
    throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
  }
  static get _setupFakeWorkerGlobal() {
    return ht(this, "_setupFakeWorkerGlobal", (async () => o(this, io, ld) ? o(this, io, ld) : (await import(
      /*webpackIgnore: true*/
      this.workerSrc
    )).WorkerMessageHandler)());
  }
}, iu = new WeakMap(), Pr = new WeakMap(), Cr = new WeakMap(), so = new WeakSet(), od = function() {
  this._readyCapability.resolve(), this._messageHandler.send("configure", {
    verbosity: this.verbosity
  });
}, io = new WeakSet(), ld = function() {
  var e;
  try {
    return ((e = globalThis.pdfjsWorker) == null ? void 0 : e.WorkerMessageHandler) || null;
  } catch {
    return null;
  }
}, y(wt, io), y(wt, iu, 0), y(wt, Pr, !1), y(wt, Cr), ye && (v(wt, Pr, !0), Zn.workerSrc || (Zn.workerSrc = "./pdf.worker.mjs")), wt._isSameOrigin = (e, t) => {
  let s;
  try {
    if (s = new URL(e), !s.origin || s.origin === "null")
      return !1;
  } catch {
    return !1;
  }
  const i = new URL(t, s);
  return s.origin === i.origin;
}, wt._createCDNWrapper = (e) => {
  const t = `await import("${e}");`;
  return URL.createObjectURL(new Blob([t], {
    type: "text/javascript"
  }));
}, wt);
var vi, Fs, no, ro, js, Rr, ml;
class GA {
  constructor(e, t, s, i, n) {
    y(this, Rr);
    y(this, vi, /* @__PURE__ */ new Map());
    y(this, Fs, /* @__PURE__ */ new Map());
    y(this, no, /* @__PURE__ */ new Map());
    y(this, ro, /* @__PURE__ */ new Map());
    y(this, js, null);
    this.messageHandler = e, this.loadingTask = t, this.commonObjs = new uv(), this.fontLoader = new Wy({
      ownerDocument: i.ownerDocument,
      styleElement: i.styleElement
    }), this.loadingParams = i.loadingParams, this._params = i, this.canvasFactory = n.canvasFactory, this.filterFactory = n.filterFactory, this.cMapReaderFactory = n.cMapReaderFactory, this.standardFontDataFactory = n.standardFontDataFactory, this.destroyed = !1, this.destroyCapability = null, this._networkStream = s, this._fullReader = null, this._lastProgress = null, this.downloadInfoCapability = Promise.withResolvers(), this.setupMessageHandler();
  }
  get annotationStorage() {
    return ht(this, "annotationStorage", new Wp());
  }
  getRenderingIntent(e, t = Zi.ENABLE, s = null, i = !1, n = !1) {
    let r = Xe.DISPLAY, a = ff;
    switch (e) {
      case "any":
        r = Xe.ANY;
        break;
      case "display":
        break;
      case "print":
        r = Xe.PRINT;
        break;
      default:
        nt(`getRenderingIntent - invalid intent: ${e}`);
    }
    const h = r & Xe.PRINT && s instanceof Zm ? s : this.annotationStorage;
    switch (t) {
      case Zi.DISABLE:
        r += Xe.ANNOTATIONS_DISABLE;
        break;
      case Zi.ENABLE:
        break;
      case Zi.ENABLE_FORMS:
        r += Xe.ANNOTATIONS_FORMS;
        break;
      case Zi.ENABLE_STORAGE:
        r += Xe.ANNOTATIONS_STORAGE, a = h.serializable;
        break;
      default:
        nt(`getRenderingIntent - invalid annotationMode: ${t}`);
    }
    i && (r += Xe.IS_EDITING), n && (r += Xe.OPLIST);
    const {
      ids: c,
      hash: d
    } = h.modifiedIds, u = [r, a.hash, d];
    return {
      renderingIntent: r,
      cacheKey: u.join("_"),
      annotationStorageSerializable: a,
      modifiedIds: c
    };
  }
  destroy() {
    var s;
    if (this.destroyCapability)
      return this.destroyCapability.promise;
    this.destroyed = !0, this.destroyCapability = Promise.withResolvers(), (s = o(this, js)) == null || s.reject(new Error("Worker was destroyed during onPassword callback"));
    const e = [];
    for (const i of o(this, Fs).values())
      e.push(i._destroy());
    o(this, Fs).clear(), o(this, no).clear(), o(this, ro).clear(), this.hasOwnProperty("annotationStorage") && this.annotationStorage.resetModified();
    const t = this.messageHandler.sendWithPromise("Terminate", null);
    return e.push(t), Promise.all(e).then(() => {
      var i;
      this.commonObjs.clear(), this.fontLoader.clear(), o(this, vi).clear(), this.filterFactory.destroy(), Af.cleanup(), (i = this._networkStream) == null || i.cancelAllRequests(new ya("Worker was terminated.")), this.messageHandler && (this.messageHandler.destroy(), this.messageHandler = null), this.destroyCapability.resolve();
    }, this.destroyCapability.reject), this.destroyCapability.promise;
  }
  setupMessageHandler() {
    const {
      messageHandler: e,
      loadingTask: t
    } = this;
    e.on("GetReader", (s, i) => {
      Qt(this._networkStream, "GetReader - no `IPDFStream` instance available."), this._fullReader = this._networkStream.getFullReader(), this._fullReader.onProgress = (n) => {
        this._lastProgress = {
          loaded: n.loaded,
          total: n.total
        };
      }, i.onPull = () => {
        this._fullReader.read().then(function({
          value: n,
          done: r
        }) {
          if (r) {
            i.close();
            return;
          }
          Qt(n instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer."), i.enqueue(new Uint8Array(n), 1, [n]);
        }).catch((n) => {
          i.error(n);
        });
      }, i.onCancel = (n) => {
        this._fullReader.cancel(n), i.ready.catch((r) => {
          if (!this.destroyed)
            throw r;
        });
      };
    }), e.on("ReaderHeadersReady", (s) => {
      const i = Promise.withResolvers(), n = this._fullReader;
      return n.headersReady.then(() => {
        var r;
        (!n.isStreamingSupported || !n.isRangeSupported) && (this._lastProgress && ((r = t.onProgress) == null || r.call(t, this._lastProgress)), n.onProgress = (a) => {
          var h;
          (h = t.onProgress) == null || h.call(t, {
            loaded: a.loaded,
            total: a.total
          });
        }), i.resolve({
          isStreamingSupported: n.isStreamingSupported,
          isRangeSupported: n.isRangeSupported,
          contentLength: n.contentLength
        });
      }, i.reject), i.promise;
    }), e.on("GetRangeReader", (s, i) => {
      Qt(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
      const n = this._networkStream.getRangeReader(s.begin, s.end);
      if (!n) {
        i.close();
        return;
      }
      i.onPull = () => {
        n.read().then(function({
          value: r,
          done: a
        }) {
          if (a) {
            i.close();
            return;
          }
          Qt(r instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer."), i.enqueue(new Uint8Array(r), 1, [r]);
        }).catch((r) => {
          i.error(r);
        });
      }, i.onCancel = (r) => {
        n.cancel(r), i.ready.catch((a) => {
          if (!this.destroyed)
            throw a;
        });
      };
    }), e.on("GetDoc", ({
      pdfInfo: s
    }) => {
      this._numPages = s.numPages, this._htmlForXfa = s.htmlForXfa, delete s.htmlForXfa, t._capability.resolve(new UA(s, this));
    }), e.on("DocException", function(s) {
      let i;
      switch (s.name) {
        case "PasswordException":
          i = new Vu(s.message, s.code);
          break;
        case "InvalidPDFException":
          i = new gm(s.message);
          break;
        case "MissingPDFException":
          i = new ba(s.message);
          break;
        case "UnexpectedResponseException":
          i = new pu(s.message, s.status);
          break;
        case "UnknownErrorException":
          i = new Uu(s.message, s.details);
          break;
        default:
          Ut("DocException - expected a valid Error.");
      }
      t._capability.reject(i);
    }), e.on("PasswordRequest", (s) => {
      if (v(this, js, Promise.withResolvers()), t.onPassword) {
        const i = (n) => {
          n instanceof Error ? o(this, js).reject(n) : o(this, js).resolve({
            password: n
          });
        };
        try {
          t.onPassword(i, s.code);
        } catch (n) {
          o(this, js).reject(n);
        }
      } else
        o(this, js).reject(new Vu(s.message, s.code));
      return o(this, js).promise;
    }), e.on("DataLoaded", (s) => {
      var i;
      (i = t.onProgress) == null || i.call(t, {
        loaded: s.length,
        total: s.length
      }), this.downloadInfoCapability.resolve(s);
    }), e.on("StartRenderPage", (s) => {
      if (this.destroyed)
        return;
      o(this, Fs).get(s.pageIndex)._startRenderPage(s.transparency, s.cacheKey);
    }), e.on("commonobj", ([s, i, n]) => {
      var r;
      if (this.destroyed || this.commonObjs.has(s))
        return null;
      switch (i) {
        case "Font":
          const {
            disableFontFace: a,
            fontExtraProperties: h,
            pdfBug: c
          } = this._params;
          if ("error" in n) {
            const p = n.error;
            nt(`Error during font loading: ${p}`), this.commonObjs.resolve(s, p);
            break;
          }
          const d = c && ((r = globalThis.FontInspector) != null && r.enabled) ? (p, g) => globalThis.FontInspector.fontAdded(p, g) : null, u = new Gy(n, {
            disableFontFace: a,
            inspectFont: d
          });
          this.fontLoader.bind(u).catch(() => e.sendWithPromise("FontFallback", {
            id: s
          })).finally(() => {
            !h && u.data && (u.data = null), this.commonObjs.resolve(s, u);
          });
          break;
        case "CopyLocalImage":
          const {
            imageRef: f
          } = n;
          Qt(f, "The imageRef must be defined.");
          for (const p of o(this, Fs).values())
            for (const [, g] of p.objs)
              if ((g == null ? void 0 : g.ref) === f)
                return g.dataLen ? (this.commonObjs.resolve(s, structuredClone(g)), g.dataLen) : null;
          break;
        case "FontPath":
        case "Image":
        case "Pattern":
          this.commonObjs.resolve(s, n);
          break;
        default:
          throw new Error(`Got unknown common object type ${i}`);
      }
      return null;
    }), e.on("obj", ([s, i, n, r]) => {
      var h;
      if (this.destroyed)
        return;
      const a = o(this, Fs).get(i);
      if (!a.objs.has(s)) {
        if (a._intentStates.size === 0) {
          (h = r == null ? void 0 : r.bitmap) == null || h.close();
          return;
        }
        switch (n) {
          case "Image":
            a.objs.resolve(s, r), (r == null ? void 0 : r.dataLen) > by && (a._maybeCleanupAfterRender = !0);
            break;
          case "Pattern":
            a.objs.resolve(s, r);
            break;
          default:
            throw new Error(`Got unknown object type ${n}`);
        }
      }
    }), e.on("DocProgress", (s) => {
      var i;
      this.destroyed || (i = t.onProgress) == null || i.call(t, {
        loaded: s.loaded,
        total: s.total
      });
    }), e.on("FetchBuiltInCMap", (s) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.cMapReaderFactory ? this.cMapReaderFactory.fetch(s) : Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."))), e.on("FetchStandardFontData", (s) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.standardFontDataFactory ? this.standardFontDataFactory.fetch(s) : Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.")));
  }
  getData() {
    return this.messageHandler.sendWithPromise("GetData", null);
  }
  saveDocument() {
    var s;
    this.annotationStorage.size <= 0 && nt("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
    const {
      map: e,
      transfer: t
    } = this.annotationStorage.serializable;
    return this.messageHandler.sendWithPromise("SaveDocument", {
      isPureXfa: !!this._htmlForXfa,
      numPages: this._numPages,
      annotationStorage: e,
      filename: ((s = this._fullReader) == null ? void 0 : s.filename) ?? null
    }, t).finally(() => {
      this.annotationStorage.resetModified();
    });
  }
  getPage(e) {
    if (!Number.isInteger(e) || e <= 0 || e > this._numPages)
      return Promise.reject(new Error("Invalid page request."));
    const t = e - 1, s = o(this, no).get(t);
    if (s)
      return s;
    const i = this.messageHandler.sendWithPromise("GetPage", {
      pageIndex: t
    }).then((n) => {
      if (this.destroyed)
        throw new Error("Transport destroyed");
      n.refStr && o(this, ro).set(n.refStr, e);
      const r = new zA(t, n, this, this._params.pdfBug);
      return o(this, Fs).set(t, r), r;
    });
    return o(this, no).set(t, i), i;
  }
  getPageIndex(e) {
    return xg(e) ? this.messageHandler.sendWithPromise("GetPageIndex", {
      num: e.num,
      gen: e.gen
    }) : Promise.reject(new Error("Invalid pageIndex request."));
  }
  getAnnotations(e, t) {
    return this.messageHandler.sendWithPromise("GetAnnotations", {
      pageIndex: e,
      intent: t
    });
  }
  getFieldObjects() {
    return m(this, Rr, ml).call(this, "GetFieldObjects");
  }
  hasJSActions() {
    return m(this, Rr, ml).call(this, "HasJSActions");
  }
  getCalculationOrderIds() {
    return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
  }
  getDestinations() {
    return this.messageHandler.sendWithPromise("GetDestinations", null);
  }
  getDestination(e) {
    return typeof e != "string" ? Promise.reject(new Error("Invalid destination request.")) : this.messageHandler.sendWithPromise("GetDestination", {
      id: e
    });
  }
  getPageLabels() {
    return this.messageHandler.sendWithPromise("GetPageLabels", null);
  }
  getPageLayout() {
    return this.messageHandler.sendWithPromise("GetPageLayout", null);
  }
  getPageMode() {
    return this.messageHandler.sendWithPromise("GetPageMode", null);
  }
  getViewerPreferences() {
    return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
  }
  getOpenAction() {
    return this.messageHandler.sendWithPromise("GetOpenAction", null);
  }
  getAttachments() {
    return this.messageHandler.sendWithPromise("GetAttachments", null);
  }
  getDocJSActions() {
    return m(this, Rr, ml).call(this, "GetDocJSActions");
  }
  getPageJSActions(e) {
    return this.messageHandler.sendWithPromise("GetPageJSActions", {
      pageIndex: e
    });
  }
  getStructTree(e) {
    return this.messageHandler.sendWithPromise("GetStructTree", {
      pageIndex: e
    });
  }
  getOutline() {
    return this.messageHandler.sendWithPromise("GetOutline", null);
  }
  getOptionalContentConfig(e) {
    return m(this, Rr, ml).call(this, "GetOptionalContentConfig").then((t) => new uA(t, e));
  }
  getPermissions() {
    return this.messageHandler.sendWithPromise("GetPermissions", null);
  }
  getMetadata() {
    const e = "GetMetadata", t = o(this, vi).get(e);
    if (t)
      return t;
    const s = this.messageHandler.sendWithPromise(e, null).then((i) => {
      var n, r;
      return {
        info: i[0],
        metadata: i[1] ? new cA(i[1]) : null,
        contentDispositionFilename: ((n = this._fullReader) == null ? void 0 : n.filename) ?? null,
        contentLength: ((r = this._fullReader) == null ? void 0 : r.contentLength) ?? null
      };
    });
    return o(this, vi).set(e, s), s;
  }
  getMarkInfo() {
    return this.messageHandler.sendWithPromise("GetMarkInfo", null);
  }
  async startCleanup(e = !1) {
    if (!this.destroyed) {
      await this.messageHandler.sendWithPromise("Cleanup", null);
      for (const t of o(this, Fs).values())
        if (!t.cleanup())
          throw new Error(`startCleanup: Page ${t.pageNumber} is currently rendering.`);
      this.commonObjs.clear(), e || this.fontLoader.clear(), o(this, vi).clear(), this.filterFactory.destroy(!0), Af.cleanup();
    }
  }
  cachedPageNumber(e) {
    if (!xg(e))
      return null;
    const t = e.gen === 0 ? `${e.num}R` : `${e.num}R${e.gen}`;
    return o(this, ro).get(t) ?? null;
  }
}
vi = new WeakMap(), Fs = new WeakMap(), no = new WeakMap(), ro = new WeakMap(), js = new WeakMap(), Rr = new WeakSet(), ml = function(e, t = null) {
  const s = o(this, vi).get(e);
  if (s)
    return s;
  const i = this.messageHandler.sendWithPromise(e, t);
  return o(this, vi).set(e, i), i;
};
const Bc = Symbol("INITIAL_DATA");
var gs, wh, Sf;
class uv {
  constructor() {
    y(this, wh);
    y(this, gs, /* @__PURE__ */ Object.create(null));
  }
  get(e, t = null) {
    if (t) {
      const i = m(this, wh, Sf).call(this, e);
      return i.promise.then(() => t(i.data)), null;
    }
    const s = o(this, gs)[e];
    if (!s || s.data === Bc)
      throw new Error(`Requesting object that isn't resolved yet ${e}.`);
    return s.data;
  }
  has(e) {
    const t = o(this, gs)[e];
    return !!t && t.data !== Bc;
  }
  resolve(e, t = null) {
    const s = m(this, wh, Sf).call(this, e);
    s.data = t, s.resolve();
  }
  clear() {
    var e;
    for (const t in o(this, gs)) {
      const {
        data: s
      } = o(this, gs)[t];
      (e = s == null ? void 0 : s.bitmap) == null || e.close();
    }
    v(this, gs, /* @__PURE__ */ Object.create(null));
  }
  *[Symbol.iterator]() {
    for (const e in o(this, gs)) {
      const {
        data: t
      } = o(this, gs)[e];
      t !== Bc && (yield [e, t]);
    }
  }
}
gs = new WeakMap(), wh = new WeakSet(), Sf = function(e) {
  var t;
  return (t = o(this, gs))[e] || (t[e] = {
    ...Promise.withResolvers(),
    data: Bc
  });
};
var pn;
class XA {
  constructor(e) {
    y(this, pn, null);
    v(this, pn, e), this.onContinue = null;
  }
  get promise() {
    return o(this, pn).capability.promise;
  }
  cancel(e = 0) {
    o(this, pn).cancel(null, e);
  }
  get separateAnnots() {
    const {
      separateAnnots: e
    } = o(this, pn).operatorList;
    if (!e)
      return !1;
    const {
      annotationCanvasMap: t
    } = o(this, pn);
    return e.form || e.canvas && (t == null ? void 0 : t.size) > 0;
  }
}
pn = new WeakMap();
var gn, Ir;
const Jn = class Jn {
  constructor({
    callback: e,
    params: t,
    objs: s,
    commonObjs: i,
    annotationCanvasMap: n,
    operatorList: r,
    pageIndex: a,
    canvasFactory: h,
    filterFactory: c,
    useRequestAnimationFrame: d = !1,
    pdfBug: u = !1,
    pageColors: f = null
  }) {
    y(this, gn, null);
    this.callback = e, this.params = t, this.objs = s, this.commonObjs = i, this.annotationCanvasMap = n, this.operatorListIdx = null, this.operatorList = r, this._pageIndex = a, this.canvasFactory = h, this.filterFactory = c, this._pdfBug = u, this.pageColors = f, this.running = !1, this.graphicsReadyCallback = null, this.graphicsReady = !1, this._useRequestAnimationFrame = d === !0 && typeof window < "u", this.cancelled = !1, this.capability = Promise.withResolvers(), this.task = new XA(this), this._cancelBound = this.cancel.bind(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this), this._canvas = t.canvasContext.canvas;
  }
  get completed() {
    return this.capability.promise.catch(function() {
    });
  }
  initializeGraphics({
    transparency: e = !1,
    optionalContentConfig: t
  }) {
    var a, h;
    if (this.cancelled)
      return;
    if (this._canvas) {
      if (o(Jn, Ir).has(this._canvas))
        throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
      o(Jn, Ir).add(this._canvas);
    }
    this._pdfBug && ((a = globalThis.StepperManager) != null && a.enabled) && (this.stepper = globalThis.StepperManager.create(this._pageIndex), this.stepper.init(this.operatorList), this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint());
    const {
      canvasContext: s,
      viewport: i,
      transform: n,
      background: r
    } = this.params;
    this.gfx = new _a(s, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
      optionalContentConfig: t
    }, this.annotationCanvasMap, this.pageColors), this.gfx.beginDrawing({
      transform: n,
      viewport: i,
      transparency: e,
      background: r
    }), this.operatorListIdx = 0, this.graphicsReady = !0, (h = this.graphicsReadyCallback) == null || h.call(this);
  }
  cancel(e = null, t = 0) {
    var s;
    this.running = !1, this.cancelled = !0, (s = this.gfx) == null || s.endDrawing(), o(this, gn) && (window.cancelAnimationFrame(o(this, gn)), v(this, gn, null)), o(Jn, Ir).delete(this._canvas), this.callback(e || new Vp(`Rendering cancelled, page ${this._pageIndex + 1}`, t));
  }
  operatorListChanged() {
    var e;
    if (!this.graphicsReady) {
      this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound);
      return;
    }
    (e = this.stepper) == null || e.updateOperatorList(this.operatorList), !this.running && this._continue();
  }
  _continue() {
    this.running = !0, !this.cancelled && (this.task.onContinue ? this.task.onContinue(this._scheduleNextBound) : this._scheduleNext());
  }
  _scheduleNext() {
    this._useRequestAnimationFrame ? v(this, gn, window.requestAnimationFrame(() => {
      v(this, gn, null), this._nextBound().catch(this._cancelBound);
    })) : Promise.resolve().then(this._nextBound).catch(this._cancelBound);
  }
  async _next() {
    this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = !1, this.operatorList.lastChunk && (this.gfx.endDrawing(), o(Jn, Ir).delete(this._canvas), this.callback())));
  }
};
gn = new WeakMap(), Ir = new WeakMap(), y(Jn, Ir, /* @__PURE__ */ new WeakSet());
let Tf = Jn;
const KA = "4.7.76", YA = "8b73b828b";
dt(670);
function Sg(l) {
  return Math.floor(Math.max(0, Math.min(1, l)) * 255).toString(16).padStart(2, "0");
}
function rl(l) {
  return Math.max(0, Math.min(255, 255 * l));
}
class Tg {
  static CMYK_G([e, t, s, i]) {
    return ["G", 1 - Math.min(1, 0.3 * e + 0.59 * s + 0.11 * t + i)];
  }
  static G_CMYK([e]) {
    return ["CMYK", 0, 0, 0, 1 - e];
  }
  static G_RGB([e]) {
    return ["RGB", e, e, e];
  }
  static G_rgb([e]) {
    return e = rl(e), [e, e, e];
  }
  static G_HTML([e]) {
    const t = Sg(e);
    return `#${t}${t}${t}`;
  }
  static RGB_G([e, t, s]) {
    return ["G", 0.3 * e + 0.59 * t + 0.11 * s];
  }
  static RGB_rgb(e) {
    return e.map(rl);
  }
  static RGB_HTML(e) {
    return `#${e.map(Sg).join("")}`;
  }
  static T_HTML() {
    return "#00000000";
  }
  static T_rgb() {
    return [null];
  }
  static CMYK_RGB([e, t, s, i]) {
    return ["RGB", 1 - Math.min(1, e + i), 1 - Math.min(1, s + i), 1 - Math.min(1, t + i)];
  }
  static CMYK_rgb([e, t, s, i]) {
    return [rl(1 - Math.min(1, e + i)), rl(1 - Math.min(1, s + i)), rl(1 - Math.min(1, t + i))];
  }
  static CMYK_HTML(e) {
    const t = this.CMYK_RGB(e).slice(1);
    return this.RGB_HTML(t);
  }
  static RGB_CMYK([e, t, s]) {
    const i = 1 - e, n = 1 - t, r = 1 - s, a = Math.min(i, n, r);
    return ["CMYK", i, n, r, a];
  }
}
let fv = class {
  static setupStorage(e, t, s, i, n) {
    const r = i.getValue(t, {
      value: null
    });
    switch (s.name) {
      case "textarea":
        if (r.value !== null && (e.textContent = r.value), n === "print")
          break;
        e.addEventListener("input", (a) => {
          i.setValue(t, {
            value: a.target.value
          });
        });
        break;
      case "input":
        if (s.attributes.type === "radio" || s.attributes.type === "checkbox") {
          if (r.value === s.attributes.xfaOn ? e.setAttribute("checked", !0) : r.value === s.attributes.xfaOff && e.removeAttribute("checked"), n === "print")
            break;
          e.addEventListener("change", (a) => {
            i.setValue(t, {
              value: a.target.checked ? a.target.getAttribute("xfaOn") : a.target.getAttribute("xfaOff")
            });
          });
        } else {
          if (r.value !== null && e.setAttribute("value", r.value), n === "print")
            break;
          e.addEventListener("input", (a) => {
            i.setValue(t, {
              value: a.target.value
            });
          });
        }
        break;
      case "select":
        if (r.value !== null) {
          e.setAttribute("value", r.value);
          for (const a of s.children)
            a.attributes.value === r.value ? a.attributes.selected = !0 : a.attributes.hasOwnProperty("selected") && delete a.attributes.selected;
        }
        e.addEventListener("input", (a) => {
          const h = a.target.options, c = h.selectedIndex === -1 ? "" : h[h.selectedIndex].value;
          i.setValue(t, {
            value: c
          });
        });
        break;
    }
  }
  static setAttributes({
    html: e,
    element: t,
    storage: s = null,
    intent: i,
    linkService: n
  }) {
    const {
      attributes: r
    } = t, a = e instanceof HTMLAnchorElement;
    r.type === "radio" && (r.name = `${r.name}-${i}`);
    for (const [h, c] of Object.entries(r))
      if (c != null)
        switch (h) {
          case "class":
            c.length && e.setAttribute(h, c.join(" "));
            break;
          case "dataId":
            break;
          case "id":
            e.setAttribute("data-element-id", c);
            break;
          case "style":
            Object.assign(e.style, c);
            break;
          case "textContent":
            e.textContent = c;
            break;
          default:
            (!a || h !== "href" && h !== "newWindow") && e.setAttribute(h, c);
        }
    a && n.addLinkAttributes(e, r.href, r.newWindow), s && r.dataId && this.setupStorage(e, r.dataId, t, s);
  }
  static render(e) {
    var u, f;
    const t = e.annotationStorage, s = e.linkService, i = e.xfaHtml, n = e.intent || "display", r = document.createElement(i.name);
    i.attributes && this.setAttributes({
      html: r,
      element: i,
      intent: n,
      linkService: s
    });
    const a = n !== "richText", h = e.div;
    if (h.append(r), e.viewport) {
      const p = `matrix(${e.viewport.transform.join(",")})`;
      h.style.transform = p;
    }
    a && h.setAttribute("class", "xfaLayer xfaFont");
    const c = [];
    if (i.children.length === 0) {
      if (i.value) {
        const p = document.createTextNode(i.value);
        r.append(p), a && Fl.shouldBuildText(i.name) && c.push(p);
      }
      return {
        textDivs: c
      };
    }
    const d = [[i, -1, r]];
    for (; d.length > 0; ) {
      const [p, g, b] = d.at(-1);
      if (g + 1 === p.children.length) {
        d.pop();
        continue;
      }
      const E = p.children[++d.at(-1)[1]];
      if (E === null)
        continue;
      const {
        name: A
      } = E;
      if (A === "#text") {
        const x = document.createTextNode(E.value);
        c.push(x), b.append(x);
        continue;
      }
      const w = (u = E == null ? void 0 : E.attributes) != null && u.xmlns ? document.createElementNS(E.attributes.xmlns, A) : document.createElement(A);
      if (b.append(w), E.attributes && this.setAttributes({
        html: w,
        element: E,
        storage: t,
        intent: n,
        linkService: s
      }), ((f = E.children) == null ? void 0 : f.length) > 0)
        d.push([E, -1, w]);
      else if (E.value) {
        const x = document.createTextNode(E.value);
        a && Fl.shouldBuildText(A) && c.push(x), w.append(x);
      }
    }
    for (const p of h.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea"))
      p.setAttribute("readOnly", !0);
    return {
      textDivs: c
    };
  }
  static update(e) {
    const t = `matrix(${e.viewport.transform.join(",")})`;
    e.div.style.transform = t, e.div.hidden = !1;
  }
};
const Nc = 1e3, QA = 9, ga = /* @__PURE__ */ new WeakSet();
function Bi(l) {
  return {
    width: l[2] - l[0],
    height: l[3] - l[1]
  };
}
class ZA {
  static create(e) {
    switch (e.data.annotationType) {
      case Wt.LINK:
        return new pv(e);
      case Wt.TEXT:
        return new JA(e);
      case Wt.WIDGET:
        switch (e.data.fieldType) {
          case "Tx":
            return new qA(e);
          case "Btn":
            return e.data.radioButton ? new vv(e) : e.data.checkBox ? new eE(e) : new sE(e);
          case "Ch":
            return new iE(e);
          case "Sig":
            return new tE(e);
        }
        return new Aa(e);
      case Wt.POPUP:
        return new Cf(e);
      case Wt.FREETEXT:
        return new wv(e);
      case Wt.LINE:
        return new rE(e);
      case Wt.SQUARE:
        return new aE(e);
      case Wt.CIRCLE:
        return new oE(e);
      case Wt.POLYLINE:
        return new xv(e);
      case Wt.CARET:
        return new hE(e);
      case Wt.INK:
        return new Qp(e);
      case Wt.POLYGON:
        return new lE(e);
      case Wt.HIGHLIGHT:
        return new Sv(e);
      case Wt.UNDERLINE:
        return new cE(e);
      case Wt.SQUIGGLY:
        return new dE(e);
      case Wt.STRIKEOUT:
        return new uE(e);
      case Wt.STAMP:
        return new Tv(e);
      case Wt.FILEATTACHMENT:
        return new fE(e);
      default:
        return new Ft(e);
    }
  }
}
var Lr, ao, oo, xh, Pf;
const eg = class eg {
  constructor(e, {
    isRenderable: t = !1,
    ignoreBorder: s = !1,
    createQuadrilaterals: i = !1
  } = {}) {
    y(this, xh);
    y(this, Lr, null);
    y(this, ao, !1);
    y(this, oo, null);
    this.isRenderable = t, this.data = e.data, this.layer = e.layer, this.linkService = e.linkService, this.downloadManager = e.downloadManager, this.imageResourcesPath = e.imageResourcesPath, this.renderForms = e.renderForms, this.svgFactory = e.svgFactory, this.annotationStorage = e.annotationStorage, this.enableScripting = e.enableScripting, this.hasJSActions = e.hasJSActions, this._fieldObjects = e.fieldObjects, this.parent = e.parent, t && (this.container = this._createContainer(s)), i && this._createQuadrilaterals();
  }
  static _hasPopupData({
    titleObj: e,
    contentsObj: t,
    richText: s
  }) {
    return !!(e != null && e.str || t != null && t.str || s != null && s.str);
  }
  get _isEditable() {
    return this.data.isEditable;
  }
  get hasPopupData() {
    return eg._hasPopupData(this.data);
  }
  updateEdited(e) {
    var s;
    if (!this.container)
      return;
    o(this, Lr) || v(this, Lr, {
      rect: this.data.rect.slice(0)
    });
    const {
      rect: t
    } = e;
    t && m(this, xh, Pf).call(this, t), (s = o(this, oo)) == null || s.popup.updateEdited(e);
  }
  resetEdited() {
    var e;
    o(this, Lr) && (m(this, xh, Pf).call(this, o(this, Lr).rect), (e = o(this, oo)) == null || e.popup.resetEdited(), v(this, Lr, null));
  }
  _createContainer(e) {
    const {
      data: t,
      parent: {
        page: s,
        viewport: i
      }
    } = this, n = document.createElement("section");
    n.setAttribute("data-annotation-id", t.id), this instanceof Aa || (n.tabIndex = Nc);
    const {
      style: r
    } = n;
    if (r.zIndex = this.parent.zIndex++, t.popupRef && n.setAttribute("aria-haspopup", "dialog"), t.alternativeText && (n.title = t.alternativeText), t.noRotate && n.classList.add("norotate"), !t.rect || this instanceof Cf) {
      const {
        rotation: b
      } = t;
      return !t.hasOwnCanvas && b !== 0 && this.setRotation(b, n), n;
    }
    const {
      width: a,
      height: h
    } = Bi(t.rect);
    if (!e && t.borderStyle.width > 0) {
      r.borderWidth = `${t.borderStyle.width}px`;
      const b = t.borderStyle.horizontalCornerRadius, E = t.borderStyle.verticalCornerRadius;
      if (b > 0 || E > 0) {
        const w = `calc(${b}px * var(--scale-factor)) / calc(${E}px * var(--scale-factor))`;
        r.borderRadius = w;
      } else if (this instanceof vv) {
        const w = `calc(${a}px * var(--scale-factor)) / calc(${h}px * var(--scale-factor))`;
        r.borderRadius = w;
      }
      switch (t.borderStyle.style) {
        case il.SOLID:
          r.borderStyle = "solid";
          break;
        case il.DASHED:
          r.borderStyle = "dashed";
          break;
        case il.BEVELED:
          nt("Unimplemented border style: beveled");
          break;
        case il.INSET:
          nt("Unimplemented border style: inset");
          break;
        case il.UNDERLINE:
          r.borderBottomStyle = "solid";
          break;
      }
      const A = t.borderColor || null;
      A ? (v(this, ao, !0), r.borderColor = X.makeHexColor(A[0] | 0, A[1] | 0, A[2] | 0)) : r.borderWidth = 0;
    }
    const c = X.normalizeRect([t.rect[0], s.view[3] - t.rect[1] + s.view[1], t.rect[2], s.view[3] - t.rect[3] + s.view[1]]), {
      pageWidth: d,
      pageHeight: u,
      pageX: f,
      pageY: p
    } = i.rawDims;
    r.left = `${100 * (c[0] - f) / d}%`, r.top = `${100 * (c[1] - p) / u}%`;
    const {
      rotation: g
    } = t;
    return t.hasOwnCanvas || g === 0 ? (r.width = `${100 * a / d}%`, r.height = `${100 * h / u}%`) : this.setRotation(g, n), n;
  }
  setRotation(e, t = this.container) {
    if (!this.data.rect)
      return;
    const {
      pageWidth: s,
      pageHeight: i
    } = this.parent.viewport.rawDims, {
      width: n,
      height: r
    } = Bi(this.data.rect);
    let a, h;
    e % 180 === 0 ? (a = 100 * n / s, h = 100 * r / i) : (a = 100 * r / s, h = 100 * n / i), t.style.width = `${a}%`, t.style.height = `${h}%`, t.setAttribute("data-main-rotation", (360 - e) % 360);
  }
  get _commonActions() {
    const e = (t, s, i) => {
      const n = i.detail[t], r = n[0], a = n.slice(1);
      i.target.style[s] = Tg[`${r}_HTML`](a), this.annotationStorage.setValue(this.data.id, {
        [s]: Tg[`${r}_rgb`](a)
      });
    };
    return ht(this, "_commonActions", {
      display: (t) => {
        const {
          display: s
        } = t.detail, i = s % 2 === 1;
        this.container.style.visibility = i ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
          noView: i,
          noPrint: s === 1 || s === 2
        });
      },
      print: (t) => {
        this.annotationStorage.setValue(this.data.id, {
          noPrint: !t.detail.print
        });
      },
      hidden: (t) => {
        const {
          hidden: s
        } = t.detail;
        this.container.style.visibility = s ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
          noPrint: s,
          noView: s
        });
      },
      focus: (t) => {
        setTimeout(() => t.target.focus({
          preventScroll: !1
        }), 0);
      },
      userName: (t) => {
        t.target.title = t.detail.userName;
      },
      readonly: (t) => {
        t.target.disabled = t.detail.readonly;
      },
      required: (t) => {
        this._setRequired(t.target, t.detail.required);
      },
      bgColor: (t) => {
        e("bgColor", "backgroundColor", t);
      },
      fillColor: (t) => {
        e("fillColor", "backgroundColor", t);
      },
      fgColor: (t) => {
        e("fgColor", "color", t);
      },
      textColor: (t) => {
        e("textColor", "color", t);
      },
      borderColor: (t) => {
        e("borderColor", "borderColor", t);
      },
      strokeColor: (t) => {
        e("strokeColor", "borderColor", t);
      },
      rotation: (t) => {
        const s = t.detail.rotation;
        this.setRotation(s), this.annotationStorage.setValue(this.data.id, {
          rotation: s
        });
      }
    });
  }
  _dispatchEventFromSandbox(e, t) {
    const s = this._commonActions;
    for (const i of Object.keys(t.detail)) {
      const n = e[i] || s[i];
      n == null || n(t);
    }
  }
  _setDefaultPropertiesFromJS(e) {
    if (!this.enableScripting)
      return;
    const t = this.annotationStorage.getRawValue(this.data.id);
    if (!t)
      return;
    const s = this._commonActions;
    for (const [i, n] of Object.entries(t)) {
      const r = s[i];
      if (r) {
        const a = {
          detail: {
            [i]: n
          },
          target: e
        };
        r(a), delete t[i];
      }
    }
  }
  _createQuadrilaterals() {
    if (!this.container)
      return;
    const {
      quadPoints: e
    } = this.data;
    if (!e)
      return;
    const [t, s, i, n] = this.data.rect.map((b) => Math.fround(b));
    if (e.length === 8) {
      const [b, E, A, w] = e.subarray(2, 6);
      if (i === b && n === E && t === A && s === w)
        return;
    }
    const {
      style: r
    } = this.container;
    let a;
    if (o(this, ao)) {
      const {
        borderColor: b,
        borderWidth: E
      } = r;
      r.borderWidth = 0, a = ["url('data:image/svg+xml;utf8,", '<svg xmlns="http://www.w3.org/2000/svg"', ' preserveAspectRatio="none" viewBox="0 0 1 1">', `<g fill="transparent" stroke="${b}" stroke-width="${E}">`], this.container.classList.add("hasBorder");
    }
    const h = i - t, c = n - s, {
      svgFactory: d
    } = this, u = d.createElement("svg");
    u.classList.add("quadrilateralsContainer"), u.setAttribute("width", 0), u.setAttribute("height", 0);
    const f = d.createElement("defs");
    u.append(f);
    const p = d.createElement("clipPath"), g = `clippath_${this.data.id}`;
    p.setAttribute("id", g), p.setAttribute("clipPathUnits", "objectBoundingBox"), f.append(p);
    for (let b = 2, E = e.length; b < E; b += 8) {
      const A = e[b], w = e[b + 1], x = e[b + 2], P = e[b + 3], T = d.createElement("rect"), C = (x - t) / h, R = (n - w) / c, M = (A - x) / h, S = (w - P) / c;
      T.setAttribute("x", C), T.setAttribute("y", R), T.setAttribute("width", M), T.setAttribute("height", S), p.append(T), a == null || a.push(`<rect vector-effect="non-scaling-stroke" x="${C}" y="${R}" width="${M}" height="${S}"/>`);
    }
    o(this, ao) && (a.push("</g></svg>')"), r.backgroundImage = a.join("")), this.container.append(u), this.container.style.clipPath = `url(#${g})`;
  }
  _createPopup() {
    const {
      container: e,
      data: t
    } = this;
    e.setAttribute("aria-haspopup", "dialog");
    const s = v(this, oo, new Cf({
      data: {
        color: t.color,
        titleObj: t.titleObj,
        modificationDate: t.modificationDate,
        contentsObj: t.contentsObj,
        richText: t.richText,
        parentRect: t.rect,
        borderStyle: 0,
        id: `popup_${t.id}`,
        rotation: t.rotation
      },
      parent: this.parent,
      elements: [this]
    }));
    this.parent.div.append(s.render());
  }
  render() {
    Ut("Abstract method `AnnotationElement.render` called");
  }
  _getElementsByName(e, t = null) {
    const s = [];
    if (this._fieldObjects) {
      const i = this._fieldObjects[e];
      if (i)
        for (const {
          page: n,
          id: r,
          exportValues: a
        } of i) {
          if (n === -1 || r === t)
            continue;
          const h = typeof a == "string" ? a : null, c = document.querySelector(`[data-element-id="${r}"]`);
          if (c && !ga.has(c)) {
            nt(`_getElementsByName - element not allowed: ${r}`);
            continue;
          }
          s.push({
            id: r,
            exportValue: h,
            domElement: c
          });
        }
      return s;
    }
    for (const i of document.getElementsByName(e)) {
      const {
        exportValue: n
      } = i, r = i.getAttribute("data-element-id");
      r !== t && ga.has(i) && s.push({
        id: r,
        exportValue: n,
        domElement: i
      });
    }
    return s;
  }
  show() {
    var e;
    this.container && (this.container.hidden = !1), (e = this.popup) == null || e.maybeShow();
  }
  hide() {
    var e;
    this.container && (this.container.hidden = !0), (e = this.popup) == null || e.forceHide();
  }
  getElementsToTriggerPopup() {
    return this.container;
  }
  addHighlightArea() {
    const e = this.getElementsToTriggerPopup();
    if (Array.isArray(e))
      for (const t of e)
        t.classList.add("highlightArea");
    else
      e.classList.add("highlightArea");
  }
  _editOnDoubleClick() {
    if (!this._isEditable)
      return;
    const {
      annotationEditorType: e,
      data: {
        id: t
      }
    } = this;
    this.container.addEventListener("dblclick", () => {
      var s;
      (s = this.linkService.eventBus) == null || s.dispatch("switchannotationeditormode", {
        source: this,
        mode: e,
        editId: t
      });
    });
  }
};
Lr = new WeakMap(), ao = new WeakMap(), oo = new WeakMap(), xh = new WeakSet(), Pf = function(e) {
  const {
    container: {
      style: t
    },
    data: {
      rect: s,
      rotation: i
    },
    parent: {
      viewport: {
        rawDims: {
          pageWidth: n,
          pageHeight: r,
          pageX: a,
          pageY: h
        }
      }
    }
  } = this;
  s == null || s.splice(0, 4, ...e);
  const {
    width: c,
    height: d
  } = Bi(e);
  t.left = `${100 * (e[0] - a) / n}%`, t.top = `${100 * (r - e[3] + h) / r}%`, i === 0 ? (t.width = `${100 * c / n}%`, t.height = `${100 * d / r}%`) : this.setRotation(i);
};
let Ft = eg;
var Ke, Wn, gv, mv;
class pv extends Ft {
  constructor(t, s = null) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !!(s != null && s.ignoreBorder),
      createQuadrilaterals: !0
    });
    y(this, Ke);
    this.isTooltipOnly = t.data.isTooltipOnly;
  }
  render() {
    const {
      data: t,
      linkService: s
    } = this, i = document.createElement("a");
    i.setAttribute("data-element-id", t.id);
    let n = !1;
    return t.url ? (s.addLinkAttributes(i, t.url, t.newWindow), n = !0) : t.action ? (this._bindNamedAction(i, t.action), n = !0) : t.attachment ? (m(this, Ke, gv).call(this, i, t.attachment, t.attachmentDest), n = !0) : t.setOCGState ? (m(this, Ke, mv).call(this, i, t.setOCGState), n = !0) : t.dest ? (this._bindLink(i, t.dest), n = !0) : (t.actions && (t.actions.Action || t.actions["Mouse Up"] || t.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions && (this._bindJSAction(i, t), n = !0), t.resetForm ? (this._bindResetFormAction(i, t.resetForm), n = !0) : this.isTooltipOnly && !n && (this._bindLink(i, ""), n = !0)), this.container.classList.add("linkAnnotation"), n && this.container.append(i), this.container;
  }
  _bindLink(t, s) {
    t.href = this.linkService.getDestinationHash(s), t.onclick = () => (s && this.linkService.goToDestination(s), !1), (s || s === "") && m(this, Ke, Wn).call(this);
  }
  _bindNamedAction(t, s) {
    t.href = this.linkService.getAnchorUrl(""), t.onclick = () => (this.linkService.executeNamedAction(s), !1), m(this, Ke, Wn).call(this);
  }
  _bindJSAction(t, s) {
    t.href = this.linkService.getAnchorUrl("");
    const i = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
    for (const n of Object.keys(s.actions)) {
      const r = i.get(n);
      r && (t[r] = () => {
        var a;
        return (a = this.linkService.eventBus) == null || a.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: s.id,
            name: n
          }
        }), !1;
      });
    }
    t.onclick || (t.onclick = () => !1), m(this, Ke, Wn).call(this);
  }
  _bindResetFormAction(t, s) {
    const i = t.onclick;
    if (i || (t.href = this.linkService.getAnchorUrl("")), m(this, Ke, Wn).call(this), !this._fieldObjects) {
      nt('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.'), i || (t.onclick = () => !1);
      return;
    }
    t.onclick = () => {
      var u;
      i == null || i();
      const {
        fields: n,
        refs: r,
        include: a
      } = s, h = [];
      if (n.length !== 0 || r.length !== 0) {
        const f = new Set(r);
        for (const p of n) {
          const g = this._fieldObjects[p] || [];
          for (const {
            id: b
          } of g)
            f.add(b);
        }
        for (const p of Object.values(this._fieldObjects))
          for (const g of p)
            f.has(g.id) === a && h.push(g);
      } else
        for (const f of Object.values(this._fieldObjects))
          h.push(...f);
      const c = this.annotationStorage, d = [];
      for (const f of h) {
        const {
          id: p
        } = f;
        switch (d.push(p), f.type) {
          case "text": {
            const b = f.defaultValue || "";
            c.setValue(p, {
              value: b
            });
            break;
          }
          case "checkbox":
          case "radiobutton": {
            const b = f.defaultValue === f.exportValues;
            c.setValue(p, {
              value: b
            });
            break;
          }
          case "combobox":
          case "listbox": {
            const b = f.defaultValue || "";
            c.setValue(p, {
              value: b
            });
            break;
          }
          default:
            continue;
        }
        const g = document.querySelector(`[data-element-id="${p}"]`);
        if (g) {
          if (!ga.has(g)) {
            nt(`_bindResetFormAction - element not allowed: ${p}`);
            continue;
          }
        } else continue;
        g.dispatchEvent(new Event("resetform"));
      }
      return this.enableScripting && ((u = this.linkService.eventBus) == null || u.dispatch("dispatcheventinsandbox", {
        source: this,
        detail: {
          id: "app",
          ids: d,
          name: "ResetForm"
        }
      })), !1;
    };
  }
}
Ke = new WeakSet(), Wn = function() {
  this.container.setAttribute("data-internal-link", "");
}, gv = function(t, s, i = null) {
  t.href = this.linkService.getAnchorUrl(""), s.description && (t.title = s.description), t.onclick = () => {
    var n;
    return (n = this.downloadManager) == null || n.openOrDownloadData(s.content, s.filename, i), !1;
  }, m(this, Ke, Wn).call(this);
}, mv = function(t, s) {
  t.href = this.linkService.getAnchorUrl(""), t.onclick = () => (this.linkService.executeSetOCGState(s), !1), m(this, Ke, Wn).call(this);
};
class JA extends Ft {
  constructor(e) {
    super(e, {
      isRenderable: !0
    });
  }
  render() {
    this.container.classList.add("textAnnotation");
    const e = document.createElement("img");
    return e.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg", e.setAttribute("data-l10n-id", "pdfjs-text-annotation-type"), e.setAttribute("data-l10n-args", JSON.stringify({
      type: this.data.name
    })), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.append(e), this.container;
  }
}
class Aa extends Ft {
  render() {
    return this.container;
  }
  showElementAndHideCanvas(e) {
    var t;
    this.data.hasOwnCanvas && (((t = e.previousSibling) == null ? void 0 : t.nodeName) === "CANVAS" && (e.previousSibling.hidden = !0), e.hidden = !1);
  }
  _getKeyModifier(e) {
    return ke.platform.isMac ? e.metaKey : e.ctrlKey;
  }
  _setEventListener(e, t, s, i, n) {
    s.includes("mouse") ? e.addEventListener(s, (r) => {
      var a;
      (a = this.linkService.eventBus) == null || a.dispatch("dispatcheventinsandbox", {
        source: this,
        detail: {
          id: this.data.id,
          name: i,
          value: n(r),
          shift: r.shiftKey,
          modifier: this._getKeyModifier(r)
        }
      });
    }) : e.addEventListener(s, (r) => {
      var a;
      if (s === "blur") {
        if (!t.focused || !r.relatedTarget)
          return;
        t.focused = !1;
      } else if (s === "focus") {
        if (t.focused)
          return;
        t.focused = !0;
      }
      n && ((a = this.linkService.eventBus) == null || a.dispatch("dispatcheventinsandbox", {
        source: this,
        detail: {
          id: this.data.id,
          name: i,
          value: n(r)
        }
      }));
    });
  }
  _setEventListeners(e, t, s, i) {
    var n, r, a;
    for (const [h, c] of s)
      (c === "Action" || (n = this.data.actions) != null && n[c]) && ((c === "Focus" || c === "Blur") && (t || (t = {
        focused: !1
      })), this._setEventListener(e, t, h, c, i), c === "Focus" && !((r = this.data.actions) != null && r.Blur) ? this._setEventListener(e, t, "blur", "Blur", null) : c === "Blur" && !((a = this.data.actions) != null && a.Focus) && this._setEventListener(e, t, "focus", "Focus", null));
  }
  _setBackgroundColor(e) {
    const t = this.data.backgroundColor || null;
    e.style.backgroundColor = t === null ? "transparent" : X.makeHexColor(t[0], t[1], t[2]);
  }
  _setTextStyle(e) {
    const t = ["left", "center", "right"], {
      fontColor: s
    } = this.data.defaultAppearanceData, i = this.data.defaultAppearanceData.fontSize || QA, n = e.style;
    let r;
    const a = 2, h = (c) => Math.round(10 * c) / 10;
    if (this.data.multiLine) {
      const c = Math.abs(this.data.rect[3] - this.data.rect[1] - a), d = Math.round(c / (xu * i)) || 1, u = c / d;
      r = Math.min(i, h(u / xu));
    } else {
      const c = Math.abs(this.data.rect[3] - this.data.rect[1] - a);
      r = Math.min(i, h(c / xu));
    }
    n.fontSize = `calc(${r}px * var(--scale-factor))`, n.color = X.makeHexColor(s[0], s[1], s[2]), this.data.textAlignment !== null && (n.textAlign = t[this.data.textAlignment]);
  }
  _setRequired(e, t) {
    t ? e.setAttribute("required", !0) : e.removeAttribute("required"), e.setAttribute("aria-required", t);
  }
}
class qA extends Aa {
  constructor(e) {
    const t = e.renderForms || e.data.hasOwnCanvas || !e.data.hasAppearance && !!e.data.fieldValue;
    super(e, {
      isRenderable: t
    });
  }
  setPropertyOnSiblings(e, t, s, i) {
    const n = this.annotationStorage;
    for (const r of this._getElementsByName(e.name, e.id))
      r.domElement && (r.domElement[t] = s), n.setValue(r.id, {
        [i]: s
      });
  }
  render() {
    var i, n;
    const e = this.annotationStorage, t = this.data.id;
    this.container.classList.add("textWidgetAnnotation");
    let s = null;
    if (this.renderForms) {
      const r = e.getValue(t, {
        value: this.data.fieldValue
      });
      let a = r.value || "";
      const h = e.getValue(t, {
        charLimit: this.data.maxLen
      }).charLimit;
      h && a.length > h && (a = a.slice(0, h));
      let c = r.formattedValue || ((i = this.data.textContent) == null ? void 0 : i.join(`
`)) || null;
      c && this.data.comb && (c = c.replaceAll(/\s+/g, ""));
      const d = {
        userValue: a,
        formattedValue: c,
        lastCommittedValue: null,
        commitKey: 1,
        focused: !1
      };
      this.data.multiLine ? (s = document.createElement("textarea"), s.textContent = c ?? a, this.data.doNotScroll && (s.style.overflowY = "hidden")) : (s = document.createElement("input"), s.type = "text", s.setAttribute("value", c ?? a), this.data.doNotScroll && (s.style.overflowX = "hidden")), this.data.hasOwnCanvas && (s.hidden = !0), ga.add(s), s.setAttribute("data-element-id", t), s.disabled = this.data.readOnly, s.name = this.data.fieldName, s.tabIndex = Nc, this._setRequired(s, this.data.required), h && (s.maxLength = h), s.addEventListener("input", (f) => {
        e.setValue(t, {
          value: f.target.value
        }), this.setPropertyOnSiblings(s, "value", f.target.value, "value"), d.formattedValue = null;
      }), s.addEventListener("resetform", (f) => {
        const p = this.data.defaultFieldValue ?? "";
        s.value = d.userValue = p, d.formattedValue = null;
      });
      let u = (f) => {
        const {
          formattedValue: p
        } = d;
        p != null && (f.target.value = p), f.target.scrollLeft = 0;
      };
      if (this.enableScripting && this.hasJSActions) {
        s.addEventListener("focus", (p) => {
          var b;
          if (d.focused)
            return;
          const {
            target: g
          } = p;
          d.userValue && (g.value = d.userValue), d.lastCommittedValue = g.value, d.commitKey = 1, (b = this.data.actions) != null && b.Focus || (d.focused = !0);
        }), s.addEventListener("updatefromsandbox", (p) => {
          this.showElementAndHideCanvas(p.target);
          const g = {
            value(b) {
              d.userValue = b.detail.value ?? "", e.setValue(t, {
                value: d.userValue.toString()
              }), b.target.value = d.userValue;
            },
            formattedValue(b) {
              const {
                formattedValue: E
              } = b.detail;
              d.formattedValue = E, E != null && b.target !== document.activeElement && (b.target.value = E), e.setValue(t, {
                formattedValue: E
              });
            },
            selRange(b) {
              b.target.setSelectionRange(...b.detail.selRange);
            },
            charLimit: (b) => {
              var x;
              const {
                charLimit: E
              } = b.detail, {
                target: A
              } = b;
              if (E === 0) {
                A.removeAttribute("maxLength");
                return;
              }
              A.setAttribute("maxLength", E);
              let w = d.userValue;
              !w || w.length <= E || (w = w.slice(0, E), A.value = d.userValue = w, e.setValue(t, {
                value: w
              }), (x = this.linkService.eventBus) == null || x.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                  id: t,
                  name: "Keystroke",
                  value: w,
                  willCommit: !0,
                  commitKey: 1,
                  selStart: A.selectionStart,
                  selEnd: A.selectionEnd
                }
              }));
            }
          };
          this._dispatchEventFromSandbox(g, p);
        }), s.addEventListener("keydown", (p) => {
          var E;
          d.commitKey = 1;
          let g = -1;
          if (p.key === "Escape" ? g = 0 : p.key === "Enter" && !this.data.multiLine ? g = 2 : p.key === "Tab" && (d.commitKey = 3), g === -1)
            return;
          const {
            value: b
          } = p.target;
          d.lastCommittedValue !== b && (d.lastCommittedValue = b, d.userValue = b, (E = this.linkService.eventBus) == null || E.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id: t,
              name: "Keystroke",
              value: b,
              willCommit: !0,
              commitKey: g,
              selStart: p.target.selectionStart,
              selEnd: p.target.selectionEnd
            }
          }));
        });
        const f = u;
        u = null, s.addEventListener("blur", (p) => {
          var b, E;
          if (!d.focused || !p.relatedTarget)
            return;
          (b = this.data.actions) != null && b.Blur || (d.focused = !1);
          const {
            value: g
          } = p.target;
          d.userValue = g, d.lastCommittedValue !== g && ((E = this.linkService.eventBus) == null || E.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id: t,
              name: "Keystroke",
              value: g,
              willCommit: !0,
              commitKey: d.commitKey,
              selStart: p.target.selectionStart,
              selEnd: p.target.selectionEnd
            }
          })), f(p);
        }), (n = this.data.actions) != null && n.Keystroke && s.addEventListener("beforeinput", (p) => {
          var T;
          d.lastCommittedValue = null;
          const {
            data: g,
            target: b
          } = p, {
            value: E,
            selectionStart: A,
            selectionEnd: w
          } = b;
          let x = A, P = w;
          switch (p.inputType) {
            case "deleteWordBackward": {
              const C = E.substring(0, A).match(/\w*[^\w]*$/);
              C && (x -= C[0].length);
              break;
            }
            case "deleteWordForward": {
              const C = E.substring(A).match(/^[^\w]*\w*/);
              C && (P += C[0].length);
              break;
            }
            case "deleteContentBackward":
              A === w && (x -= 1);
              break;
            case "deleteContentForward":
              A === w && (P += 1);
              break;
          }
          p.preventDefault(), (T = this.linkService.eventBus) == null || T.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id: t,
              name: "Keystroke",
              value: E,
              change: g || "",
              willCommit: !1,
              selStart: x,
              selEnd: P
            }
          });
        }), this._setEventListeners(s, d, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (p) => p.target.value);
      }
      if (u && s.addEventListener("blur", u), this.data.comb) {
        const p = (this.data.rect[2] - this.data.rect[0]) / h;
        s.classList.add("comb"), s.style.letterSpacing = `calc(${p}px * var(--scale-factor) - 1ch)`;
      }
    } else
      s = document.createElement("div"), s.textContent = this.data.fieldValue, s.style.verticalAlign = "middle", s.style.display = "table-cell", this.data.hasOwnCanvas && (s.hidden = !0);
    return this._setTextStyle(s), this._setBackgroundColor(s), this._setDefaultPropertiesFromJS(s), this.container.append(s), this.container;
  }
}
class tE extends Aa {
  constructor(e) {
    super(e, {
      isRenderable: !!e.data.hasOwnCanvas
    });
  }
}
class eE extends Aa {
  constructor(e) {
    super(e, {
      isRenderable: e.renderForms
    });
  }
  render() {
    const e = this.annotationStorage, t = this.data, s = t.id;
    let i = e.getValue(s, {
      value: t.exportValue === t.fieldValue
    }).value;
    typeof i == "string" && (i = i !== "Off", e.setValue(s, {
      value: i
    })), this.container.classList.add("buttonWidgetAnnotation", "checkBox");
    const n = document.createElement("input");
    return ga.add(n), n.setAttribute("data-element-id", s), n.disabled = t.readOnly, this._setRequired(n, this.data.required), n.type = "checkbox", n.name = t.fieldName, i && n.setAttribute("checked", !0), n.setAttribute("exportValue", t.exportValue), n.tabIndex = Nc, n.addEventListener("change", (r) => {
      const {
        name: a,
        checked: h
      } = r.target;
      for (const c of this._getElementsByName(a, s)) {
        const d = h && c.exportValue === t.exportValue;
        c.domElement && (c.domElement.checked = d), e.setValue(c.id, {
          value: d
        });
      }
      e.setValue(s, {
        value: h
      });
    }), n.addEventListener("resetform", (r) => {
      const a = t.defaultFieldValue || "Off";
      r.target.checked = a === t.exportValue;
    }), this.enableScripting && this.hasJSActions && (n.addEventListener("updatefromsandbox", (r) => {
      const a = {
        value(h) {
          h.target.checked = h.detail.value !== "Off", e.setValue(s, {
            value: h.target.checked
          });
        }
      };
      this._dispatchEventFromSandbox(a, r);
    }), this._setEventListeners(n, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (r) => r.target.checked)), this._setBackgroundColor(n), this._setDefaultPropertiesFromJS(n), this.container.append(n), this.container;
  }
}
class vv extends Aa {
  constructor(e) {
    super(e, {
      isRenderable: e.renderForms
    });
  }
  render() {
    this.container.classList.add("buttonWidgetAnnotation", "radioButton");
    const e = this.annotationStorage, t = this.data, s = t.id;
    let i = e.getValue(s, {
      value: t.fieldValue === t.buttonValue
    }).value;
    if (typeof i == "string" && (i = i !== t.buttonValue, e.setValue(s, {
      value: i
    })), i)
      for (const r of this._getElementsByName(t.fieldName, s))
        e.setValue(r.id, {
          value: !1
        });
    const n = document.createElement("input");
    if (ga.add(n), n.setAttribute("data-element-id", s), n.disabled = t.readOnly, this._setRequired(n, this.data.required), n.type = "radio", n.name = t.fieldName, i && n.setAttribute("checked", !0), n.tabIndex = Nc, n.addEventListener("change", (r) => {
      const {
        name: a,
        checked: h
      } = r.target;
      for (const c of this._getElementsByName(a, s))
        e.setValue(c.id, {
          value: !1
        });
      e.setValue(s, {
        value: h
      });
    }), n.addEventListener("resetform", (r) => {
      const a = t.defaultFieldValue;
      r.target.checked = a != null && a === t.buttonValue;
    }), this.enableScripting && this.hasJSActions) {
      const r = t.buttonValue;
      n.addEventListener("updatefromsandbox", (a) => {
        const h = {
          value: (c) => {
            const d = r === c.detail.value;
            for (const u of this._getElementsByName(c.target.name)) {
              const f = d && u.id === s;
              u.domElement && (u.domElement.checked = f), e.setValue(u.id, {
                value: f
              });
            }
          }
        };
        this._dispatchEventFromSandbox(h, a);
      }), this._setEventListeners(n, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (a) => a.target.checked);
    }
    return this._setBackgroundColor(n), this._setDefaultPropertiesFromJS(n), this.container.append(n), this.container;
  }
}
class sE extends pv {
  constructor(e) {
    super(e, {
      ignoreBorder: e.data.hasAppearance
    });
  }
  render() {
    const e = super.render();
    e.classList.add("buttonWidgetAnnotation", "pushButton");
    const t = e.lastChild;
    return this.enableScripting && this.hasJSActions && t && (this._setDefaultPropertiesFromJS(t), t.addEventListener("updatefromsandbox", (s) => {
      this._dispatchEventFromSandbox({}, s);
    })), e;
  }
}
class iE extends Aa {
  constructor(e) {
    super(e, {
      isRenderable: e.renderForms
    });
  }
  render() {
    this.container.classList.add("choiceWidgetAnnotation");
    const e = this.annotationStorage, t = this.data.id, s = e.getValue(t, {
      value: this.data.fieldValue
    }), i = document.createElement("select");
    ga.add(i), i.setAttribute("data-element-id", t), i.disabled = this.data.readOnly, this._setRequired(i, this.data.required), i.name = this.data.fieldName, i.tabIndex = Nc;
    let n = this.data.combo && this.data.options.length > 0;
    this.data.combo || (i.size = this.data.options.length, this.data.multiSelect && (i.multiple = !0)), i.addEventListener("resetform", (d) => {
      const u = this.data.defaultFieldValue;
      for (const f of i.options)
        f.selected = f.value === u;
    });
    for (const d of this.data.options) {
      const u = document.createElement("option");
      u.textContent = d.displayValue, u.value = d.exportValue, s.value.includes(d.exportValue) && (u.setAttribute("selected", !0), n = !1), i.append(u);
    }
    let r = null;
    if (n) {
      const d = document.createElement("option");
      d.value = " ", d.setAttribute("hidden", !0), d.setAttribute("selected", !0), i.prepend(d), r = () => {
        d.remove(), i.removeEventListener("input", r), r = null;
      }, i.addEventListener("input", r);
    }
    const a = (d) => {
      const u = d ? "value" : "textContent", {
        options: f,
        multiple: p
      } = i;
      return p ? Array.prototype.filter.call(f, (g) => g.selected).map((g) => g[u]) : f.selectedIndex === -1 ? null : f[f.selectedIndex][u];
    };
    let h = a(!1);
    const c = (d) => {
      const u = d.target.options;
      return Array.prototype.map.call(u, (f) => ({
        displayValue: f.textContent,
        exportValue: f.value
      }));
    };
    return this.enableScripting && this.hasJSActions ? (i.addEventListener("updatefromsandbox", (d) => {
      const u = {
        value(f) {
          r == null || r();
          const p = f.detail.value, g = new Set(Array.isArray(p) ? p : [p]);
          for (const b of i.options)
            b.selected = g.has(b.value);
          e.setValue(t, {
            value: a(!0)
          }), h = a(!1);
        },
        multipleSelection(f) {
          i.multiple = !0;
        },
        remove(f) {
          const p = i.options, g = f.detail.remove;
          p[g].selected = !1, i.remove(g), p.length > 0 && Array.prototype.findIndex.call(p, (E) => E.selected) === -1 && (p[0].selected = !0), e.setValue(t, {
            value: a(!0),
            items: c(f)
          }), h = a(!1);
        },
        clear(f) {
          for (; i.length !== 0; )
            i.remove(0);
          e.setValue(t, {
            value: null,
            items: []
          }), h = a(!1);
        },
        insert(f) {
          const {
            index: p,
            displayValue: g,
            exportValue: b
          } = f.detail.insert, E = i.children[p], A = document.createElement("option");
          A.textContent = g, A.value = b, E ? E.before(A) : i.append(A), e.setValue(t, {
            value: a(!0),
            items: c(f)
          }), h = a(!1);
        },
        items(f) {
          const {
            items: p
          } = f.detail;
          for (; i.length !== 0; )
            i.remove(0);
          for (const g of p) {
            const {
              displayValue: b,
              exportValue: E
            } = g, A = document.createElement("option");
            A.textContent = b, A.value = E, i.append(A);
          }
          i.options.length > 0 && (i.options[0].selected = !0), e.setValue(t, {
            value: a(!0),
            items: c(f)
          }), h = a(!1);
        },
        indices(f) {
          const p = new Set(f.detail.indices);
          for (const g of f.target.options)
            g.selected = p.has(g.index);
          e.setValue(t, {
            value: a(!0)
          }), h = a(!1);
        },
        editable(f) {
          f.target.disabled = !f.detail.editable;
        }
      };
      this._dispatchEventFromSandbox(u, d);
    }), i.addEventListener("input", (d) => {
      var p;
      const u = a(!0), f = a(!1);
      e.setValue(t, {
        value: u
      }), d.preventDefault(), (p = this.linkService.eventBus) == null || p.dispatch("dispatcheventinsandbox", {
        source: this,
        detail: {
          id: t,
          name: "Keystroke",
          value: h,
          change: f,
          changeEx: u,
          willCommit: !1,
          commitKey: 1,
          keyDown: !1
        }
      });
    }), this._setEventListeners(i, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], (d) => d.target.value)) : i.addEventListener("input", function(d) {
      e.setValue(t, {
        value: a(!0)
      });
    }), this.data.combo && this._setTextStyle(i), this._setBackgroundColor(i), this._setDefaultPropertiesFromJS(i), this.container.append(i), this.container;
  }
}
class Cf extends Ft {
  constructor(e) {
    const {
      data: t,
      elements: s
    } = e;
    super(e, {
      isRenderable: Ft._hasPopupData(t)
    }), this.elements = s, this.popup = null;
  }
  render() {
    this.container.classList.add("popupAnnotation");
    const e = this.popup = new nE({
      container: this.container,
      color: this.data.color,
      titleObj: this.data.titleObj,
      modificationDate: this.data.modificationDate,
      contentsObj: this.data.contentsObj,
      richText: this.data.richText,
      rect: this.data.rect,
      parentRect: this.data.parentRect || null,
      parent: this.parent,
      elements: this.elements,
      open: this.data.open
    }), t = [];
    for (const s of this.elements)
      s.popup = e, t.push(s.data.id), s.addHighlightArea();
    return this.container.setAttribute("aria-controls", t.map((s) => `${Hp}${s}`).join(",")), this.container;
  }
}
var lo, nu, ru, ho, Mr, Ot, bi, co, Sh, Th, uo, yi, ms, Ai, Ph, Ei, Ch, _r, Or, At, hd, Rf, bv, yv, Av, Ev, cd, dd, If;
class nE {
  constructor({
    container: e,
    color: t,
    elements: s,
    titleObj: i,
    modificationDate: n,
    contentsObj: r,
    richText: a,
    parent: h,
    rect: c,
    parentRect: d,
    open: u
  }) {
    y(this, At);
    y(this, lo, m(this, At, Av).bind(this));
    y(this, nu, m(this, At, If).bind(this));
    y(this, ru, m(this, At, dd).bind(this));
    y(this, ho, m(this, At, cd).bind(this));
    y(this, Mr, null);
    y(this, Ot, null);
    y(this, bi, null);
    y(this, co, null);
    y(this, Sh, null);
    y(this, Th, null);
    y(this, uo, null);
    y(this, yi, !1);
    y(this, ms, null);
    y(this, Ai, null);
    y(this, Ph, null);
    y(this, Ei, null);
    y(this, Ch, null);
    y(this, _r, null);
    y(this, Or, !1);
    var f;
    v(this, Ot, e), v(this, Ch, i), v(this, bi, r), v(this, Ei, a), v(this, Th, h), v(this, Mr, t), v(this, Ph, c), v(this, uo, d), v(this, Sh, s), v(this, co, Sm.toDateObject(n)), this.trigger = s.flatMap((p) => p.getElementsToTriggerPopup());
    for (const p of this.trigger)
      p.addEventListener("click", o(this, ho)), p.addEventListener("mouseenter", o(this, ru)), p.addEventListener("mouseleave", o(this, nu)), p.classList.add("popupTriggerArea");
    for (const p of s)
      (f = p.container) == null || f.addEventListener("keydown", o(this, lo));
    o(this, Ot).hidden = !0, u && m(this, At, cd).call(this);
  }
  render() {
    if (o(this, ms))
      return;
    const e = v(this, ms, document.createElement("div"));
    if (e.className = "popup", o(this, Mr)) {
      const n = e.style.outlineColor = X.makeHexColor(...o(this, Mr));
      CSS.supports("background-color", "color-mix(in srgb, red 30%, white)") ? e.style.backgroundColor = `color-mix(in srgb, ${n} 30%, white)` : e.style.backgroundColor = X.makeHexColor(...o(this, Mr).map((a) => Math.floor(0.7 * (255 - a) + a)));
    }
    const t = document.createElement("span");
    t.className = "header";
    const s = document.createElement("h1");
    if (t.append(s), {
      dir: s.dir,
      str: s.textContent
    } = o(this, Ch), e.append(t), o(this, co)) {
      const n = document.createElement("span");
      n.classList.add("popupDate"), n.setAttribute("data-l10n-id", "pdfjs-annotation-date-time-string"), n.setAttribute("data-l10n-args", JSON.stringify({
        dateObj: o(this, co).valueOf()
      })), t.append(n);
    }
    const i = o(this, At, hd);
    if (i)
      fv.render({
        xfaHtml: i,
        intent: "richText",
        div: e
      }), e.lastChild.classList.add("richText", "popupContent");
    else {
      const n = this._formatContents(o(this, bi));
      e.append(n);
    }
    o(this, Ot).append(e);
  }
  _formatContents({
    str: e,
    dir: t
  }) {
    const s = document.createElement("p");
    s.classList.add("popupContent"), s.dir = t;
    const i = e.split(/(?:\r\n?|\n)/);
    for (let n = 0, r = i.length; n < r; ++n) {
      const a = i[n];
      s.append(document.createTextNode(a)), n < r - 1 && s.append(document.createElement("br"));
    }
    return s;
  }
  updateEdited({
    rect: e,
    popupContent: t
  }) {
    var s;
    o(this, _r) || v(this, _r, {
      contentsObj: o(this, bi),
      richText: o(this, Ei)
    }), e && v(this, Ai, null), t && (v(this, Ei, m(this, At, yv).call(this, t)), v(this, bi, null)), (s = o(this, ms)) == null || s.remove(), v(this, ms, null);
  }
  resetEdited() {
    var e;
    o(this, _r) && ({
      contentsObj: de(this, bi)._,
      richText: de(this, Ei)._
    } = o(this, _r), v(this, _r, null), (e = o(this, ms)) == null || e.remove(), v(this, ms, null), v(this, Ai, null));
  }
  forceHide() {
    v(this, Or, this.isVisible), o(this, Or) && (o(this, Ot).hidden = !0);
  }
  maybeShow() {
    o(this, Or) && (o(this, ms) || m(this, At, dd).call(this), v(this, Or, !1), o(this, Ot).hidden = !1);
  }
  get isVisible() {
    return o(this, Ot).hidden === !1;
  }
}
lo = new WeakMap(), nu = new WeakMap(), ru = new WeakMap(), ho = new WeakMap(), Mr = new WeakMap(), Ot = new WeakMap(), bi = new WeakMap(), co = new WeakMap(), Sh = new WeakMap(), Th = new WeakMap(), uo = new WeakMap(), yi = new WeakMap(), ms = new WeakMap(), Ai = new WeakMap(), Ph = new WeakMap(), Ei = new WeakMap(), Ch = new WeakMap(), _r = new WeakMap(), Or = new WeakMap(), At = new WeakSet(), hd = function() {
  const e = o(this, Ei), t = o(this, bi);
  return e != null && e.str && (!(t != null && t.str) || t.str === e.str) && o(this, Ei).html || null;
}, Rf = function() {
  var e, t, s;
  return ((s = (t = (e = o(this, At, hd)) == null ? void 0 : e.attributes) == null ? void 0 : t.style) == null ? void 0 : s.fontSize) || 0;
}, bv = function() {
  var e, t, s;
  return ((s = (t = (e = o(this, At, hd)) == null ? void 0 : e.attributes) == null ? void 0 : t.style) == null ? void 0 : s.color) || null;
}, yv = function(e) {
  const t = [], s = {
    str: e,
    html: {
      name: "div",
      attributes: {
        dir: "auto"
      },
      children: [{
        name: "p",
        children: t
      }]
    }
  }, i = {
    style: {
      color: o(this, At, bv),
      fontSize: o(this, At, Rf) ? `calc(${o(this, At, Rf)}px * var(--scale-factor))` : ""
    }
  };
  for (const n of e.split(`
`))
    t.push({
      name: "span",
      value: n,
      attributes: i
    });
  return s;
}, Av = function(e) {
  e.altKey || e.shiftKey || e.ctrlKey || e.metaKey || (e.key === "Enter" || e.key === "Escape" && o(this, yi)) && m(this, At, cd).call(this);
}, Ev = function() {
  if (o(this, Ai) !== null)
    return;
  const {
    page: {
      view: e
    },
    viewport: {
      rawDims: {
        pageWidth: t,
        pageHeight: s,
        pageX: i,
        pageY: n
      }
    }
  } = o(this, Th);
  let r = !!o(this, uo), a = r ? o(this, uo) : o(this, Ph);
  for (const g of o(this, Sh))
    if (!a || X.intersect(g.data.rect, a) !== null) {
      a = g.data.rect, r = !0;
      break;
    }
  const h = X.normalizeRect([a[0], e[3] - a[1] + e[1], a[2], e[3] - a[3] + e[1]]), d = r ? a[2] - a[0] + 5 : 0, u = h[0] + d, f = h[1];
  v(this, Ai, [100 * (u - i) / t, 100 * (f - n) / s]);
  const {
    style: p
  } = o(this, Ot);
  p.left = `${o(this, Ai)[0]}%`, p.top = `${o(this, Ai)[1]}%`;
}, cd = function() {
  v(this, yi, !o(this, yi)), o(this, yi) ? (m(this, At, dd).call(this), o(this, Ot).addEventListener("click", o(this, ho)), o(this, Ot).addEventListener("keydown", o(this, lo))) : (m(this, At, If).call(this), o(this, Ot).removeEventListener("click", o(this, ho)), o(this, Ot).removeEventListener("keydown", o(this, lo)));
}, dd = function() {
  o(this, ms) || this.render(), this.isVisible ? o(this, yi) && o(this, Ot).classList.add("focused") : (m(this, At, Ev).call(this), o(this, Ot).hidden = !1, o(this, Ot).style.zIndex = parseInt(o(this, Ot).style.zIndex) + 1e3);
}, If = function() {
  o(this, Ot).classList.remove("focused"), !(o(this, yi) || !this.isVisible) && (o(this, Ot).hidden = !0, o(this, Ot).style.zIndex = parseInt(o(this, Ot).style.zIndex) - 1e3);
};
class wv extends Ft {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0
    }), this.textContent = e.data.textContent, this.textPosition = e.data.textPosition, this.annotationEditorType = it.FREETEXT;
  }
  render() {
    if (this.container.classList.add("freeTextAnnotation"), this.textContent) {
      const e = document.createElement("div");
      e.classList.add("annotationTextContent"), e.setAttribute("role", "comment");
      for (const t of this.textContent) {
        const s = document.createElement("span");
        s.textContent = t, e.append(s);
      }
      this.container.append(e);
    }
    return !this.data.popupRef && this.hasPopupData && this._createPopup(), this._editOnDoubleClick(), this.container;
  }
}
var Rh;
class rE extends Ft {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    });
    y(this, Rh, null);
  }
  render() {
    this.container.classList.add("lineAnnotation");
    const t = this.data, {
      width: s,
      height: i
    } = Bi(t.rect), n = this.svgFactory.create(s, i, !0), r = v(this, Rh, this.svgFactory.createElement("svg:line"));
    return r.setAttribute("x1", t.rect[2] - t.lineCoordinates[0]), r.setAttribute("y1", t.rect[3] - t.lineCoordinates[1]), r.setAttribute("x2", t.rect[2] - t.lineCoordinates[2]), r.setAttribute("y2", t.rect[3] - t.lineCoordinates[3]), r.setAttribute("stroke-width", t.borderStyle.width || 1), r.setAttribute("stroke", "transparent"), r.setAttribute("fill", "transparent"), n.append(r), this.container.append(n), !t.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
  getElementsToTriggerPopup() {
    return o(this, Rh);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
Rh = new WeakMap();
var Ih;
class aE extends Ft {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    });
    y(this, Ih, null);
  }
  render() {
    this.container.classList.add("squareAnnotation");
    const t = this.data, {
      width: s,
      height: i
    } = Bi(t.rect), n = this.svgFactory.create(s, i, !0), r = t.borderStyle.width, a = v(this, Ih, this.svgFactory.createElement("svg:rect"));
    return a.setAttribute("x", r / 2), a.setAttribute("y", r / 2), a.setAttribute("width", s - r), a.setAttribute("height", i - r), a.setAttribute("stroke-width", r || 1), a.setAttribute("stroke", "transparent"), a.setAttribute("fill", "transparent"), n.append(a), this.container.append(n), !t.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
  getElementsToTriggerPopup() {
    return o(this, Ih);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
Ih = new WeakMap();
var Lh;
class oE extends Ft {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    });
    y(this, Lh, null);
  }
  render() {
    this.container.classList.add("circleAnnotation");
    const t = this.data, {
      width: s,
      height: i
    } = Bi(t.rect), n = this.svgFactory.create(s, i, !0), r = t.borderStyle.width, a = v(this, Lh, this.svgFactory.createElement("svg:ellipse"));
    return a.setAttribute("cx", s / 2), a.setAttribute("cy", i / 2), a.setAttribute("rx", s / 2 - r / 2), a.setAttribute("ry", i / 2 - r / 2), a.setAttribute("stroke-width", r || 1), a.setAttribute("stroke", "transparent"), a.setAttribute("fill", "transparent"), n.append(a), this.container.append(n), !t.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
  getElementsToTriggerPopup() {
    return o(this, Lh);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
Lh = new WeakMap();
var Mh;
class xv extends Ft {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    });
    y(this, Mh, null);
    this.containerClassName = "polylineAnnotation", this.svgElementName = "svg:polyline";
  }
  render() {
    this.container.classList.add(this.containerClassName);
    const {
      data: {
        rect: t,
        vertices: s,
        borderStyle: i,
        popupRef: n
      }
    } = this;
    if (!s)
      return this.container;
    const {
      width: r,
      height: a
    } = Bi(t), h = this.svgFactory.create(r, a, !0);
    let c = [];
    for (let u = 0, f = s.length; u < f; u += 2) {
      const p = s[u] - t[0], g = t[3] - s[u + 1];
      c.push(`${p},${g}`);
    }
    c = c.join(" ");
    const d = v(this, Mh, this.svgFactory.createElement(this.svgElementName));
    return d.setAttribute("points", c), d.setAttribute("stroke-width", i.width || 1), d.setAttribute("stroke", "transparent"), d.setAttribute("fill", "transparent"), h.append(d), this.container.append(h), !n && this.hasPopupData && this._createPopup(), this.container;
  }
  getElementsToTriggerPopup() {
    return o(this, Mh);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
Mh = new WeakMap();
class lE extends xv {
  constructor(e) {
    super(e), this.containerClassName = "polygonAnnotation", this.svgElementName = "svg:polygon";
  }
}
class hE extends Ft {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0
    });
  }
  render() {
    return this.container.classList.add("caretAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
}
var _h;
class Qp extends Ft {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    });
    y(this, _h, []);
    this.containerClassName = "inkAnnotation", this.svgElementName = "svg:polyline", this.annotationEditorType = this.data.it === "InkHighlight" ? it.HIGHLIGHT : it.INK;
  }
  render() {
    this.container.classList.add(this.containerClassName);
    const {
      data: {
        rect: t,
        inkLists: s,
        borderStyle: i,
        popupRef: n
      }
    } = this, {
      width: r,
      height: a
    } = Bi(t), h = this.svgFactory.create(r, a, !0);
    for (const c of s) {
      let d = [];
      for (let f = 0, p = c.length; f < p; f += 2) {
        const g = c[f] - t[0], b = t[3] - c[f + 1];
        d.push(`${g},${b}`);
      }
      d = d.join(" ");
      const u = this.svgFactory.createElement(this.svgElementName);
      o(this, _h).push(u), u.setAttribute("points", d), u.setAttribute("stroke-width", i.width || 1), u.setAttribute("stroke", "transparent"), u.setAttribute("fill", "transparent"), !n && this.hasPopupData && this._createPopup(), h.append(u);
    }
    return this.container.append(h), this._editOnDoubleClick(), this.container;
  }
  getElementsToTriggerPopup() {
    return o(this, _h);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
_h = new WeakMap();
class Sv extends Ft {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0,
      createQuadrilaterals: !0
    }), this.annotationEditorType = it.HIGHLIGHT;
  }
  render() {
    return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("highlightAnnotation"), this._editOnDoubleClick(), this.container;
  }
}
class cE extends Ft {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0,
      createQuadrilaterals: !0
    });
  }
  render() {
    return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("underlineAnnotation"), this.container;
  }
}
class dE extends Ft {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0,
      createQuadrilaterals: !0
    });
  }
  render() {
    return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("squigglyAnnotation"), this.container;
  }
}
class uE extends Ft {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0,
      createQuadrilaterals: !0
    });
  }
  render() {
    return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("strikeoutAnnotation"), this.container;
  }
}
class Tv extends Ft {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0
    }), this.annotationEditorType = it.STAMP;
  }
  render() {
    return this.container.classList.add("stampAnnotation"), this.container.setAttribute("role", "img"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this._editOnDoubleClick(), this.container;
  }
}
var Oh, Nh, Lf;
class fE extends Ft {
  constructor(t) {
    var i;
    super(t, {
      isRenderable: !0
    });
    y(this, Nh);
    y(this, Oh, null);
    const {
      file: s
    } = this.data;
    this.filename = s.filename, this.content = s.content, (i = this.linkService.eventBus) == null || i.dispatch("fileattachmentannotation", {
      source: this,
      ...s
    });
  }
  render() {
    this.container.classList.add("fileAttachmentAnnotation");
    const {
      container: t,
      data: s
    } = this;
    let i;
    s.hasAppearance || s.fillAlpha === 0 ? i = document.createElement("div") : (i = document.createElement("img"), i.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(s.name) ? "paperclip" : "pushpin"}.svg`, s.fillAlpha && s.fillAlpha < 1 && (i.style = `filter: opacity(${Math.round(s.fillAlpha * 100)}%);`)), i.addEventListener("dblclick", m(this, Nh, Lf).bind(this)), v(this, Oh, i);
    const {
      isMac: n
    } = ke.platform;
    return t.addEventListener("keydown", (r) => {
      r.key === "Enter" && (n ? r.metaKey : r.ctrlKey) && m(this, Nh, Lf).call(this);
    }), !s.popupRef && this.hasPopupData ? this._createPopup() : i.classList.add("popupTriggerArea"), t.append(i), t;
  }
  getElementsToTriggerPopup() {
    return o(this, Oh);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
Oh = new WeakMap(), Nh = new WeakSet(), Lf = function() {
  var t;
  (t = this.downloadManager) == null || t.openOrDownloadData(this.content, this.filename);
};
var Dh, Nr, Dr, kh, ma, Pv, Mf, dm;
let pE = (dm = class {
  constructor({
    div: e,
    accessibilityManager: t,
    annotationCanvasMap: s,
    annotationEditorUIManager: i,
    page: n,
    viewport: r,
    structTreeLayer: a
  }) {
    y(this, ma);
    y(this, Dh, null);
    y(this, Nr, null);
    y(this, Dr, /* @__PURE__ */ new Map());
    y(this, kh, null);
    this.div = e, v(this, Dh, t), v(this, Nr, s), v(this, kh, a || null), this.page = n, this.viewport = r, this.zIndex = 0, this._annotationEditorUIManager = i;
  }
  hasEditableAnnotations() {
    return o(this, Dr).size > 0;
  }
  async render(e) {
    var r;
    const {
      annotations: t
    } = e, s = this.div;
    pa(s, this.viewport);
    const i = /* @__PURE__ */ new Map(), n = {
      data: null,
      layer: s,
      linkService: e.linkService,
      downloadManager: e.downloadManager,
      imageResourcesPath: e.imageResourcesPath || "",
      renderForms: e.renderForms !== !1,
      svgFactory: new $p(),
      annotationStorage: e.annotationStorage || new Wp(),
      enableScripting: e.enableScripting === !0,
      hasJSActions: e.hasJSActions,
      fieldObjects: e.fieldObjects,
      parent: this,
      elements: null
    };
    for (const a of t) {
      if (a.noHTML)
        continue;
      const h = a.annotationType === Wt.POPUP;
      if (h) {
        const u = i.get(a.id);
        if (!u)
          continue;
        n.elements = u;
      } else {
        const {
          width: u,
          height: f
        } = Bi(a.rect);
        if (u <= 0 || f <= 0)
          continue;
      }
      n.data = a;
      const c = ZA.create(n);
      if (!c.isRenderable)
        continue;
      if (!h && a.popupRef) {
        const u = i.get(a.popupRef);
        u ? u.push(c) : i.set(a.popupRef, [c]);
      }
      const d = c.render();
      a.hidden && (d.style.visibility = "hidden"), await m(this, ma, Pv).call(this, d, a.id), c._isEditable && (o(this, Dr).set(c.data.id, c), (r = this._annotationEditorUIManager) == null || r.renderAnnotationElement(c));
    }
    m(this, ma, Mf).call(this);
  }
  update({
    viewport: e
  }) {
    const t = this.div;
    this.viewport = e, pa(t, {
      rotation: e.rotation
    }), m(this, ma, Mf).call(this), t.hidden = !1;
  }
  getEditableAnnotations() {
    return Array.from(o(this, Dr).values());
  }
  getEditableAnnotation(e) {
    return o(this, Dr).get(e);
  }
}, Dh = new WeakMap(), Nr = new WeakMap(), Dr = new WeakMap(), kh = new WeakMap(), ma = new WeakSet(), Pv = async function(e, t) {
  var r, a;
  const s = e.firstChild || e, i = s.id = `${Hp}${t}`, n = await ((r = o(this, kh)) == null ? void 0 : r.getAriaAttributes(i));
  if (n)
    for (const [h, c] of n)
      s.setAttribute(h, c);
  this.div.append(e), (a = o(this, Dh)) == null || a.moveElementInDOM(this.div, e, s, !1);
}, Mf = function() {
  if (!o(this, Nr))
    return;
  const e = this.div;
  for (const [t, s] of o(this, Nr)) {
    const i = e.querySelector(`[data-annotation-id="${t}"]`);
    if (!i)
      continue;
    s.className = "annotationContent";
    const {
      firstChild: n
    } = i;
    n ? n.nodeName === "CANVAS" ? n.replaceWith(s) : n.classList.contains("annotationContent") ? n.after(s) : n.before(s) : i.append(s);
  }
  o(this, Nr).clear();
}, dm);
const Hc = /\r\n?|\n/g;
var vs, $e, Fh, kr, Ve, Vt, Cv, Rv, Iv, ud, Vi, fd, pd, Lv, Of, Mv;
const St = class St extends mt {
  constructor(t) {
    super({
      ...t,
      name: "freeTextEditor"
    });
    y(this, Vt);
    y(this, vs);
    y(this, $e, "");
    y(this, Fh, `${this.id}-editor`);
    y(this, kr, null);
    y(this, Ve);
    v(this, vs, t.color || St._defaultColor || mt._defaultLineColor), v(this, Ve, t.fontSize || St._defaultFontSize);
  }
  static get _keyboardManager() {
    const t = St.prototype, s = (r) => r.isEmpty(), i = kl.TRANSLATE_SMALL, n = kl.TRANSLATE_BIG;
    return ht(this, "_keyboardManager", new Oc([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], t.commitOrRemove, {
      bubbles: !0
    }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], t.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], t._translateEmpty, {
      args: [-i, 0],
      checker: s
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], t._translateEmpty, {
      args: [-n, 0],
      checker: s
    }], [["ArrowRight", "mac+ArrowRight"], t._translateEmpty, {
      args: [i, 0],
      checker: s
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], t._translateEmpty, {
      args: [n, 0],
      checker: s
    }], [["ArrowUp", "mac+ArrowUp"], t._translateEmpty, {
      args: [0, -i],
      checker: s
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], t._translateEmpty, {
      args: [0, -n],
      checker: s
    }], [["ArrowDown", "mac+ArrowDown"], t._translateEmpty, {
      args: [0, i],
      checker: s
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], t._translateEmpty, {
      args: [0, n],
      checker: s
    }]]));
  }
  static initialize(t, s) {
    mt.initialize(t, s, {
      strings: ["pdfjs-free-text-default-content"]
    });
    const i = getComputedStyle(document.documentElement);
    this._internalPadding = parseFloat(i.getPropertyValue("--freetext-padding"));
  }
  static updateDefaultParams(t, s) {
    switch (t) {
      case J.FREETEXT_SIZE:
        St._defaultFontSize = s;
        break;
      case J.FREETEXT_COLOR:
        St._defaultColor = s;
        break;
    }
  }
  updateParams(t, s) {
    switch (t) {
      case J.FREETEXT_SIZE:
        m(this, Vt, Cv).call(this, s);
        break;
      case J.FREETEXT_COLOR:
        m(this, Vt, Rv).call(this, s);
        break;
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[J.FREETEXT_SIZE, St._defaultFontSize], [J.FREETEXT_COLOR, St._defaultColor || mt._defaultLineColor]];
  }
  get propertiesToUpdate() {
    return [[J.FREETEXT_SIZE, o(this, Ve)], [J.FREETEXT_COLOR, o(this, vs)]];
  }
  _translateEmpty(t, s) {
    this._uiManager.translateSelectedEditors(t, s, !0);
  }
  getInitialTranslation() {
    const t = this.parentScale;
    return [-St._internalPadding * t, -(St._internalPadding + o(this, Ve)) * t];
  }
  rebuild() {
    this.parent && (super.rebuild(), this.div !== null && (this.isAttachedToDOM || this.parent.add(this)));
  }
  enableEditMode() {
    if (this.isInEditMode())
      return;
    this.parent.setEditingState(!1), this.parent.updateToolbar(it.FREETEXT), super.enableEditMode(), this.overlayDiv.classList.remove("enabled"), this.editorDiv.contentEditable = !0, this._isDraggable = !1, this.div.removeAttribute("aria-activedescendant"), v(this, kr, new AbortController());
    const t = this._uiManager.combinedSignal(o(this, kr));
    this.editorDiv.addEventListener("keydown", this.editorDivKeydown.bind(this), {
      signal: t
    }), this.editorDiv.addEventListener("focus", this.editorDivFocus.bind(this), {
      signal: t
    }), this.editorDiv.addEventListener("blur", this.editorDivBlur.bind(this), {
      signal: t
    }), this.editorDiv.addEventListener("input", this.editorDivInput.bind(this), {
      signal: t
    }), this.editorDiv.addEventListener("paste", this.editorDivPaste.bind(this), {
      signal: t
    });
  }
  disableEditMode() {
    var t;
    this.isInEditMode() && (this.parent.setEditingState(!0), super.disableEditMode(), this.overlayDiv.classList.add("enabled"), this.editorDiv.contentEditable = !1, this.div.setAttribute("aria-activedescendant", o(this, Fh)), this._isDraggable = !0, (t = o(this, kr)) == null || t.abort(), v(this, kr, null), this.div.focus({
      preventScroll: !0
    }), this.isEditing = !1, this.parent.div.classList.add("freetextEditing"));
  }
  focusin(t) {
    this._focusEventsAllowed && (super.focusin(t), t.target !== this.editorDiv && this.editorDiv.focus());
  }
  onceAdded() {
    var t;
    this.width || (this.enableEditMode(), this.editorDiv.focus(), (t = this._initialOptions) != null && t.isCentered && this.center(), this._initialOptions = null);
  }
  isEmpty() {
    return !this.editorDiv || this.editorDiv.innerText.trim() === "";
  }
  remove() {
    this.isEditing = !1, this.parent && (this.parent.setEditingState(!0), this.parent.div.classList.add("freetextEditing")), super.remove();
  }
  commit() {
    if (!this.isInEditMode())
      return;
    super.commit(), this.disableEditMode();
    const t = o(this, $e), s = v(this, $e, m(this, Vt, Iv).call(this).trimEnd());
    if (t === s)
      return;
    const i = (n) => {
      if (v(this, $e, n), !n) {
        this.remove();
        return;
      }
      m(this, Vt, pd).call(this), this._uiManager.rebuild(this), m(this, Vt, ud).call(this);
    };
    this.addCommands({
      cmd: () => {
        i(s);
      },
      undo: () => {
        i(t);
      },
      mustExec: !1
    }), m(this, Vt, ud).call(this);
  }
  shouldGetKeyboardEvents() {
    return this.isInEditMode();
  }
  enterInEditMode() {
    this.enableEditMode(), this.editorDiv.focus();
  }
  dblclick(t) {
    this.enterInEditMode();
  }
  keydown(t) {
    t.target === this.div && t.key === "Enter" && (this.enterInEditMode(), t.preventDefault());
  }
  editorDivKeydown(t) {
    St._keyboardManager.exec(this, t);
  }
  editorDivFocus(t) {
    this.isEditing = !0;
  }
  editorDivBlur(t) {
    this.isEditing = !1;
  }
  editorDivInput(t) {
    this.parent.div.classList.toggle("freetextEditing", this.isEmpty());
  }
  disableEditing() {
    this.editorDiv.setAttribute("role", "comment"), this.editorDiv.removeAttribute("aria-multiline");
  }
  enableEditing() {
    this.editorDiv.setAttribute("role", "textbox"), this.editorDiv.setAttribute("aria-multiline", !0);
  }
  render() {
    if (this.div)
      return this.div;
    let t, s;
    this.width && (t = this.x, s = this.y), super.render(), this.editorDiv = document.createElement("div"), this.editorDiv.className = "internal", this.editorDiv.setAttribute("id", o(this, Fh)), this.editorDiv.setAttribute("data-l10n-id", "pdfjs-free-text"), this.enableEditing(), mt._l10nPromise.get("pdfjs-free-text-default-content").then((n) => {
      var r;
      return (r = this.editorDiv) == null ? void 0 : r.setAttribute("default-content", n);
    }), this.editorDiv.contentEditable = !0;
    const {
      style: i
    } = this.editorDiv;
    if (i.fontSize = `calc(${o(this, Ve)}px * var(--scale-factor))`, i.color = o(this, vs), this.div.append(this.editorDiv), this.overlayDiv = document.createElement("div"), this.overlayDiv.classList.add("overlay", "enabled"), this.div.append(this.overlayDiv), jd(this, this.div, ["dblclick", "keydown"]), this.width) {
      const [n, r] = this.parentDimensions;
      if (this.annotationElementId) {
        const {
          position: a
        } = this._initialData;
        let [h, c] = this.getInitialTranslation();
        [h, c] = this.pageTranslationToScreen(h, c);
        const [d, u] = this.pageDimensions, [f, p] = this.pageTranslation;
        let g, b;
        switch (this.rotation) {
          case 0:
            g = t + (a[0] - f) / d, b = s + this.height - (a[1] - p) / u;
            break;
          case 90:
            g = t + (a[0] - f) / d, b = s - (a[1] - p) / u, [h, c] = [c, -h];
            break;
          case 180:
            g = t - this.width + (a[0] - f) / d, b = s - (a[1] - p) / u, [h, c] = [-h, -c];
            break;
          case 270:
            g = t + (a[0] - f - this.height * u) / d, b = s + (a[1] - p - this.width * d) / u, [h, c] = [-c, h];
            break;
        }
        this.setAt(g * n, b * r, h, c);
      } else
        this.setAt(t * n, s * r, this.width * n, this.height * r);
      m(this, Vt, pd).call(this), this._isDraggable = !0, this.editorDiv.contentEditable = !1;
    } else
      this._isDraggable = !1, this.editorDiv.contentEditable = !0;
    return this.div;
  }
  editorDivPaste(t) {
    var g, b, E;
    const s = t.clipboardData || window.clipboardData, {
      types: i
    } = s;
    if (i.length === 1 && i[0] === "text/plain")
      return;
    t.preventDefault();
    const n = m(g = St, Vi, Of).call(g, s.getData("text") || "").replaceAll(Hc, `
`);
    if (!n)
      return;
    const r = window.getSelection();
    if (!r.rangeCount)
      return;
    this.editorDiv.normalize(), r.deleteFromDocument();
    const a = r.getRangeAt(0);
    if (!n.includes(`
`)) {
      a.insertNode(document.createTextNode(n)), this.editorDiv.normalize(), r.collapseToStart();
      return;
    }
    const {
      startContainer: h,
      startOffset: c
    } = a, d = [], u = [];
    if (h.nodeType === Node.TEXT_NODE) {
      const A = h.parentElement;
      if (u.push(h.nodeValue.slice(c).replaceAll(Hc, "")), A !== this.editorDiv) {
        let w = d;
        for (const x of this.editorDiv.childNodes) {
          if (x === A) {
            w = u;
            continue;
          }
          w.push(m(b = St, Vi, fd).call(b, x));
        }
      }
      d.push(h.nodeValue.slice(0, c).replaceAll(Hc, ""));
    } else if (h === this.editorDiv) {
      let A = d, w = 0;
      for (const x of this.editorDiv.childNodes)
        w++ === c && (A = u), A.push(m(E = St, Vi, fd).call(E, x));
    }
    v(this, $e, `${d.join(`
`)}${n}${u.join(`
`)}`), m(this, Vt, pd).call(this);
    const f = new Range();
    let p = d.reduce((A, w) => A + w.length, 0);
    for (const {
      firstChild: A
    } of this.editorDiv.childNodes)
      if (A.nodeType === Node.TEXT_NODE) {
        const w = A.nodeValue.length;
        if (p <= w) {
          f.setStart(A, p), f.setEnd(A, p);
          break;
        }
        p -= w;
      }
    r.removeAllRanges(), r.addRange(f);
  }
  get contentDiv() {
    return this.editorDiv;
  }
  static async deserialize(t, s, i) {
    var a;
    let n = null;
    if (t instanceof wv) {
      const {
        data: {
          defaultAppearanceData: {
            fontSize: h,
            fontColor: c
          },
          rect: d,
          rotation: u,
          id: f,
          popupRef: p
        },
        textContent: g,
        textPosition: b,
        parent: {
          page: {
            pageNumber: E
          }
        }
      } = t;
      if (!g || g.length === 0)
        return null;
      n = t = {
        annotationType: it.FREETEXT,
        color: Array.from(c),
        fontSize: h,
        value: g.join(`
`),
        position: b,
        pageIndex: E - 1,
        rect: d.slice(0),
        rotation: u,
        id: f,
        deleted: !1,
        popupRef: p
      };
    }
    const r = await super.deserialize(t, s, i);
    return v(r, Ve, t.fontSize), v(r, vs, X.makeHexColor(...t.color)), v(r, $e, m(a = St, Vi, Of).call(a, t.value)), r.annotationElementId = t.id || null, r._initialData = n, r;
  }
  serialize(t = !1) {
    if (this.isEmpty())
      return null;
    if (this.deleted)
      return this.serializeDeleted();
    const s = St._internalPadding * this.parentScale, i = this.getRect(s, s), n = mt._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : o(this, vs)), r = {
      annotationType: it.FREETEXT,
      color: n,
      fontSize: o(this, Ve),
      value: m(this, Vt, Lv).call(this),
      pageIndex: this.pageIndex,
      rect: i,
      rotation: this.rotation,
      structTreeParentId: this._structTreeParentId
    };
    return t ? r : this.annotationElementId && !m(this, Vt, Mv).call(this, r) ? null : (r.id = this.annotationElementId, r);
  }
  renderAnnotationElement(t) {
    const s = super.renderAnnotationElement(t);
    if (this.deleted)
      return s;
    const {
      style: i
    } = s;
    i.fontSize = `calc(${o(this, Ve)}px * var(--scale-factor))`, i.color = o(this, vs), s.replaceChildren();
    for (const r of o(this, $e).split(`
`)) {
      const a = document.createElement("div");
      a.append(r ? document.createTextNode(r) : document.createElement("br")), s.append(a);
    }
    const n = St._internalPadding * this.parentScale;
    return t.updateEdited({
      rect: this.getRect(n, n),
      popupContent: o(this, $e)
    }), s;
  }
  resetAnnotationElement(t) {
    super.resetAnnotationElement(t), t.resetEdited();
  }
};
vs = new WeakMap(), $e = new WeakMap(), Fh = new WeakMap(), kr = new WeakMap(), Ve = new WeakMap(), Vt = new WeakSet(), Cv = function(t) {
  const s = (n) => {
    this.editorDiv.style.fontSize = `calc(${n}px * var(--scale-factor))`, this.translate(0, -(n - o(this, Ve)) * this.parentScale), v(this, Ve, n), m(this, Vt, ud).call(this);
  }, i = o(this, Ve);
  this.addCommands({
    cmd: s.bind(this, t),
    undo: s.bind(this, i),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: J.FREETEXT_SIZE,
    overwriteIfSameType: !0,
    keepUndo: !0
  });
}, Rv = function(t) {
  const s = (n) => {
    v(this, vs, this.editorDiv.style.color = n);
  }, i = o(this, vs);
  this.addCommands({
    cmd: s.bind(this, t),
    undo: s.bind(this, i),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: J.FREETEXT_COLOR,
    overwriteIfSameType: !0,
    keepUndo: !0
  });
}, Iv = function() {
  var i;
  const t = [];
  this.editorDiv.normalize();
  let s = null;
  for (const n of this.editorDiv.childNodes)
    (s == null ? void 0 : s.nodeType) === Node.TEXT_NODE && n.nodeName === "BR" || (t.push(m(i = St, Vi, fd).call(i, n)), s = n);
  return t.join(`
`);
}, ud = function() {
  const [t, s] = this.parentDimensions;
  let i;
  if (this.isAttachedToDOM)
    i = this.div.getBoundingClientRect();
  else {
    const {
      currentLayer: n,
      div: r
    } = this, a = r.style.display, h = r.classList.contains("hidden");
    r.classList.remove("hidden"), r.style.display = "hidden", n.div.append(this.div), i = r.getBoundingClientRect(), r.remove(), r.style.display = a, r.classList.toggle("hidden", h);
  }
  this.rotation % 180 === this.parentRotation % 180 ? (this.width = i.width / t, this.height = i.height / s) : (this.width = i.height / t, this.height = i.width / s), this.fixAndSetPosition();
}, Vi = new WeakSet(), fd = function(t) {
  return (t.nodeType === Node.TEXT_NODE ? t.nodeValue : t.innerText).replaceAll(Hc, "");
}, pd = function() {
  if (this.editorDiv.replaceChildren(), !!o(this, $e))
    for (const t of o(this, $e).split(`
`)) {
      const s = document.createElement("div");
      s.append(t ? document.createTextNode(t) : document.createElement("br")), this.editorDiv.append(s);
    }
}, Lv = function() {
  return o(this, $e).replaceAll("Â ", " ");
}, Of = function(t) {
  return t.replaceAll(" ", "Â ");
}, Mv = function(t) {
  const {
    value: s,
    fontSize: i,
    color: n,
    pageIndex: r
  } = this._initialData;
  return this._hasBeenMoved || t.value !== s || t.fontSize !== i || t.color.some((a, h) => a !== n[h]) || t.pageIndex !== r;
}, y(St, Vi), Z(St, "_freeTextDefaultContent", ""), Z(St, "_internalPadding", 0), Z(St, "_defaultColor", null), Z(St, "_defaultFontSize", 10), Z(St, "_type", "freetext"), Z(St, "_editorType", it.FREETEXT);
let _f = St;
var jh, mn, bs, Te, _v, gd, Ov, Nv, Nf;
class Pg {
  constructor(e, t = 0, s = 0, i = !0) {
    y(this, Te);
    y(this, jh);
    y(this, mn, []);
    y(this, bs, []);
    let n = 1 / 0, r = -1 / 0, a = 1 / 0, h = -1 / 0;
    const d = 10 ** -4;
    for (const {
      x: A,
      y: w,
      width: x,
      height: P
    } of e) {
      const T = Math.floor((A - t) / d) * d, C = Math.ceil((A + x + t) / d) * d, R = Math.floor((w - t) / d) * d, M = Math.ceil((w + P + t) / d) * d, S = [T, R, M, !0], I = [C, R, M, !1];
      o(this, mn).push(S, I), n = Math.min(n, T), r = Math.max(r, C), a = Math.min(a, R), h = Math.max(h, M);
    }
    const u = r - n + 2 * s, f = h - a + 2 * s, p = n - s, g = a - s, b = o(this, mn).at(i ? -1 : -2), E = [b[0], b[2]];
    for (const A of o(this, mn)) {
      const [w, x, P] = A;
      A[0] = (w - p) / u, A[1] = (x - g) / f, A[2] = (P - g) / f;
    }
    v(this, jh, {
      x: p,
      y: g,
      width: u,
      height: f,
      lastPoint: E
    });
  }
  getOutlines() {
    o(this, mn).sort((t, s) => t[0] - s[0] || t[1] - s[1] || t[2] - s[2]);
    const e = [];
    for (const t of o(this, mn))
      t[3] ? (e.push(...m(this, Te, Nf).call(this, t)), m(this, Te, Ov).call(this, t)) : (m(this, Te, Nv).call(this, t), e.push(...m(this, Te, Nf).call(this, t)));
    return m(this, Te, _v).call(this, e);
  }
}
jh = new WeakMap(), mn = new WeakMap(), bs = new WeakMap(), Te = new WeakSet(), _v = function(e) {
  const t = [], s = /* @__PURE__ */ new Set();
  for (const r of e) {
    const [a, h, c] = r;
    t.push([a, h, r], [a, c, r]);
  }
  t.sort((r, a) => r[1] - a[1] || r[0] - a[0]);
  for (let r = 0, a = t.length; r < a; r += 2) {
    const h = t[r][2], c = t[r + 1][2];
    h.push(c), c.push(h), s.add(h), s.add(c);
  }
  const i = [];
  let n;
  for (; s.size > 0; ) {
    const r = s.values().next().value;
    let [a, h, c, d, u] = r;
    s.delete(r);
    let f = a, p = h;
    for (n = [a, c], i.push(n); ; ) {
      let g;
      if (s.has(d))
        g = d;
      else if (s.has(u))
        g = u;
      else
        break;
      s.delete(g), [a, h, c, d, u] = g, f !== a && (n.push(f, p, a, p === h ? h : c), f = a), p = p === h ? c : h;
    }
    n.push(f, p);
  }
  return new gE(i, o(this, jh));
}, gd = function(e) {
  const t = o(this, bs);
  let s = 0, i = t.length - 1;
  for (; s <= i; ) {
    const n = s + i >> 1, r = t[n][0];
    if (r === e)
      return n;
    r < e ? s = n + 1 : i = n - 1;
  }
  return i + 1;
}, Ov = function([, e, t]) {
  const s = m(this, Te, gd).call(this, e);
  o(this, bs).splice(s, 0, [e, t]);
}, Nv = function([, e, t]) {
  const s = m(this, Te, gd).call(this, e);
  for (let i = s; i < o(this, bs).length; i++) {
    const [n, r] = o(this, bs)[i];
    if (n !== e)
      break;
    if (n === e && r === t) {
      o(this, bs).splice(i, 1);
      return;
    }
  }
  for (let i = s - 1; i >= 0; i--) {
    const [n, r] = o(this, bs)[i];
    if (n !== e)
      break;
    if (n === e && r === t) {
      o(this, bs).splice(i, 1);
      return;
    }
  }
}, Nf = function(e) {
  const [t, s, i] = e, n = [[t, s, i]], r = m(this, Te, gd).call(this, i);
  for (let a = 0; a < r; a++) {
    const [h, c] = o(this, bs)[a];
    for (let d = 0, u = n.length; d < u; d++) {
      const [, f, p] = n[d];
      if (!(c <= f || p <= h)) {
        if (f >= h) {
          if (p > c)
            n[d][1] = c;
          else {
            if (u === 1)
              return [];
            n.splice(d, 1), d--, u--;
          }
          continue;
        }
        n[d][2] = h, p > c && n.push([t, c, p]);
      }
    }
  }
  return n;
};
class Dv {
  toSVGPath() {
    throw new Error("Abstract method `toSVGPath` must be implemented.");
  }
  get box() {
    throw new Error("Abstract getter `box` must be implemented.");
  }
  serialize(e, t) {
    throw new Error("Abstract method `serialize` must be implemented.");
  }
  get free() {
    return this instanceof kf;
  }
}
var Bh, fo;
class gE extends Dv {
  constructor(t, s) {
    super();
    y(this, Bh);
    y(this, fo);
    v(this, fo, t), v(this, Bh, s);
  }
  toSVGPath() {
    const t = [];
    for (const s of o(this, fo)) {
      let [i, n] = s;
      t.push(`M${i} ${n}`);
      for (let r = 2; r < s.length; r += 2) {
        const a = s[r], h = s[r + 1];
        a === i ? (t.push(`V${h}`), n = h) : h === n && (t.push(`H${a}`), i = a);
      }
      t.push("Z");
    }
    return t.join(" ");
  }
  serialize([t, s, i, n], r) {
    const a = [], h = i - t, c = n - s;
    for (const d of o(this, fo)) {
      const u = new Array(d.length);
      for (let f = 0; f < d.length; f += 2)
        u[f] = t + d[f] * h, u[f + 1] = n - d[f + 1] * c;
      a.push(u);
    }
    return a;
  }
  get box() {
    return o(this, Bh);
  }
}
Bh = new WeakMap(), fo = new WeakMap();
var Bs, wi, po, go, Hs, lt, Fr, jr, Hh, $h, mo, vo, vn, Vh, au, ou, Uh, Df;
const oi = class oi {
  constructor({
    x: e,
    y: t
  }, s, i, n, r, a = 0) {
    y(this, Uh);
    y(this, Bs);
    y(this, wi, []);
    y(this, po);
    y(this, go);
    y(this, Hs, []);
    y(this, lt, new Float64Array(18));
    y(this, Fr);
    y(this, jr);
    y(this, Hh);
    y(this, $h);
    y(this, mo);
    y(this, vo);
    y(this, vn, []);
    v(this, Bs, s), v(this, vo, n * i), v(this, go, r), o(this, lt).set([NaN, NaN, NaN, NaN, e, t], 6), v(this, po, a), v(this, $h, o(oi, Vh) * i), v(this, Hh, o(oi, ou) * i), v(this, mo, i), o(this, vn).push(e, t);
  }
  get free() {
    return !0;
  }
  isEmpty() {
    return isNaN(o(this, lt)[8]);
  }
  add({
    x: e,
    y: t
  }) {
    var S;
    v(this, Fr, e), v(this, jr, t);
    const [s, i, n, r] = o(this, Bs);
    let [a, h, c, d] = o(this, lt).subarray(8, 12);
    const u = e - c, f = t - d, p = Math.hypot(u, f);
    if (p < o(this, Hh))
      return !1;
    const g = p - o(this, $h), b = g / p, E = b * u, A = b * f;
    let w = a, x = h;
    a = c, h = d, c += E, d += A, (S = o(this, vn)) == null || S.push(e, t);
    const P = -A / g, T = E / g, C = P * o(this, vo), R = T * o(this, vo);
    return o(this, lt).set(o(this, lt).subarray(2, 8), 0), o(this, lt).set([c + C, d + R], 4), o(this, lt).set(o(this, lt).subarray(14, 18), 12), o(this, lt).set([c - C, d - R], 16), isNaN(o(this, lt)[6]) ? (o(this, Hs).length === 0 && (o(this, lt).set([a + C, h + R], 2), o(this, Hs).push(NaN, NaN, NaN, NaN, (a + C - s) / n, (h + R - i) / r), o(this, lt).set([a - C, h - R], 14), o(this, wi).push(NaN, NaN, NaN, NaN, (a - C - s) / n, (h - R - i) / r)), o(this, lt).set([w, x, a, h, c, d], 6), !this.isEmpty()) : (o(this, lt).set([w, x, a, h, c, d], 6), Math.abs(Math.atan2(x - h, w - a) - Math.atan2(A, E)) < Math.PI / 2 ? ([a, h, c, d] = o(this, lt).subarray(2, 6), o(this, Hs).push(NaN, NaN, NaN, NaN, ((a + c) / 2 - s) / n, ((h + d) / 2 - i) / r), [a, h, w, x] = o(this, lt).subarray(14, 18), o(this, wi).push(NaN, NaN, NaN, NaN, ((w + a) / 2 - s) / n, ((x + h) / 2 - i) / r), !0) : ([w, x, a, h, c, d] = o(this, lt).subarray(0, 6), o(this, Hs).push(((w + 5 * a) / 6 - s) / n, ((x + 5 * h) / 6 - i) / r, ((5 * a + c) / 6 - s) / n, ((5 * h + d) / 6 - i) / r, ((a + c) / 2 - s) / n, ((h + d) / 2 - i) / r), [c, d, a, h, w, x] = o(this, lt).subarray(12, 18), o(this, wi).push(((w + 5 * a) / 6 - s) / n, ((x + 5 * h) / 6 - i) / r, ((5 * a + c) / 6 - s) / n, ((5 * h + d) / 6 - i) / r, ((a + c) / 2 - s) / n, ((h + d) / 2 - i) / r), !0));
  }
  toSVGPath() {
    if (this.isEmpty())
      return "";
    const e = o(this, Hs), t = o(this, wi), s = o(this, lt).subarray(4, 6), i = o(this, lt).subarray(16, 18), [n, r, a, h] = o(this, Bs), [c, d, u, f] = m(this, Uh, Df).call(this);
    if (isNaN(o(this, lt)[6]) && !this.isEmpty())
      return `M${(o(this, lt)[2] - n) / a} ${(o(this, lt)[3] - r) / h} L${(o(this, lt)[4] - n) / a} ${(o(this, lt)[5] - r) / h} L${c} ${d} L${u} ${f} L${(o(this, lt)[16] - n) / a} ${(o(this, lt)[17] - r) / h} L${(o(this, lt)[14] - n) / a} ${(o(this, lt)[15] - r) / h} Z`;
    const p = [];
    p.push(`M${e[4]} ${e[5]}`);
    for (let g = 6; g < e.length; g += 6)
      isNaN(e[g]) ? p.push(`L${e[g + 4]} ${e[g + 5]}`) : p.push(`C${e[g]} ${e[g + 1]} ${e[g + 2]} ${e[g + 3]} ${e[g + 4]} ${e[g + 5]}`);
    p.push(`L${(s[0] - n) / a} ${(s[1] - r) / h} L${c} ${d} L${u} ${f} L${(i[0] - n) / a} ${(i[1] - r) / h}`);
    for (let g = t.length - 6; g >= 6; g -= 6)
      isNaN(t[g]) ? p.push(`L${t[g + 4]} ${t[g + 5]}`) : p.push(`C${t[g]} ${t[g + 1]} ${t[g + 2]} ${t[g + 3]} ${t[g + 4]} ${t[g + 5]}`);
    return p.push(`L${t[4]} ${t[5]} Z`), p.join(" ");
  }
  getOutlines() {
    var A;
    const e = o(this, Hs), t = o(this, wi), s = o(this, lt), i = s.subarray(4, 6), n = s.subarray(16, 18), [r, a, h, c] = o(this, Bs), d = new Float64Array((((A = o(this, vn)) == null ? void 0 : A.length) ?? 0) + 2);
    for (let w = 0, x = d.length - 2; w < x; w += 2)
      d[w] = (o(this, vn)[w] - r) / h, d[w + 1] = (o(this, vn)[w + 1] - a) / c;
    d[d.length - 2] = (o(this, Fr) - r) / h, d[d.length - 1] = (o(this, jr) - a) / c;
    const [u, f, p, g] = m(this, Uh, Df).call(this);
    if (isNaN(s[6]) && !this.isEmpty()) {
      const w = new Float64Array(36);
      return w.set([NaN, NaN, NaN, NaN, (s[2] - r) / h, (s[3] - a) / c, NaN, NaN, NaN, NaN, (s[4] - r) / h, (s[5] - a) / c, NaN, NaN, NaN, NaN, u, f, NaN, NaN, NaN, NaN, p, g, NaN, NaN, NaN, NaN, (s[16] - r) / h, (s[17] - a) / c, NaN, NaN, NaN, NaN, (s[14] - r) / h, (s[15] - a) / c], 0), new kf(w, d, o(this, Bs), o(this, mo), o(this, po), o(this, go));
    }
    const b = new Float64Array(o(this, Hs).length + 24 + o(this, wi).length);
    let E = e.length;
    for (let w = 0; w < E; w += 2) {
      if (isNaN(e[w])) {
        b[w] = b[w + 1] = NaN;
        continue;
      }
      b[w] = e[w], b[w + 1] = e[w + 1];
    }
    b.set([NaN, NaN, NaN, NaN, (i[0] - r) / h, (i[1] - a) / c, NaN, NaN, NaN, NaN, u, f, NaN, NaN, NaN, NaN, p, g, NaN, NaN, NaN, NaN, (n[0] - r) / h, (n[1] - a) / c], E), E += 24;
    for (let w = t.length - 6; w >= 6; w -= 6)
      for (let x = 0; x < 6; x += 2) {
        if (isNaN(t[w + x])) {
          b[E] = b[E + 1] = NaN, E += 2;
          continue;
        }
        b[E] = t[w + x], b[E + 1] = t[w + x + 1], E += 2;
      }
    return b.set([NaN, NaN, NaN, NaN, t[4], t[5]], E), new kf(b, d, o(this, Bs), o(this, mo), o(this, po), o(this, go));
  }
};
Bs = new WeakMap(), wi = new WeakMap(), po = new WeakMap(), go = new WeakMap(), Hs = new WeakMap(), lt = new WeakMap(), Fr = new WeakMap(), jr = new WeakMap(), Hh = new WeakMap(), $h = new WeakMap(), mo = new WeakMap(), vo = new WeakMap(), vn = new WeakMap(), Vh = new WeakMap(), au = new WeakMap(), ou = new WeakMap(), Uh = new WeakSet(), Df = function() {
  const e = o(this, lt).subarray(4, 6), t = o(this, lt).subarray(16, 18), [s, i, n, r] = o(this, Bs);
  return [(o(this, Fr) + (e[0] - t[0]) / 2 - s) / n, (o(this, jr) + (e[1] - t[1]) / 2 - i) / r, (o(this, Fr) + (t[0] - e[0]) / 2 - s) / n, (o(this, jr) + (t[1] - e[1]) / 2 - i) / r];
}, y(oi, Vh, 8), y(oi, au, 2), y(oi, ou, o(oi, Vh) + o(oi, au));
let jl = oi;
var bo, Br, xi, zh, Ue, Wh, kt, De, vl, bl, kv;
class kf extends Dv {
  constructor(t, s, i, n, r, a) {
    super();
    y(this, De);
    y(this, bo);
    y(this, Br, null);
    y(this, xi);
    y(this, zh);
    y(this, Ue);
    y(this, Wh);
    y(this, kt);
    v(this, kt, t), v(this, Ue, s), v(this, bo, i), v(this, Wh, n), v(this, xi, r), v(this, zh, a), m(this, De, kv).call(this, a);
    const {
      x: h,
      y: c,
      width: d,
      height: u
    } = o(this, Br);
    for (let f = 0, p = t.length; f < p; f += 2)
      t[f] = (t[f] - h) / d, t[f + 1] = (t[f + 1] - c) / u;
    for (let f = 0, p = s.length; f < p; f += 2)
      s[f] = (s[f] - h) / d, s[f + 1] = (s[f + 1] - c) / u;
  }
  toSVGPath() {
    const t = [`M${o(this, kt)[4]} ${o(this, kt)[5]}`];
    for (let s = 6, i = o(this, kt).length; s < i; s += 6) {
      if (isNaN(o(this, kt)[s])) {
        t.push(`L${o(this, kt)[s + 4]} ${o(this, kt)[s + 5]}`);
        continue;
      }
      t.push(`C${o(this, kt)[s]} ${o(this, kt)[s + 1]} ${o(this, kt)[s + 2]} ${o(this, kt)[s + 3]} ${o(this, kt)[s + 4]} ${o(this, kt)[s + 5]}`);
    }
    return t.push("Z"), t.join(" ");
  }
  serialize([t, s, i, n], r) {
    const a = i - t, h = n - s;
    let c, d;
    switch (r) {
      case 0:
        c = m(this, De, vl).call(this, o(this, kt), t, n, a, -h), d = m(this, De, vl).call(this, o(this, Ue), t, n, a, -h);
        break;
      case 90:
        c = m(this, De, bl).call(this, o(this, kt), t, s, a, h), d = m(this, De, bl).call(this, o(this, Ue), t, s, a, h);
        break;
      case 180:
        c = m(this, De, vl).call(this, o(this, kt), i, s, -a, h), d = m(this, De, vl).call(this, o(this, Ue), i, s, -a, h);
        break;
      case 270:
        c = m(this, De, bl).call(this, o(this, kt), i, n, -a, -h), d = m(this, De, bl).call(this, o(this, Ue), i, n, -a, -h);
        break;
    }
    return {
      outline: Array.from(c),
      points: [Array.from(d)]
    };
  }
  get box() {
    return o(this, Br);
  }
  getNewOutline(t, s) {
    const {
      x: i,
      y: n,
      width: r,
      height: a
    } = o(this, Br), [h, c, d, u] = o(this, bo), f = r * d, p = a * u, g = i * d + h, b = n * u + c, E = new jl({
      x: o(this, Ue)[0] * f + g,
      y: o(this, Ue)[1] * p + b
    }, o(this, bo), o(this, Wh), t, o(this, zh), s ?? o(this, xi));
    for (let A = 2; A < o(this, Ue).length; A += 2)
      E.add({
        x: o(this, Ue)[A] * f + g,
        y: o(this, Ue)[A + 1] * p + b
      });
    return E.getOutlines();
  }
}
bo = new WeakMap(), Br = new WeakMap(), xi = new WeakMap(), zh = new WeakMap(), Ue = new WeakMap(), Wh = new WeakMap(), kt = new WeakMap(), De = new WeakSet(), vl = function(t, s, i, n, r) {
  const a = new Float64Array(t.length);
  for (let h = 0, c = t.length; h < c; h += 2)
    a[h] = s + t[h] * n, a[h + 1] = i + t[h + 1] * r;
  return a;
}, bl = function(t, s, i, n, r) {
  const a = new Float64Array(t.length);
  for (let h = 0, c = t.length; h < c; h += 2)
    a[h] = s + t[h + 1] * n, a[h + 1] = i + t[h] * r;
  return a;
}, kv = function(t) {
  const s = o(this, kt);
  let i = s[4], n = s[5], r = i, a = n, h = i, c = n, d = i, u = n;
  const f = t ? Math.max : Math.min;
  for (let A = 6, w = s.length; A < w; A += 6) {
    if (isNaN(s[A]))
      r = Math.min(r, s[A + 4]), a = Math.min(a, s[A + 5]), h = Math.max(h, s[A + 4]), c = Math.max(c, s[A + 5]), u < s[A + 5] ? (d = s[A + 4], u = s[A + 5]) : u === s[A + 5] && (d = f(d, s[A + 4]));
    else {
      const x = X.bezierBoundingBox(i, n, ...s.slice(A, A + 6));
      r = Math.min(r, x[0]), a = Math.min(a, x[1]), h = Math.max(h, x[2]), c = Math.max(c, x[3]), u < x[3] ? (d = x[2], u = x[3]) : u === x[3] && (d = f(d, x[2]));
    }
    i = s[A + 4], n = s[A + 5];
  }
  const p = r - o(this, xi), g = a - o(this, xi), b = h - r + 2 * o(this, xi), E = c - a + 2 * o(this, xi);
  v(this, Br, {
    x: p,
    y: g,
    width: b,
    height: E,
    lastPoint: [d, u]
  });
};
var Gh, Xh, ys, Hr, yo, Xt, Kh, Ao, Yh, Qh, As, Eo, he, Zh, xt, Ff, jf, jv, Gn, Bv, Xi;
let Fv = (he = class {
  constructor({
    editor: e = null,
    uiManager: t = null
  }) {
    y(this, xt);
    y(this, Gh, m(this, xt, jv).bind(this));
    y(this, Xh, m(this, xt, Bv).bind(this));
    y(this, ys, null);
    y(this, Hr, null);
    y(this, yo);
    y(this, Xt, null);
    y(this, Kh, !1);
    y(this, Ao, !1);
    y(this, Yh, null);
    y(this, Qh);
    y(this, As, null);
    y(this, Eo);
    var s;
    e ? (v(this, Ao, !1), v(this, Eo, J.HIGHLIGHT_COLOR), v(this, Yh, e)) : (v(this, Ao, !0), v(this, Eo, J.HIGHLIGHT_DEFAULT_COLOR)), v(this, As, (e == null ? void 0 : e._uiManager) || t), v(this, Qh, o(this, As)._eventBus), v(this, yo, (e == null ? void 0 : e.color) || ((s = o(this, As)) == null ? void 0 : s.highlightColors.values().next().value) || "#FFFF98"), o(he, Zh) || v(he, Zh, Object.freeze({
      blue: "pdfjs-editor-colorpicker-blue",
      green: "pdfjs-editor-colorpicker-green",
      pink: "pdfjs-editor-colorpicker-pink",
      red: "pdfjs-editor-colorpicker-red",
      yellow: "pdfjs-editor-colorpicker-yellow"
    }));
  }
  static get _keyboardManager() {
    return ht(this, "_keyboardManager", new Oc([[["Escape", "mac+Escape"], he.prototype._hideDropdownFromKeyboard], [[" ", "mac+ "], he.prototype._colorSelectFromKeyboard], [["ArrowDown", "ArrowRight", "mac+ArrowDown", "mac+ArrowRight"], he.prototype._moveToNext], [["ArrowUp", "ArrowLeft", "mac+ArrowUp", "mac+ArrowLeft"], he.prototype._moveToPrevious], [["Home", "mac+Home"], he.prototype._moveToBeginning], [["End", "mac+End"], he.prototype._moveToEnd]]));
  }
  renderButton() {
    const e = v(this, ys, document.createElement("button"));
    e.className = "colorPicker", e.tabIndex = "0", e.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-button"), e.setAttribute("aria-haspopup", !0);
    const t = o(this, As)._signal;
    e.addEventListener("click", m(this, xt, Gn).bind(this), {
      signal: t
    }), e.addEventListener("keydown", o(this, Gh), {
      signal: t
    });
    const s = v(this, Hr, document.createElement("span"));
    return s.className = "swatch", s.setAttribute("aria-hidden", !0), s.style.backgroundColor = o(this, yo), e.append(s), e;
  }
  renderMainDropdown() {
    const e = v(this, Xt, m(this, xt, Ff).call(this));
    return e.setAttribute("aria-orientation", "horizontal"), e.setAttribute("aria-labelledby", "highlightColorPickerLabel"), e;
  }
  _colorSelectFromKeyboard(e) {
    if (e.target === o(this, ys)) {
      m(this, xt, Gn).call(this, e);
      return;
    }
    const t = e.target.getAttribute("data-color");
    t && m(this, xt, jf).call(this, t, e);
  }
  _moveToNext(e) {
    var t, s;
    if (!o(this, xt, Xi)) {
      m(this, xt, Gn).call(this, e);
      return;
    }
    if (e.target === o(this, ys)) {
      (t = o(this, Xt).firstChild) == null || t.focus();
      return;
    }
    (s = e.target.nextSibling) == null || s.focus();
  }
  _moveToPrevious(e) {
    var t, s;
    if (e.target === ((t = o(this, Xt)) == null ? void 0 : t.firstChild) || e.target === o(this, ys)) {
      o(this, xt, Xi) && this._hideDropdownFromKeyboard();
      return;
    }
    o(this, xt, Xi) || m(this, xt, Gn).call(this, e), (s = e.target.previousSibling) == null || s.focus();
  }
  _moveToBeginning(e) {
    var t;
    if (!o(this, xt, Xi)) {
      m(this, xt, Gn).call(this, e);
      return;
    }
    (t = o(this, Xt).firstChild) == null || t.focus();
  }
  _moveToEnd(e) {
    var t;
    if (!o(this, xt, Xi)) {
      m(this, xt, Gn).call(this, e);
      return;
    }
    (t = o(this, Xt).lastChild) == null || t.focus();
  }
  hideDropdown() {
    var e;
    (e = o(this, Xt)) == null || e.classList.add("hidden"), window.removeEventListener("pointerdown", o(this, Xh));
  }
  _hideDropdownFromKeyboard() {
    var e;
    if (!o(this, Ao)) {
      if (!o(this, xt, Xi)) {
        (e = o(this, Yh)) == null || e.unselect();
        return;
      }
      this.hideDropdown(), o(this, ys).focus({
        preventScroll: !0,
        focusVisible: o(this, Kh)
      });
    }
  }
  updateColor(e) {
    if (o(this, Hr) && (o(this, Hr).style.backgroundColor = e), !o(this, Xt))
      return;
    const t = o(this, As).highlightColors.values();
    for (const s of o(this, Xt).children)
      s.setAttribute("aria-selected", t.next().value === e);
  }
  destroy() {
    var e, t;
    (e = o(this, ys)) == null || e.remove(), v(this, ys, null), v(this, Hr, null), (t = o(this, Xt)) == null || t.remove(), v(this, Xt, null);
  }
}, Gh = new WeakMap(), Xh = new WeakMap(), ys = new WeakMap(), Hr = new WeakMap(), yo = new WeakMap(), Xt = new WeakMap(), Kh = new WeakMap(), Ao = new WeakMap(), Yh = new WeakMap(), Qh = new WeakMap(), As = new WeakMap(), Eo = new WeakMap(), Zh = new WeakMap(), xt = new WeakSet(), Ff = function() {
  const e = document.createElement("div"), t = o(this, As)._signal;
  e.addEventListener("contextmenu", os, {
    signal: t
  }), e.className = "dropdown", e.role = "listbox", e.setAttribute("aria-multiselectable", !1), e.setAttribute("aria-orientation", "vertical"), e.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-dropdown");
  for (const [s, i] of o(this, As).highlightColors) {
    const n = document.createElement("button");
    n.tabIndex = "0", n.role = "option", n.setAttribute("data-color", i), n.title = s, n.setAttribute("data-l10n-id", o(he, Zh)[s]);
    const r = document.createElement("span");
    n.append(r), r.className = "swatch", r.style.backgroundColor = i, n.setAttribute("aria-selected", i === o(this, yo)), n.addEventListener("click", m(this, xt, jf).bind(this, i), {
      signal: t
    }), e.append(n);
  }
  return e.addEventListener("keydown", o(this, Gh), {
    signal: t
  }), e;
}, jf = function(e, t) {
  t.stopPropagation(), o(this, Qh).dispatch("switchannotationeditorparams", {
    source: this,
    type: o(this, Eo),
    value: e
  });
}, jv = function(e) {
  he._keyboardManager.exec(this, e);
}, Gn = function(e) {
  if (o(this, xt, Xi)) {
    this.hideDropdown();
    return;
  }
  if (v(this, Kh, e.detail === 0), window.addEventListener("pointerdown", o(this, Xh), {
    signal: o(this, As)._signal
  }), o(this, Xt)) {
    o(this, Xt).classList.remove("hidden");
    return;
  }
  const t = v(this, Xt, m(this, xt, Ff).call(this));
  o(this, ys).append(t);
}, Bv = function(e) {
  var t;
  (t = o(this, Xt)) != null && t.contains(e.target) || this.hideDropdown();
}, Xi = function() {
  return o(this, Xt) && !o(this, Xt).classList.contains("hidden");
}, y(he, Zh, null), he);
var wo, Jh, Si, $r, xo, ts, qh, tc, Vr, Es, me, Le, So, Ti, Kt, To, es, ec, et, Bf, md, Hv, $v, Vv, Hf, Xn, as, Ca, Uv, vd, yl, zv, Wv, Gv, Xv, Kv;
const ft = class ft extends mt {
  constructor(t) {
    super({
      ...t,
      name: "highlightEditor"
    });
    y(this, et);
    y(this, wo, null);
    y(this, Jh, 0);
    y(this, Si);
    y(this, $r, null);
    y(this, xo, null);
    y(this, ts, null);
    y(this, qh, null);
    y(this, tc, 0);
    y(this, Vr, null);
    y(this, Es, null);
    y(this, me, null);
    y(this, Le, !1);
    y(this, So, null);
    y(this, Ti);
    y(this, Kt, null);
    y(this, To, "");
    y(this, es);
    y(this, ec, "");
    this.color = t.color || ft._defaultColor, v(this, es, t.thickness || ft._defaultThickness), v(this, Ti, t.opacity || ft._defaultOpacity), v(this, Si, t.boxes || null), v(this, ec, t.methodOfCreation || ""), v(this, To, t.text || ""), this._isDraggable = !1, t.highlightId > -1 ? (v(this, Le, !0), m(this, et, md).call(this, t), m(this, et, Xn).call(this)) : o(this, Si) && (v(this, wo, t.anchorNode), v(this, Jh, t.anchorOffset), v(this, qh, t.focusNode), v(this, tc, t.focusOffset), m(this, et, Bf).call(this), m(this, et, Xn).call(this), this.rotate(this.rotation));
  }
  static get _keyboardManager() {
    const t = ft.prototype;
    return ht(this, "_keyboardManager", new Oc([[["ArrowLeft", "mac+ArrowLeft"], t._moveCaret, {
      args: [0]
    }], [["ArrowRight", "mac+ArrowRight"], t._moveCaret, {
      args: [1]
    }], [["ArrowUp", "mac+ArrowUp"], t._moveCaret, {
      args: [2]
    }], [["ArrowDown", "mac+ArrowDown"], t._moveCaret, {
      args: [3]
    }]]));
  }
  get telemetryInitialData() {
    return {
      action: "added",
      type: o(this, Le) ? "free_highlight" : "highlight",
      color: this._uiManager.highlightColorNames.get(this.color),
      thickness: o(this, es),
      methodOfCreation: o(this, ec)
    };
  }
  get telemetryFinalData() {
    return {
      type: "highlight",
      color: this._uiManager.highlightColorNames.get(this.color)
    };
  }
  static computeTelemetryFinalData(t) {
    return {
      numberOfColors: t.get("color").size
    };
  }
  static initialize(t, s) {
    var i;
    mt.initialize(t, s), ft._defaultColor || (ft._defaultColor = ((i = s.highlightColors) == null ? void 0 : i.values().next().value) || "#fff066");
  }
  static updateDefaultParams(t, s) {
    switch (t) {
      case J.HIGHLIGHT_DEFAULT_COLOR:
        ft._defaultColor = s;
        break;
      case J.HIGHLIGHT_THICKNESS:
        ft._defaultThickness = s;
        break;
    }
  }
  translateInPage(t, s) {
  }
  get toolbarPosition() {
    return o(this, So);
  }
  updateParams(t, s) {
    switch (t) {
      case J.HIGHLIGHT_COLOR:
        m(this, et, Hv).call(this, s);
        break;
      case J.HIGHLIGHT_THICKNESS:
        m(this, et, $v).call(this, s);
        break;
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[J.HIGHLIGHT_DEFAULT_COLOR, ft._defaultColor], [J.HIGHLIGHT_THICKNESS, ft._defaultThickness]];
  }
  get propertiesToUpdate() {
    return [[J.HIGHLIGHT_COLOR, this.color || ft._defaultColor], [J.HIGHLIGHT_THICKNESS, o(this, es) || ft._defaultThickness], [J.HIGHLIGHT_FREE, o(this, Le)]];
  }
  async addEditToolbar() {
    const t = await super.addEditToolbar();
    return t ? (this._uiManager.highlightColors && (v(this, xo, new Fv({
      editor: this
    })), t.addColorPicker(o(this, xo))), t) : null;
  }
  disableEditing() {
    super.disableEditing(), this.div.classList.toggle("disabled", !0);
  }
  enableEditing() {
    super.enableEditing(), this.div.classList.toggle("disabled", !1);
  }
  fixAndSetPosition() {
    return super.fixAndSetPosition(m(this, et, yl).call(this));
  }
  getBaseTranslation() {
    return [0, 0];
  }
  getRect(t, s) {
    return super.getRect(t, s, m(this, et, yl).call(this));
  }
  onceAdded() {
    this.annotationElementId || this.parent.addUndoableEditor(this), this.div.focus();
  }
  remove() {
    m(this, et, Hf).call(this), this._reportTelemetry({
      action: "deleted"
    }), super.remove();
  }
  rebuild() {
    this.parent && (super.rebuild(), this.div !== null && (m(this, et, Xn).call(this), this.isAttachedToDOM || this.parent.add(this)));
  }
  setParent(t) {
    var i;
    let s = !1;
    this.parent && !t ? m(this, et, Hf).call(this) : t && (m(this, et, Xn).call(this, t), s = !this.parent && ((i = this.div) == null ? void 0 : i.classList.contains("selectedEditor"))), super.setParent(t), this.show(this._isVisible), s && this.select();
  }
  rotate(t) {
    var n, r, a;
    const {
      drawLayer: s
    } = this.parent;
    let i;
    o(this, Le) ? (t = (t - this.rotation + 360) % 360, i = m(n = ft, as, Ca).call(n, o(this, Es).box, t)) : i = m(r = ft, as, Ca).call(r, this, t), s.rotate(o(this, me), t), s.rotate(o(this, Kt), t), s.updateBox(o(this, me), i), s.updateBox(o(this, Kt), m(a = ft, as, Ca).call(a, o(this, ts).box, t));
  }
  render() {
    if (this.div)
      return this.div;
    const t = super.render();
    o(this, To) && (t.setAttribute("aria-label", o(this, To)), t.setAttribute("role", "mark")), o(this, Le) ? t.classList.add("free") : this.div.addEventListener("keydown", m(this, et, Uv).bind(this), {
      signal: this._uiManager._signal
    });
    const s = v(this, Vr, document.createElement("div"));
    t.append(s), s.setAttribute("aria-hidden", "true"), s.className = "internal", s.style.clipPath = o(this, $r);
    const [i, n] = this.parentDimensions;
    return this.setDims(this.width * i, this.height * n), jd(this, o(this, Vr), ["pointerover", "pointerleave"]), this.enableEditing(), t;
  }
  pointerover() {
    this.parent.drawLayer.addClass(o(this, Kt), "hovered");
  }
  pointerleave() {
    this.parent.drawLayer.removeClass(o(this, Kt), "hovered");
  }
  _moveCaret(t) {
    switch (this.parent.unselect(this), t) {
      case 0:
      case 2:
        m(this, et, vd).call(this, !0);
        break;
      case 1:
      case 3:
        m(this, et, vd).call(this, !1);
        break;
    }
  }
  select() {
    var t, s;
    super.select(), o(this, Kt) && ((t = this.parent) == null || t.drawLayer.removeClass(o(this, Kt), "hovered"), (s = this.parent) == null || s.drawLayer.addClass(o(this, Kt), "selected"));
  }
  unselect() {
    var t;
    super.unselect(), o(this, Kt) && ((t = this.parent) == null || t.drawLayer.removeClass(o(this, Kt), "selected"), o(this, Le) || m(this, et, vd).call(this, !1));
  }
  get _mustFixPosition() {
    return !o(this, Le);
  }
  show(t = this._isVisible) {
    super.show(t), this.parent && (this.parent.drawLayer.show(o(this, me), t), this.parent.drawLayer.show(o(this, Kt), t));
  }
  static startHighlighting(t, s, {
    target: i,
    x: n,
    y: r
  }) {
    const {
      x: a,
      y: h,
      width: c,
      height: d
    } = i.getBoundingClientRect(), u = new AbortController(), f = t.combinedSignal(u), p = (b) => {
      b.preventDefault(), b.stopPropagation();
    }, g = (b) => {
      u.abort(), m(this, as, Xv).call(this, t, b);
    };
    window.addEventListener("blur", g, {
      signal: f
    }), window.addEventListener("pointerup", g, {
      signal: f
    }), window.addEventListener("pointerdown", p, {
      capture: !0,
      passive: !1,
      signal: f
    }), window.addEventListener("contextmenu", os, {
      signal: f
    }), i.addEventListener("pointermove", m(this, as, Gv).bind(this, t), {
      signal: f
    }), this._freeHighlight = new jl({
      x: n,
      y: r
    }, [a, h, c, d], t.scale, this._defaultThickness / 2, s, 1e-3), {
      id: this._freeHighlightId,
      clipPathId: this._freeHighlightClipId
    } = t.drawLayer.highlight(this._freeHighlight, this._defaultColor, this._defaultOpacity, !0);
  }
  static async deserialize(t, s, i) {
    var b, E, A, w;
    let n = null;
    if (t instanceof Sv) {
      const {
        data: {
          quadPoints: x,
          rect: P,
          rotation: T,
          id: C,
          color: R,
          opacity: M,
          popupRef: S
        },
        parent: {
          page: {
            pageNumber: I
          }
        }
      } = t;
      n = t = {
        annotationType: it.HIGHLIGHT,
        color: Array.from(R),
        opacity: M,
        quadPoints: x,
        boxes: null,
        pageIndex: I - 1,
        rect: P.slice(0),
        rotation: T,
        id: C,
        deleted: !1,
        popupRef: S
      };
    } else if (t instanceof Qp) {
      const {
        data: {
          inkLists: x,
          rect: P,
          rotation: T,
          id: C,
          color: R,
          borderStyle: {
            rawWidth: M
          },
          popupRef: S
        },
        parent: {
          page: {
            pageNumber: I
          }
        }
      } = t;
      n = t = {
        annotationType: it.HIGHLIGHT,
        color: Array.from(R),
        thickness: M,
        inkLists: x,
        boxes: null,
        pageIndex: I - 1,
        rect: P.slice(0),
        rotation: T,
        id: C,
        deleted: !1,
        popupRef: S
      };
    }
    const {
      color: r,
      quadPoints: a,
      inkLists: h,
      opacity: c
    } = t, d = await super.deserialize(t, s, i);
    d.color = X.makeHexColor(...r), v(d, Ti, c || 1), h && v(d, es, t.thickness), d.annotationElementId = t.id || null, d._initialData = n;
    const [u, f] = d.pageDimensions, [p, g] = d.pageTranslation;
    if (a) {
      const x = v(d, Si, []);
      for (let P = 0; P < a.length; P += 8)
        x.push({
          x: (a[P] - p) / u,
          y: 1 - (a[P + 1] - g) / f,
          width: (a[P + 2] - a[P]) / u,
          height: (a[P + 1] - a[P + 5]) / f
        });
      m(b = d, et, Bf).call(b), m(E = d, et, Xn).call(E), d.rotate(d.rotation);
    } else if (h) {
      v(d, Le, !0);
      const x = h[0], P = {
        x: x[0] - p,
        y: f - (x[1] - g)
      }, T = new jl(P, [0, 0, u, f], 1, o(d, es) / 2, !0, 1e-3);
      for (let M = 0, S = x.length; M < S; M += 2)
        P.x = x[M] - p, P.y = f - (x[M + 1] - g), T.add(P);
      const {
        id: C,
        clipPathId: R
      } = s.drawLayer.highlight(T, d.color, d._defaultOpacity, !0);
      m(A = d, et, md).call(A, {
        highlightOutlines: T.getOutlines(),
        highlightId: C,
        clipPathId: R
      }), m(w = d, et, Xn).call(w);
    }
    return d;
  }
  serialize(t = !1) {
    if (this.isEmpty() || t)
      return null;
    if (this.deleted)
      return this.serializeDeleted();
    const s = this.getRect(0, 0), i = mt._colorManager.convert(this.color), n = {
      annotationType: it.HIGHLIGHT,
      color: i,
      opacity: o(this, Ti),
      thickness: o(this, es),
      quadPoints: m(this, et, zv).call(this),
      outlines: m(this, et, Wv).call(this, s),
      pageIndex: this.pageIndex,
      rect: s,
      rotation: m(this, et, yl).call(this),
      structTreeParentId: this._structTreeParentId
    };
    return this.annotationElementId && !m(this, et, Kv).call(this, n) ? null : (n.id = this.annotationElementId, n);
  }
  renderAnnotationElement(t) {
    return t.updateEdited({
      rect: this.getRect(0, 0)
    }), null;
  }
  static canCreateNewEmptyEditor() {
    return !1;
  }
};
wo = new WeakMap(), Jh = new WeakMap(), Si = new WeakMap(), $r = new WeakMap(), xo = new WeakMap(), ts = new WeakMap(), qh = new WeakMap(), tc = new WeakMap(), Vr = new WeakMap(), Es = new WeakMap(), me = new WeakMap(), Le = new WeakMap(), So = new WeakMap(), Ti = new WeakMap(), Kt = new WeakMap(), To = new WeakMap(), es = new WeakMap(), ec = new WeakMap(), et = new WeakSet(), Bf = function() {
  const t = new Pg(o(this, Si), 1e-3);
  v(this, Es, t.getOutlines()), {
    x: this.x,
    y: this.y,
    width: this.width,
    height: this.height
  } = o(this, Es).box;
  const s = new Pg(o(this, Si), 25e-4, 1e-3, this._uiManager.direction === "ltr");
  v(this, ts, s.getOutlines());
  const {
    lastPoint: i
  } = o(this, ts).box;
  v(this, So, [(i[0] - this.x) / this.width, (i[1] - this.y) / this.height]);
}, md = function({
  highlightOutlines: t,
  highlightId: s,
  clipPathId: i
}) {
  var u, f;
  if (v(this, Es, t), v(this, ts, t.getNewOutline(o(this, es) / 2 + 1.5, 25e-4)), s >= 0)
    v(this, me, s), v(this, $r, i), this.parent.drawLayer.finalizeLine(s, t), v(this, Kt, this.parent.drawLayer.highlightOutline(o(this, ts)));
  else if (this.parent) {
    const p = this.parent.viewport.rotation;
    this.parent.drawLayer.updateLine(o(this, me), t), this.parent.drawLayer.updateBox(o(this, me), m(u = ft, as, Ca).call(u, o(this, Es).box, (p - this.rotation + 360) % 360)), this.parent.drawLayer.updateLine(o(this, Kt), o(this, ts)), this.parent.drawLayer.updateBox(o(this, Kt), m(f = ft, as, Ca).call(f, o(this, ts).box, p));
  }
  const {
    x: r,
    y: a,
    width: h,
    height: c
  } = t.box;
  switch (this.rotation) {
    case 0:
      this.x = r, this.y = a, this.width = h, this.height = c;
      break;
    case 90: {
      const [p, g] = this.parentDimensions;
      this.x = a, this.y = 1 - r, this.width = h * g / p, this.height = c * p / g;
      break;
    }
    case 180:
      this.x = 1 - r, this.y = 1 - a, this.width = h, this.height = c;
      break;
    case 270: {
      const [p, g] = this.parentDimensions;
      this.x = 1 - a, this.y = r, this.width = h * g / p, this.height = c * p / g;
      break;
    }
  }
  const {
    lastPoint: d
  } = o(this, ts).box;
  v(this, So, [(d[0] - r) / h, (d[1] - a) / c]);
}, Hv = function(t) {
  const s = (r, a) => {
    var h, c, d;
    this.color = r, (h = this.parent) == null || h.drawLayer.changeColor(o(this, me), r), (c = o(this, xo)) == null || c.updateColor(r), v(this, Ti, a), (d = this.parent) == null || d.drawLayer.changeOpacity(o(this, me), a);
  }, i = this.color, n = o(this, Ti);
  this.addCommands({
    cmd: s.bind(this, t, ft._defaultOpacity),
    undo: s.bind(this, i, n),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: J.HIGHLIGHT_COLOR,
    overwriteIfSameType: !0,
    keepUndo: !0
  }), this._reportTelemetry({
    action: "color_changed",
    color: this._uiManager.highlightColorNames.get(t)
  }, !0);
}, $v = function(t) {
  const s = o(this, es), i = (n) => {
    v(this, es, n), m(this, et, Vv).call(this, n);
  };
  this.addCommands({
    cmd: i.bind(this, t),
    undo: i.bind(this, s),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: J.INK_THICKNESS,
    overwriteIfSameType: !0,
    keepUndo: !0
  }), this._reportTelemetry({
    action: "thickness_changed",
    thickness: t
  }, !0);
}, Vv = function(t) {
  if (!o(this, Le))
    return;
  m(this, et, md).call(this, {
    highlightOutlines: o(this, Es).getNewOutline(t / 2)
  }), this.fixAndSetPosition();
  const [s, i] = this.parentDimensions;
  this.setDims(this.width * s, this.height * i);
}, Hf = function() {
  o(this, me) === null || !this.parent || (this.parent.drawLayer.remove(o(this, me)), v(this, me, null), this.parent.drawLayer.remove(o(this, Kt)), v(this, Kt, null));
}, Xn = function(t = this.parent) {
  o(this, me) === null && ({
    id: de(this, me)._,
    clipPathId: de(this, $r)._
  } = t.drawLayer.highlight(o(this, Es), this.color, o(this, Ti)), v(this, Kt, t.drawLayer.highlightOutline(o(this, ts))), o(this, Vr) && (o(this, Vr).style.clipPath = o(this, $r)));
}, as = new WeakSet(), Ca = function({
  x: t,
  y: s,
  width: i,
  height: n
}, r) {
  switch (r) {
    case 90:
      return {
        x: 1 - s - n,
        y: t,
        width: n,
        height: i
      };
    case 180:
      return {
        x: 1 - t - i,
        y: 1 - s - n,
        width: i,
        height: n
      };
    case 270:
      return {
        x: s,
        y: 1 - t - i,
        width: n,
        height: i
      };
  }
  return {
    x: t,
    y: s,
    width: i,
    height: n
  };
}, Uv = function(t) {
  ft._keyboardManager.exec(this, t);
}, vd = function(t) {
  if (!o(this, wo))
    return;
  const s = window.getSelection();
  t ? s.setPosition(o(this, wo), o(this, Jh)) : s.setPosition(o(this, qh), o(this, tc));
}, yl = function() {
  return o(this, Le) ? this.rotation : 0;
}, zv = function() {
  if (o(this, Le))
    return null;
  const [t, s] = this.pageDimensions, [i, n] = this.pageTranslation, r = o(this, Si), a = new Float32Array(r.length * 8);
  let h = 0;
  for (const {
    x: c,
    y: d,
    width: u,
    height: f
  } of r) {
    const p = c * t + i, g = (1 - d - f) * s + n;
    a[h] = a[h + 4] = p, a[h + 1] = a[h + 3] = g, a[h + 2] = a[h + 6] = p + u * t, a[h + 5] = a[h + 7] = g + f * s, h += 8;
  }
  return a;
}, Wv = function(t) {
  return o(this, Es).serialize(t, m(this, et, yl).call(this));
}, Gv = function(t, s) {
  this._freeHighlight.add(s) && t.drawLayer.updatePath(this._freeHighlightId, this._freeHighlight);
}, Xv = function(t, s) {
  this._freeHighlight.isEmpty() ? t.drawLayer.removeFreeHighlight(this._freeHighlightId) : t.createAndAddNewEditor(s, !1, {
    highlightId: this._freeHighlightId,
    highlightOutlines: this._freeHighlight.getOutlines(),
    clipPathId: this._freeHighlightClipId,
    methodOfCreation: "main_toolbar"
  }), this._freeHighlightId = -1, this._freeHighlight = null, this._freeHighlightClipId = "";
}, Kv = function(t) {
  const {
    color: s
  } = this._initialData;
  return t.color.some((i, n) => i !== s[n]);
}, y(ft, as), Z(ft, "_defaultColor", null), Z(ft, "_defaultOpacity", 1), Z(ft, "_defaultThickness", 12), Z(ft, "_type", "highlight"), Z(ft, "_editorType", it.HIGHLIGHT), Z(ft, "_freeHighlightId", -1), Z(ft, "_freeHighlight", null), Z(ft, "_freeHighlightClipId", "");
let Hd = ft;
var Ur, zr, $s, Pi, ss, Wr, Gr, Xr, Ci, Po, Kr, Yr, bn, B, Yv, Qv, Zv, Jv, Vf, qv, Uf, tb, eb, sb, ib, nb, Kn, zf, Wf, Gf, bd, yd, Ra, Xf, Ad, zi, rb, Kf, ab, ob, Yf, Ed, Al;
const Pt = class Pt extends mt {
  constructor(t) {
    super({
      ...t,
      name: "inkEditor"
    });
    y(this, B);
    y(this, Ur, 0);
    y(this, zr, 0);
    y(this, $s, null);
    y(this, Pi, new Path2D());
    y(this, ss, !1);
    y(this, Wr, null);
    y(this, Gr, !1);
    y(this, Xr, !1);
    y(this, Ci, null);
    y(this, Po, null);
    y(this, Kr, 0);
    y(this, Yr, 0);
    y(this, bn, null);
    this.color = t.color || null, this.thickness = t.thickness || null, this.opacity = t.opacity || null, this.paths = [], this.bezierPath2D = [], this.allRawPaths = [], this.currentPath = [], this.scaleFactor = 1, this.translationX = this.translationY = 0, this.x = 0, this.y = 0, this._willKeepAspectRatio = !0;
  }
  static initialize(t, s) {
    mt.initialize(t, s);
  }
  static updateDefaultParams(t, s) {
    switch (t) {
      case J.INK_THICKNESS:
        Pt._defaultThickness = s;
        break;
      case J.INK_COLOR:
        Pt._defaultColor = s;
        break;
      case J.INK_OPACITY:
        Pt._defaultOpacity = s / 100;
        break;
    }
  }
  updateParams(t, s) {
    switch (t) {
      case J.INK_THICKNESS:
        m(this, B, Yv).call(this, s);
        break;
      case J.INK_COLOR:
        m(this, B, Qv).call(this, s);
        break;
      case J.INK_OPACITY:
        m(this, B, Zv).call(this, s);
        break;
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[J.INK_THICKNESS, Pt._defaultThickness], [J.INK_COLOR, Pt._defaultColor || mt._defaultLineColor], [J.INK_OPACITY, Math.round(Pt._defaultOpacity * 100)]];
  }
  get propertiesToUpdate() {
    return [[J.INK_THICKNESS, this.thickness || Pt._defaultThickness], [J.INK_COLOR, this.color || Pt._defaultColor || mt._defaultLineColor], [J.INK_OPACITY, Math.round(100 * (this.opacity ?? Pt._defaultOpacity))]];
  }
  rebuild() {
    this.parent && (super.rebuild(), this.div !== null && (this.canvas || (m(this, B, bd).call(this), m(this, B, yd).call(this)), this.isAttachedToDOM || (this.parent.add(this), m(this, B, Ra).call(this)), m(this, B, Al).call(this)));
  }
  remove() {
    var t;
    this.canvas !== null && (this.isEmpty() || this.commit(), this.canvas.width = this.canvas.height = 0, this.canvas.remove(), this.canvas = null, o(this, $s) && (clearTimeout(o(this, $s)), v(this, $s, null)), (t = o(this, Ci)) == null || t.disconnect(), v(this, Ci, null), super.remove());
  }
  setParent(t) {
    !this.parent && t ? this._uiManager.removeShouldRescale(this) : this.parent && t === null && this._uiManager.addShouldRescale(this), super.setParent(t);
  }
  onScaleChanging() {
    const [t, s] = this.parentDimensions, i = this.width * t, n = this.height * s;
    this.setDimensions(i, n);
  }
  enableEditMode() {
    o(this, ss) || this.canvas === null || (super.enableEditMode(), this._isDraggable = !1, m(this, B, zf).call(this));
  }
  disableEditMode() {
    !this.isInEditMode() || this.canvas === null || (super.disableEditMode(), this._isDraggable = !this.isEmpty(), this.div.classList.remove("editing"), m(this, B, Wf).call(this));
  }
  onceAdded() {
    this._isDraggable = !this.isEmpty();
  }
  isEmpty() {
    return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;
  }
  commit() {
    o(this, ss) || (super.commit(), this.isEditing = !1, this.disableEditMode(), this.setInForeground(), v(this, ss, !0), this.div.classList.add("disabled"), m(this, B, Al).call(this, !0), this.select(), this.parent.addInkEditorIfNeeded(!0), this.moveInDOM(), this.div.focus({
      preventScroll: !0
    }));
  }
  focusin(t) {
    this._focusEventsAllowed && (super.focusin(t), this.enableEditMode());
  }
  canvasPointerdown(t) {
    t.button !== 0 || !this.isInEditMode() || o(this, ss) || (this.setInForeground(), t.preventDefault(), this.div.contains(document.activeElement) || this.div.focus({
      preventScroll: !0
    }), m(this, B, qv).call(this, t.offsetX, t.offsetY));
  }
  canvasPointermove(t) {
    t.preventDefault(), m(this, B, Uf).call(this, t.offsetX, t.offsetY);
  }
  canvasPointerup(t) {
    t.preventDefault(), m(this, B, Gf).call(this, t);
  }
  canvasPointerleave(t) {
    m(this, B, Gf).call(this, t);
  }
  get isResizable() {
    return !this.isEmpty() && o(this, ss);
  }
  render() {
    if (this.div)
      return this.div;
    let t, s;
    this.width && (t = this.x, s = this.y), super.render(), this.div.setAttribute("data-l10n-id", "pdfjs-ink");
    const [i, n, r, a] = m(this, B, Jv).call(this);
    if (this.setAt(i, n, 0, 0), this.setDims(r, a), m(this, B, bd).call(this), this.width) {
      const [h, c] = this.parentDimensions;
      this.setAspectRatio(this.width * h, this.height * c), this.setAt(t * h, s * c, this.width * h, this.height * c), v(this, Xr, !0), m(this, B, Ra).call(this), this.setDims(this.width * h, this.height * c), m(this, B, Kn).call(this), this.div.classList.add("disabled");
    } else
      this.div.classList.add("editing"), this.enableEditMode();
    return m(this, B, yd).call(this), this.div;
  }
  setDimensions(t, s) {
    const i = Math.round(t), n = Math.round(s);
    if (o(this, Kr) === i && o(this, Yr) === n)
      return;
    v(this, Kr, i), v(this, Yr, n), this.canvas.style.visibility = "hidden";
    const [r, a] = this.parentDimensions;
    this.width = t / r, this.height = s / a, this.fixAndSetPosition(), o(this, ss) && m(this, B, Xf).call(this, t, s), m(this, B, Ra).call(this), m(this, B, Kn).call(this), this.canvas.style.visibility = "visible", this.fixDims();
  }
  static async deserialize(t, s, i) {
    var E, A, w;
    if (t instanceof Qp)
      return null;
    const n = await super.deserialize(t, s, i);
    n.thickness = t.thickness, n.color = X.makeHexColor(...t.color), n.opacity = t.opacity;
    const [r, a] = n.pageDimensions, h = n.width * r, c = n.height * a, d = n.parentScale, u = t.thickness / 2;
    v(n, ss, !0), v(n, Kr, Math.round(h)), v(n, Yr, Math.round(c));
    const {
      paths: f,
      rect: p,
      rotation: g
    } = t;
    for (let {
      bezier: x
    } of f) {
      x = m(E = Pt, zi, ab).call(E, x, p, g);
      const P = [];
      n.paths.push(P);
      let T = d * (x[0] - u), C = d * (x[1] - u);
      for (let M = 2, S = x.length; M < S; M += 6) {
        const I = d * (x[M] - u), _ = d * (x[M + 1] - u), D = d * (x[M + 2] - u), k = d * (x[M + 3] - u), j = d * (x[M + 4] - u), H = d * (x[M + 5] - u);
        P.push([[T, C], [I, _], [D, k], [j, H]]), T = j, C = H;
      }
      const R = m(this, zi, rb).call(this, P);
      n.bezierPath2D.push(R);
    }
    const b = m(A = n, B, Yf).call(A);
    return v(n, zr, Math.max(mt.MIN_SIZE, b[2] - b[0])), v(n, Ur, Math.max(mt.MIN_SIZE, b[3] - b[1])), m(w = n, B, Xf).call(w, h, c), n;
  }
  serialize() {
    if (this.isEmpty())
      return null;
    const t = this.getRect(0, 0), s = mt._colorManager.convert(this.ctx.strokeStyle);
    return {
      annotationType: it.INK,
      color: s,
      thickness: this.thickness,
      opacity: this.opacity,
      paths: m(this, B, ob).call(this, this.scaleFactor / this.parentScale, this.translationX, this.translationY, t),
      pageIndex: this.pageIndex,
      rect: t,
      rotation: this.rotation,
      structTreeParentId: this._structTreeParentId
    };
  }
};
Ur = new WeakMap(), zr = new WeakMap(), $s = new WeakMap(), Pi = new WeakMap(), ss = new WeakMap(), Wr = new WeakMap(), Gr = new WeakMap(), Xr = new WeakMap(), Ci = new WeakMap(), Po = new WeakMap(), Kr = new WeakMap(), Yr = new WeakMap(), bn = new WeakMap(), B = new WeakSet(), Yv = function(t) {
  const s = (n) => {
    this.thickness = n, m(this, B, Al).call(this);
  }, i = this.thickness;
  this.addCommands({
    cmd: s.bind(this, t),
    undo: s.bind(this, i),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: J.INK_THICKNESS,
    overwriteIfSameType: !0,
    keepUndo: !0
  });
}, Qv = function(t) {
  const s = (n) => {
    this.color = n, m(this, B, Kn).call(this);
  }, i = this.color;
  this.addCommands({
    cmd: s.bind(this, t),
    undo: s.bind(this, i),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: J.INK_COLOR,
    overwriteIfSameType: !0,
    keepUndo: !0
  });
}, Zv = function(t) {
  const s = (n) => {
    this.opacity = n, m(this, B, Kn).call(this);
  };
  t /= 100;
  const i = this.opacity;
  this.addCommands({
    cmd: s.bind(this, t),
    undo: s.bind(this, i),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: J.INK_OPACITY,
    overwriteIfSameType: !0,
    keepUndo: !0
  });
}, Jv = function() {
  const {
    parentRotation: t,
    parentDimensions: [s, i]
  } = this;
  switch (t) {
    case 90:
      return [0, i, i, s];
    case 180:
      return [s, i, s, i];
    case 270:
      return [s, 0, i, s];
    default:
      return [0, 0, s, i];
  }
}, Vf = function() {
  const {
    ctx: t,
    color: s,
    opacity: i,
    thickness: n,
    parentScale: r,
    scaleFactor: a
  } = this;
  t.lineWidth = n * r / a, t.lineCap = "round", t.lineJoin = "round", t.miterLimit = 10, t.strokeStyle = `${s}${$y(i)}`;
}, qv = function(t, s) {
  this.canvas.addEventListener("contextmenu", os, {
    signal: this._uiManager._signal
  }), m(this, B, Wf).call(this), v(this, Wr, new AbortController());
  const i = this._uiManager.combinedSignal(o(this, Wr));
  this.canvas.addEventListener("pointerleave", this.canvasPointerleave.bind(this), {
    signal: i
  }), this.canvas.addEventListener("pointermove", this.canvasPointermove.bind(this), {
    signal: i
  }), this.canvas.addEventListener("pointerup", this.canvasPointerup.bind(this), {
    signal: i
  }), this.isEditing = !0, o(this, Xr) || (v(this, Xr, !0), m(this, B, Ra).call(this), this.thickness || (this.thickness = Pt._defaultThickness), this.color || (this.color = Pt._defaultColor || mt._defaultLineColor), this.opacity ?? (this.opacity = Pt._defaultOpacity)), this.currentPath.push([t, s]), v(this, Gr, !1), m(this, B, Vf).call(this), v(this, bn, () => {
    m(this, B, sb).call(this), o(this, bn) && window.requestAnimationFrame(o(this, bn));
  }), window.requestAnimationFrame(o(this, bn));
}, Uf = function(t, s) {
  const [i, n] = this.currentPath.at(-1);
  if (this.currentPath.length > 1 && t === i && s === n)
    return;
  const r = this.currentPath;
  let a = o(this, Pi);
  if (r.push([t, s]), v(this, Gr, !0), r.length <= 2) {
    a.moveTo(...r[0]), a.lineTo(t, s);
    return;
  }
  r.length === 3 && (v(this, Pi, a = new Path2D()), a.moveTo(...r[0])), m(this, B, ib).call(this, a, ...r.at(-3), ...r.at(-2), t, s);
}, tb = function() {
  if (this.currentPath.length === 0)
    return;
  const t = this.currentPath.at(-1);
  o(this, Pi).lineTo(...t);
}, eb = function(t, s) {
  v(this, bn, null), t = Math.min(Math.max(t, 0), this.canvas.width), s = Math.min(Math.max(s, 0), this.canvas.height), m(this, B, Uf).call(this, t, s), m(this, B, tb).call(this);
  let i;
  if (this.currentPath.length !== 1)
    i = m(this, B, nb).call(this);
  else {
    const c = [t, s];
    i = [[c, c.slice(), c.slice(), c]];
  }
  const n = o(this, Pi), r = this.currentPath;
  this.currentPath = [], v(this, Pi, new Path2D());
  const a = () => {
    this.allRawPaths.push(r), this.paths.push(i), this.bezierPath2D.push(n), this._uiManager.rebuild(this);
  }, h = () => {
    this.allRawPaths.pop(), this.paths.pop(), this.bezierPath2D.pop(), this.paths.length === 0 ? this.remove() : (this.canvas || (m(this, B, bd).call(this), m(this, B, yd).call(this)), m(this, B, Al).call(this));
  };
  this.addCommands({
    cmd: a,
    undo: h,
    mustExec: !0
  });
}, sb = function() {
  if (!o(this, Gr))
    return;
  v(this, Gr, !1);
  const t = Math.ceil(this.thickness * this.parentScale), s = this.currentPath.slice(-3), i = s.map((a) => a[0]), n = s.map((a) => a[1]);
  Math.min(...i) - t, Math.max(...i) + t, Math.min(...n) - t, Math.max(...n) + t;
  const {
    ctx: r
  } = this;
  r.save(), r.clearRect(0, 0, this.canvas.width, this.canvas.height);
  for (const a of this.bezierPath2D)
    r.stroke(a);
  r.stroke(o(this, Pi)), r.restore();
}, ib = function(t, s, i, n, r, a, h) {
  const c = (s + n) / 2, d = (i + r) / 2, u = (n + a) / 2, f = (r + h) / 2;
  t.bezierCurveTo(c + 2 * (n - c) / 3, d + 2 * (r - d) / 3, u + 2 * (n - u) / 3, f + 2 * (r - f) / 3, u, f);
}, nb = function() {
  const t = this.currentPath;
  if (t.length <= 2)
    return [[t[0], t[0], t.at(-1), t.at(-1)]];
  const s = [];
  let i, [n, r] = t[0];
  for (i = 1; i < t.length - 2; i++) {
    const [p, g] = t[i], [b, E] = t[i + 1], A = (p + b) / 2, w = (g + E) / 2, x = [n + 2 * (p - n) / 3, r + 2 * (g - r) / 3], P = [A + 2 * (p - A) / 3, w + 2 * (g - w) / 3];
    s.push([[n, r], x, P, [A, w]]), [n, r] = [A, w];
  }
  const [a, h] = t[i], [c, d] = t[i + 1], u = [n + 2 * (a - n) / 3, r + 2 * (h - r) / 3], f = [c + 2 * (a - c) / 3, d + 2 * (h - d) / 3];
  return s.push([[n, r], u, f, [c, d]]), s;
}, Kn = function() {
  if (this.isEmpty()) {
    m(this, B, Ad).call(this);
    return;
  }
  m(this, B, Vf).call(this);
  const {
    canvas: t,
    ctx: s
  } = this;
  s.setTransform(1, 0, 0, 1, 0, 0), s.clearRect(0, 0, t.width, t.height), m(this, B, Ad).call(this);
  for (const i of this.bezierPath2D)
    s.stroke(i);
}, zf = function() {
  if (o(this, Po))
    return;
  v(this, Po, new AbortController());
  const t = this._uiManager.combinedSignal(o(this, Po));
  this.canvas.addEventListener("pointerdown", this.canvasPointerdown.bind(this), {
    signal: t
  });
}, Wf = function() {
  var t;
  (t = this.pointerdownAC) == null || t.abort(), this.pointerdownAC = null;
}, Gf = function(t) {
  var s;
  (s = o(this, Wr)) == null || s.abort(), v(this, Wr, null), m(this, B, zf).call(this), o(this, $s) && clearTimeout(o(this, $s)), v(this, $s, setTimeout(() => {
    v(this, $s, null), this.canvas.removeEventListener("contextmenu", os);
  }, 10)), m(this, B, eb).call(this, t.offsetX, t.offsetY), this.addToAnnotationStorage(), this.setInBackground();
}, bd = function() {
  this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = 0, this.canvas.className = "inkEditorCanvas", this.canvas.setAttribute("data-l10n-id", "pdfjs-ink-canvas"), this.div.append(this.canvas), this.ctx = this.canvas.getContext("2d");
}, yd = function() {
  v(this, Ci, new ResizeObserver((t) => {
    const s = t[0].contentRect;
    s.width && s.height && this.setDimensions(s.width, s.height);
  })), o(this, Ci).observe(this.div), this._uiManager._signal.addEventListener("abort", () => {
    var t;
    (t = o(this, Ci)) == null || t.disconnect(), v(this, Ci, null);
  }, {
    once: !0
  });
}, Ra = function() {
  if (!o(this, Xr))
    return;
  const [t, s] = this.parentDimensions;
  this.canvas.width = Math.ceil(this.width * t), this.canvas.height = Math.ceil(this.height * s), m(this, B, Ad).call(this);
}, Xf = function(t, s) {
  const i = m(this, B, Ed).call(this), n = (t - i) / o(this, zr), r = (s - i) / o(this, Ur);
  this.scaleFactor = Math.min(n, r);
}, Ad = function() {
  const t = m(this, B, Ed).call(this) / 2;
  this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + t, this.translationY * this.scaleFactor + t);
}, zi = new WeakSet(), rb = function(t) {
  const s = new Path2D();
  for (let i = 0, n = t.length; i < n; i++) {
    const [r, a, h, c] = t[i];
    i === 0 && s.moveTo(...r), s.bezierCurveTo(a[0], a[1], h[0], h[1], c[0], c[1]);
  }
  return s;
}, Kf = function(t, s, i) {
  const [n, r, a, h] = s;
  switch (i) {
    case 0:
      for (let c = 0, d = t.length; c < d; c += 2)
        t[c] += n, t[c + 1] = h - t[c + 1];
      break;
    case 90:
      for (let c = 0, d = t.length; c < d; c += 2) {
        const u = t[c];
        t[c] = t[c + 1] + n, t[c + 1] = u + r;
      }
      break;
    case 180:
      for (let c = 0, d = t.length; c < d; c += 2)
        t[c] = a - t[c], t[c + 1] += r;
      break;
    case 270:
      for (let c = 0, d = t.length; c < d; c += 2) {
        const u = t[c];
        t[c] = a - t[c + 1], t[c + 1] = h - u;
      }
      break;
    default:
      throw new Error("Invalid rotation");
  }
  return t;
}, ab = function(t, s, i) {
  const [n, r, a, h] = s;
  switch (i) {
    case 0:
      for (let c = 0, d = t.length; c < d; c += 2)
        t[c] -= n, t[c + 1] = h - t[c + 1];
      break;
    case 90:
      for (let c = 0, d = t.length; c < d; c += 2) {
        const u = t[c];
        t[c] = t[c + 1] - r, t[c + 1] = u - n;
      }
      break;
    case 180:
      for (let c = 0, d = t.length; c < d; c += 2)
        t[c] = a - t[c], t[c + 1] -= r;
      break;
    case 270:
      for (let c = 0, d = t.length; c < d; c += 2) {
        const u = t[c];
        t[c] = h - t[c + 1], t[c + 1] = a - u;
      }
      break;
    default:
      throw new Error("Invalid rotation");
  }
  return t;
}, ob = function(t, s, i, n) {
  var d, u;
  const r = [], a = this.thickness / 2, h = t * s + a, c = t * i + a;
  for (const f of this.paths) {
    const p = [], g = [];
    for (let b = 0, E = f.length; b < E; b++) {
      const [A, w, x, P] = f[b];
      if (A[0] === P[0] && A[1] === P[1] && E === 1) {
        const k = t * A[0] + h, j = t * A[1] + c;
        p.push(k, j), g.push(k, j);
        break;
      }
      const T = t * A[0] + h, C = t * A[1] + c, R = t * w[0] + h, M = t * w[1] + c, S = t * x[0] + h, I = t * x[1] + c, _ = t * P[0] + h, D = t * P[1] + c;
      b === 0 && (p.push(T, C), g.push(T, C)), p.push(R, M, S, I, _, D), g.push(R, M), b === E - 1 && g.push(_, D);
    }
    r.push({
      bezier: m(d = Pt, zi, Kf).call(d, p, n, this.rotation),
      points: m(u = Pt, zi, Kf).call(u, g, n, this.rotation)
    });
  }
  return r;
}, Yf = function() {
  let t = 1 / 0, s = -1 / 0, i = 1 / 0, n = -1 / 0;
  for (const r of this.paths)
    for (const [a, h, c, d] of r) {
      const u = X.bezierBoundingBox(...a, ...h, ...c, ...d);
      t = Math.min(t, u[0]), i = Math.min(i, u[1]), s = Math.max(s, u[2]), n = Math.max(n, u[3]);
    }
  return [t, i, s, n];
}, Ed = function() {
  return o(this, ss) ? Math.ceil(this.thickness * this.parentScale) : 0;
}, Al = function(t = !1) {
  if (this.isEmpty())
    return;
  if (!o(this, ss)) {
    m(this, B, Kn).call(this);
    return;
  }
  const s = m(this, B, Yf).call(this), i = m(this, B, Ed).call(this);
  v(this, zr, Math.max(mt.MIN_SIZE, s[2] - s[0])), v(this, Ur, Math.max(mt.MIN_SIZE, s[3] - s[1]));
  const n = Math.ceil(i + o(this, zr) * this.scaleFactor), r = Math.ceil(i + o(this, Ur) * this.scaleFactor), [a, h] = this.parentDimensions;
  this.width = n / a, this.height = r / h, this.setAspectRatio(n, r);
  const c = this.translationX, d = this.translationY;
  this.translationX = -s[0], this.translationY = -s[1], m(this, B, Ra).call(this), m(this, B, Kn).call(this), v(this, Kr, n), v(this, Yr, r), this.setDims(n, r);
  const u = t ? i / this.scaleFactor / 2 : 0;
  this.translate(c - this.translationX - u, d - this.translationY - u);
}, y(Pt, zi), Z(Pt, "_defaultColor", null), Z(Pt, "_defaultOpacity", 1), Z(Pt, "_defaultThickness", 1), Z(Pt, "_type", "ink"), Z(Pt, "_editorType", it.INK);
let $f = Pt;
var Rt, le, yn, Ri, An, Co, Vs, Ii, Us, ze, Ro, ot, El, wl, wd, Zf, lb, xd, Jf, Sd, hb, cb;
const Nl = class Nl extends mt {
  constructor(t) {
    super({
      ...t,
      name: "stampEditor"
    });
    y(this, ot);
    y(this, Rt, null);
    y(this, le, null);
    y(this, yn, null);
    y(this, Ri, null);
    y(this, An, null);
    y(this, Co, "");
    y(this, Vs, null);
    y(this, Ii, null);
    y(this, Us, null);
    y(this, ze, !1);
    y(this, Ro, !1);
    v(this, Ri, t.bitmapUrl), v(this, An, t.bitmapFile);
  }
  static initialize(t, s) {
    mt.initialize(t, s);
  }
  static get supportedTypes() {
    return ht(this, "supportedTypes", ["apng", "avif", "bmp", "gif", "jpeg", "png", "svg+xml", "webp", "x-icon"].map((s) => `image/${s}`));
  }
  static get supportedTypesStr() {
    return ht(this, "supportedTypesStr", this.supportedTypes.join(","));
  }
  static isHandlingMimeForPasting(t) {
    return this.supportedTypes.includes(t);
  }
  static paste(t, s) {
    s.pasteEditor(it.STAMP, {
      bitmapFile: t.getAsFile()
    });
  }
  altTextFinish() {
    this._uiManager.useNewAltTextFlow && (this.div.hidden = !1), super.altTextFinish();
  }
  get telemetryFinalData() {
    var t;
    return {
      type: "stamp",
      hasAltText: !!((t = this.altTextData) != null && t.altText)
    };
  }
  static computeTelemetryFinalData(t) {
    const s = t.get("hasAltText");
    return {
      hasAltText: s.get(!0) ?? 0,
      hasNoAltText: s.get(!1) ?? 0
    };
  }
  async mlGuessAltText(t = null, s = !0) {
    if (this.hasAltTextData())
      return null;
    const {
      mlManager: i
    } = this._uiManager;
    if (!i)
      throw new Error("No ML.");
    if (!await i.isEnabledFor("altText"))
      throw new Error("ML isn't enabled for alt text.");
    const {
      data: n,
      width: r,
      height: a
    } = t || this.copyCanvas(null, null, !0).imageData, h = await i.guess({
      name: "altText",
      request: {
        data: n,
        width: r,
        height: a,
        channels: n.length / (r * a)
      }
    });
    if (!h)
      throw new Error("No response from the AI service.");
    if (h.error)
      throw new Error("Error from the AI service.");
    if (h.cancel)
      return null;
    if (!h.output)
      throw new Error("No valid response from the AI service.");
    const c = h.output;
    return await this.setGuessedAltText(c), s && !this.hasAltTextData() && (this.altTextData = {
      alt: c,
      decorative: !1
    }), c;
  }
  remove() {
    var t, s;
    o(this, le) && (v(this, Rt, null), this._uiManager.imageManager.deleteId(o(this, le)), (t = o(this, Vs)) == null || t.remove(), v(this, Vs, null), (s = o(this, Ii)) == null || s.disconnect(), v(this, Ii, null), o(this, Us) && (clearTimeout(o(this, Us)), v(this, Us, null))), super.remove();
  }
  rebuild() {
    if (!this.parent) {
      o(this, le) && m(this, ot, wd).call(this);
      return;
    }
    super.rebuild(), this.div !== null && (o(this, le) && o(this, Vs) === null && m(this, ot, wd).call(this), this.isAttachedToDOM || this.parent.add(this));
  }
  onceAdded() {
    this._isDraggable = !0, this.div.focus();
  }
  isEmpty() {
    return !(o(this, yn) || o(this, Rt) || o(this, Ri) || o(this, An) || o(this, le));
  }
  get isResizable() {
    return !0;
  }
  render() {
    if (this.div)
      return this.div;
    let t, s;
    if (this.width && (t = this.x, s = this.y), super.render(), this.div.hidden = !0, this.div.setAttribute("role", "figure"), this.addAltTextButton(), o(this, Rt) ? m(this, ot, Zf).call(this) : m(this, ot, wd).call(this), this.width && !this.annotationElementId) {
      const [i, n] = this.parentDimensions;
      this.setAt(t * i, s * n, this.width * i, this.height * n);
    }
    return this.div;
  }
  copyCanvas(t, s, i = !1) {
    var p;
    t || (t = 224);
    const {
      width: n,
      height: r
    } = o(this, Rt), a = new Xu();
    let h = o(this, Rt), c = n, d = r, u = null;
    if (s) {
      if (n > s || r > s) {
        const M = Math.min(s / n, s / r);
        c = Math.floor(n * M), d = Math.floor(r * M);
      }
      u = document.createElement("canvas");
      const g = u.width = Math.ceil(c * a.sx), b = u.height = Math.ceil(d * a.sy);
      o(this, ze) || (h = m(this, ot, xd).call(this, g, b));
      const E = u.getContext("2d");
      E.filter = this._uiManager.hcmFilter;
      let A = "white", w = "#cfcfd8";
      this._uiManager.hcmFilter !== "none" ? w = "black" : (p = window.matchMedia) != null && p.call(window, "(prefers-color-scheme: dark)").matches && (A = "#8f8f9d", w = "#42414d");
      const x = 15, P = x * a.sx, T = x * a.sy, C = new OffscreenCanvas(P * 2, T * 2), R = C.getContext("2d");
      R.fillStyle = A, R.fillRect(0, 0, P * 2, T * 2), R.fillStyle = w, R.fillRect(0, 0, P, T), R.fillRect(P, T, P, T), E.fillStyle = E.createPattern(C, "repeat"), E.fillRect(0, 0, g, b), E.drawImage(h, 0, 0, h.width, h.height, 0, 0, g, b);
    }
    let f = null;
    if (i) {
      let g, b;
      if (a.symmetric && h.width < t && h.height < t)
        g = h.width, b = h.height;
      else if (h = o(this, Rt), n > t || r > t) {
        const w = Math.min(t / n, t / r);
        g = Math.floor(n * w), b = Math.floor(r * w), o(this, ze) || (h = m(this, ot, xd).call(this, g, b));
      }
      const A = new OffscreenCanvas(g, b).getContext("2d", {
        willReadFrequently: !0
      });
      A.drawImage(h, 0, 0, h.width, h.height, 0, 0, g, b), f = {
        width: g,
        height: b,
        data: A.getImageData(0, 0, g, b).data
      };
    }
    return {
      canvas: u,
      width: c,
      height: d,
      imageData: f
    };
  }
  getImageForAltText() {
    return o(this, Vs);
  }
  static async deserialize(t, s, i) {
    var b;
    let n = null;
    if (t instanceof Tv) {
      const {
        data: {
          rect: E,
          rotation: A,
          id: w,
          structParent: x,
          popupRef: P
        },
        container: T,
        parent: {
          page: {
            pageNumber: C
          }
        }
      } = t, R = T.querySelector("canvas"), M = i.imageManager.getFromCanvas(T.id, R);
      R.remove();
      const S = ((b = await s._structTree.getAriaAttributes(`${Hp}${w}`)) == null ? void 0 : b.get("aria-label")) || "";
      n = t = {
        annotationType: it.STAMP,
        bitmapId: M.id,
        bitmap: M.bitmap,
        pageIndex: C - 1,
        rect: E.slice(0),
        rotation: A,
        id: w,
        deleted: !1,
        accessibilityData: {
          decorative: !1,
          altText: S
        },
        isSvg: !1,
        structParent: x,
        popupRef: P
      };
    }
    const r = await super.deserialize(t, s, i), {
      rect: a,
      bitmap: h,
      bitmapUrl: c,
      bitmapId: d,
      isSvg: u,
      accessibilityData: f
    } = t;
    d && i.imageManager.isValidId(d) ? (v(r, le, d), h && v(r, Rt, h)) : v(r, Ri, c), v(r, ze, u);
    const [p, g] = r.pageDimensions;
    return r.width = (a[2] - a[0]) / p, r.height = (a[3] - a[1]) / g, r.annotationElementId = t.id || null, f && (r.altTextData = f), r._initialData = n, v(r, Ro, !!n), r;
  }
  serialize(t = !1, s = null) {
    if (this.isEmpty())
      return null;
    if (this.deleted)
      return this.serializeDeleted();
    const i = {
      annotationType: it.STAMP,
      bitmapId: o(this, le),
      pageIndex: this.pageIndex,
      rect: this.getRect(0, 0),
      rotation: this.rotation,
      isSvg: o(this, ze),
      structTreeParentId: this._structTreeParentId
    };
    if (t)
      return i.bitmapUrl = m(this, ot, Sd).call(this, !0), i.accessibilityData = this.serializeAltText(!0), i;
    const {
      decorative: n,
      altText: r
    } = this.serializeAltText(!1);
    if (!n && r && (i.accessibilityData = {
      type: "Figure",
      alt: r
    }), this.annotationElementId) {
      const h = m(this, ot, cb).call(this, i);
      if (h.isSame)
        return null;
      h.isSameAltText ? delete i.accessibilityData : i.accessibilityData.structParent = this._initialData.structParent ?? -1;
    }
    if (i.id = this.annotationElementId, s === null)
      return i;
    s.stamps || (s.stamps = /* @__PURE__ */ new Map());
    const a = o(this, ze) ? (i.rect[2] - i.rect[0]) * (i.rect[3] - i.rect[1]) : null;
    if (!s.stamps.has(o(this, le)))
      s.stamps.set(o(this, le), {
        area: a,
        serialized: i
      }), i.bitmap = m(this, ot, Sd).call(this, !1);
    else if (o(this, ze)) {
      const h = s.stamps.get(o(this, le));
      a > h.area && (h.area = a, h.serialized.bitmap.close(), h.serialized.bitmap = m(this, ot, Sd).call(this, !1));
    }
    return i;
  }
  renderAnnotationElement(t) {
    return t.updateEdited({
      rect: this.getRect(0, 0)
    }), null;
  }
};
Rt = new WeakMap(), le = new WeakMap(), yn = new WeakMap(), Ri = new WeakMap(), An = new WeakMap(), Co = new WeakMap(), Vs = new WeakMap(), Ii = new WeakMap(), Us = new WeakMap(), ze = new WeakMap(), Ro = new WeakMap(), ot = new WeakSet(), El = function(t, s = !1) {
  if (!t) {
    this.remove();
    return;
  }
  v(this, Rt, t.bitmap), s || (v(this, le, t.id), v(this, ze, t.isSvg)), t.file && v(this, Co, t.file.name), m(this, ot, Zf).call(this);
}, wl = function() {
  if (v(this, yn, null), this._uiManager.enableWaiting(!1), !!o(this, Vs)) {
    if (this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && o(this, Rt)) {
      this._editToolbar.hide(), this._uiManager.editAltText(this, !0);
      return;
    }
    if (!this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && o(this, Rt)) {
      this._reportTelemetry({
        action: "pdfjs.image.image_added",
        data: {
          alt_text_modal: !1,
          alt_text_type: "empty"
        }
      });
      try {
        this.mlGuessAltText();
      } catch {
      }
    }
    this.div.focus();
  }
}, wd = function() {
  if (o(this, le)) {
    this._uiManager.enableWaiting(!0), this._uiManager.imageManager.getFromId(o(this, le)).then((i) => m(this, ot, El).call(this, i, !0)).finally(() => m(this, ot, wl).call(this));
    return;
  }
  if (o(this, Ri)) {
    const i = o(this, Ri);
    v(this, Ri, null), this._uiManager.enableWaiting(!0), v(this, yn, this._uiManager.imageManager.getFromUrl(i).then((n) => m(this, ot, El).call(this, n)).finally(() => m(this, ot, wl).call(this)));
    return;
  }
  if (o(this, An)) {
    const i = o(this, An);
    v(this, An, null), this._uiManager.enableWaiting(!0), v(this, yn, this._uiManager.imageManager.getFromFile(i).then((n) => m(this, ot, El).call(this, n)).finally(() => m(this, ot, wl).call(this)));
    return;
  }
  const t = document.createElement("input");
  t.type = "file", t.accept = Nl.supportedTypesStr;
  const s = this._uiManager._signal;
  v(this, yn, new Promise((i) => {
    t.addEventListener("change", async () => {
      if (!t.files || t.files.length === 0)
        this.remove();
      else {
        this._uiManager.enableWaiting(!0);
        const n = await this._uiManager.imageManager.getFromFile(t.files[0]);
        this._reportTelemetry({
          action: "pdfjs.image.image_selected",
          data: {
            alt_text_modal: this._uiManager.useNewAltTextFlow
          }
        }), m(this, ot, El).call(this, n);
      }
      i();
    }, {
      signal: s
    }), t.addEventListener("cancel", () => {
      this.remove(), i();
    }, {
      signal: s
    });
  }).finally(() => m(this, ot, wl).call(this))), t.click();
}, Zf = function() {
  const {
    div: t
  } = this;
  let {
    width: s,
    height: i
  } = o(this, Rt);
  const [n, r] = this.pageDimensions, a = 0.75;
  if (this.width)
    s = this.width * n, i = this.height * r;
  else if (s > a * n || i > a * r) {
    const u = Math.min(a * n / s, a * r / i);
    s *= u, i *= u;
  }
  const [h, c] = this.parentDimensions;
  this.setDims(s * h / n, i * c / r), this._uiManager.enableWaiting(!1);
  const d = v(this, Vs, document.createElement("canvas"));
  d.setAttribute("role", "img"), this.addContainer(d), (!this._uiManager.useNewAltTextWhenAddingImage || !this._uiManager.useNewAltTextFlow || this.annotationElementId) && (t.hidden = !1), m(this, ot, Jf).call(this, s, i), m(this, ot, hb).call(this), o(this, Ro) || (this.parent.addUndoableEditor(this), v(this, Ro, !0)), this._reportTelemetry({
    action: "inserted_image"
  }), o(this, Co) && d.setAttribute("aria-label", o(this, Co));
}, lb = function(t, s) {
  var a;
  const [i, n] = this.parentDimensions;
  this.width = t / i, this.height = s / n, (a = this._initialOptions) != null && a.isCentered ? this.center() : this.fixAndSetPosition(), this._initialOptions = null, o(this, Us) !== null && clearTimeout(o(this, Us)), v(this, Us, setTimeout(() => {
    v(this, Us, null), m(this, ot, Jf).call(this, t, s);
  }, 200));
}, xd = function(t, s) {
  const {
    width: i,
    height: n
  } = o(this, Rt);
  let r = i, a = n, h = o(this, Rt);
  for (; r > 2 * t || a > 2 * s; ) {
    const c = r, d = a;
    r > 2 * t && (r = r >= 16384 ? Math.floor(r / 2) - 1 : Math.ceil(r / 2)), a > 2 * s && (a = a >= 16384 ? Math.floor(a / 2) - 1 : Math.ceil(a / 2));
    const u = new OffscreenCanvas(r, a);
    u.getContext("2d").drawImage(h, 0, 0, c, d, 0, 0, r, a), h = u.transferToImageBitmap();
  }
  return h;
}, Jf = function(t, s) {
  const i = new Xu(), n = Math.ceil(t * i.sx), r = Math.ceil(s * i.sy), a = o(this, Vs);
  if (!a || a.width === n && a.height === r)
    return;
  a.width = n, a.height = r;
  const h = o(this, ze) ? o(this, Rt) : m(this, ot, xd).call(this, n, r), c = a.getContext("2d");
  c.filter = this._uiManager.hcmFilter, c.drawImage(h, 0, 0, h.width, h.height, 0, 0, n, r);
}, Sd = function(t) {
  if (t) {
    if (o(this, ze)) {
      const n = this._uiManager.imageManager.getSvgUrl(o(this, le));
      if (n)
        return n;
    }
    const s = document.createElement("canvas");
    return {
      width: s.width,
      height: s.height
    } = o(this, Rt), s.getContext("2d").drawImage(o(this, Rt), 0, 0), s.toDataURL();
  }
  if (o(this, ze)) {
    const [s, i] = this.pageDimensions, n = Math.round(this.width * s * Qo.PDF_TO_CSS_UNITS), r = Math.round(this.height * i * Qo.PDF_TO_CSS_UNITS), a = new OffscreenCanvas(n, r);
    return a.getContext("2d").drawImage(o(this, Rt), 0, 0, o(this, Rt).width, o(this, Rt).height, 0, 0, n, r), a.transferToImageBitmap();
  }
  return structuredClone(o(this, Rt));
}, hb = function() {
  this._uiManager._signal && (v(this, Ii, new ResizeObserver((t) => {
    const s = t[0].contentRect;
    s.width && s.height && m(this, ot, lb).call(this, s.width, s.height);
  })), o(this, Ii).observe(this.div), this._uiManager._signal.addEventListener("abort", () => {
    var t;
    (t = o(this, Ii)) == null || t.disconnect(), v(this, Ii, null);
  }, {
    once: !0
  }));
}, cb = function(t) {
  var c;
  const {
    rect: s,
    pageIndex: i,
    accessibilityData: {
      altText: n
    }
  } = this._initialData, r = t.rect.every((d, u) => Math.abs(d - s[u]) < 1), a = t.pageIndex === i, h = (((c = t.accessibilityData) == null ? void 0 : c.alt) || "") === n;
  return {
    isSame: r && a && h,
    isSameAltText: h
  };
}, Z(Nl, "_type", "stamp"), Z(Nl, "_editorType", it.STAMP);
let Qf = Nl;
var Qr, Io, zs, En, Li, We, wn, Lo, Mo, ve, Mi, K, Ne, xn, ce, db, qf, tp, ep, Td;
let mE = (Ne = class {
  constructor({
    uiManager: e,
    pageIndex: t,
    div: s,
    structTreeLayer: i,
    accessibilityManager: n,
    annotationLayer: r,
    drawLayer: a,
    textLayer: h,
    viewport: c,
    l10n: d
  }) {
    y(this, ce);
    y(this, Qr);
    y(this, Io, !1);
    y(this, zs, null);
    y(this, En, null);
    y(this, Li, null);
    y(this, We, /* @__PURE__ */ new Map());
    y(this, wn, !1);
    y(this, Lo, !1);
    y(this, Mo, !1);
    y(this, ve, null);
    y(this, Mi, null);
    y(this, K);
    const u = [...o(Ne, xn).values()];
    if (!Ne._initialized) {
      Ne._initialized = !0;
      for (const f of u)
        f.initialize(d, e);
    }
    e.registerEditorTypes(u), v(this, K, e), this.pageIndex = t, this.div = s, v(this, Qr, n), v(this, zs, r), this.viewport = c, v(this, ve, h), this.drawLayer = a, this._structTree = i, o(this, K).addLayer(this);
  }
  get isEmpty() {
    return o(this, We).size === 0;
  }
  get isInvisible() {
    return this.isEmpty && o(this, K).getMode() === it.NONE;
  }
  updateToolbar(e) {
    o(this, K).updateToolbar(e);
  }
  updateMode(e = o(this, K).getMode()) {
    switch (m(this, ce, Td).call(this), e) {
      case it.NONE:
        this.disableTextSelection(), this.togglePointerEvents(!1), this.toggleAnnotationLayerPointerEvents(!0), this.disableClick();
        return;
      case it.INK:
        this.addInkEditorIfNeeded(!1), this.disableTextSelection(), this.togglePointerEvents(!0), this.disableClick();
        break;
      case it.HIGHLIGHT:
        this.enableTextSelection(), this.togglePointerEvents(!1), this.disableClick();
        break;
      default:
        this.disableTextSelection(), this.togglePointerEvents(!0), this.enableClick();
    }
    this.toggleAnnotationLayerPointerEvents(!1);
    const {
      classList: t
    } = this.div;
    for (const s of o(Ne, xn).values())
      t.toggle(`${s._type}Editing`, e === s._editorType);
    this.div.hidden = !1;
  }
  hasTextLayer(e) {
    var t;
    return e === ((t = o(this, ve)) == null ? void 0 : t.div);
  }
  addInkEditorIfNeeded(e) {
    if (o(this, K).getMode() !== it.INK)
      return;
    if (!e) {
      for (const s of o(this, We).values())
        if (s.isEmpty()) {
          s.setInBackground();
          return;
        }
    }
    this.createAndAddNewEditor({
      offsetX: 0,
      offsetY: 0
    }, !1).setInBackground();
  }
  setEditingState(e) {
    o(this, K).setEditingState(e);
  }
  addCommands(e) {
    o(this, K).addCommands(e);
  }
  toggleDrawing(e = !1) {
    this.div.classList.toggle("drawing", !e);
  }
  togglePointerEvents(e = !1) {
    this.div.classList.toggle("disabled", !e);
  }
  toggleAnnotationLayerPointerEvents(e = !1) {
    var t;
    (t = o(this, zs)) == null || t.div.classList.toggle("disabled", !e);
  }
  async enable() {
    this.div.tabIndex = 0, this.togglePointerEvents(!0);
    const e = /* @__PURE__ */ new Set();
    for (const s of o(this, We).values())
      s.enableEditing(), s.show(!0), s.annotationElementId && (o(this, K).removeChangedExistingAnnotation(s), e.add(s.annotationElementId));
    if (!o(this, zs))
      return;
    const t = o(this, zs).getEditableAnnotations();
    for (const s of t) {
      if (s.hide(), o(this, K).isDeletedAnnotationElement(s.data.id) || e.has(s.data.id))
        continue;
      const i = await this.deserialize(s);
      i && (this.addOrRebuild(i), i.enableEditing());
    }
  }
  disable() {
    var i;
    v(this, Mo, !0), this.div.tabIndex = -1, this.togglePointerEvents(!1);
    const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map();
    for (const n of o(this, We).values())
      if (n.disableEditing(), !!n.annotationElementId) {
        if (n.serialize() !== null) {
          e.set(n.annotationElementId, n);
          continue;
        } else
          t.set(n.annotationElementId, n);
        (i = this.getEditableAnnotation(n.annotationElementId)) == null || i.show(), n.remove();
      }
    if (o(this, zs)) {
      const n = o(this, zs).getEditableAnnotations();
      for (const r of n) {
        const {
          id: a
        } = r.data;
        if (o(this, K).isDeletedAnnotationElement(a))
          continue;
        let h = t.get(a);
        if (h) {
          h.resetAnnotationElement(r), h.show(!1), r.show();
          continue;
        }
        h = e.get(a), h && (o(this, K).addChangedExistingAnnotation(h), h.renderAnnotationElement(r) && h.show(!1)), r.show();
      }
    }
    m(this, ce, Td).call(this), this.isEmpty && (this.div.hidden = !0);
    const {
      classList: s
    } = this.div;
    for (const n of o(Ne, xn).values())
      s.remove(`${n._type}Editing`);
    this.disableTextSelection(), this.toggleAnnotationLayerPointerEvents(!0), v(this, Mo, !1);
  }
  getEditableAnnotation(e) {
    var t;
    return ((t = o(this, zs)) == null ? void 0 : t.getEditableAnnotation(e)) || null;
  }
  setActiveEditor(e) {
    o(this, K).getActive() !== e && o(this, K).setActiveEditor(e);
  }
  enableTextSelection() {
    var e;
    if (this.div.tabIndex = -1, (e = o(this, ve)) != null && e.div && !o(this, Mi)) {
      v(this, Mi, new AbortController());
      const t = o(this, K).combinedSignal(o(this, Mi));
      o(this, ve).div.addEventListener("pointerdown", m(this, ce, db).bind(this), {
        signal: t
      }), o(this, ve).div.classList.add("highlighting");
    }
  }
  disableTextSelection() {
    var e;
    this.div.tabIndex = 0, (e = o(this, ve)) != null && e.div && o(this, Mi) && (o(this, Mi).abort(), v(this, Mi, null), o(this, ve).div.classList.remove("highlighting"));
  }
  enableClick() {
    if (o(this, En))
      return;
    v(this, En, new AbortController());
    const e = o(this, K).combinedSignal(o(this, En));
    this.div.addEventListener("pointerdown", this.pointerdown.bind(this), {
      signal: e
    }), this.div.addEventListener("pointerup", this.pointerup.bind(this), {
      signal: e
    });
  }
  disableClick() {
    var e;
    (e = o(this, En)) == null || e.abort(), v(this, En, null);
  }
  attach(e) {
    o(this, We).set(e.id, e);
    const {
      annotationElementId: t
    } = e;
    t && o(this, K).isDeletedAnnotationElement(t) && o(this, K).removeDeletedAnnotationElement(e);
  }
  detach(e) {
    var t;
    o(this, We).delete(e.id), (t = o(this, Qr)) == null || t.removePointerInTextLayer(e.contentDiv), !o(this, Mo) && e.annotationElementId && o(this, K).addDeletedAnnotationElement(e);
  }
  remove(e) {
    this.detach(e), o(this, K).removeEditor(e), e.div.remove(), e.isAttachedToDOM = !1, o(this, Lo) || this.addInkEditorIfNeeded(!1);
  }
  changeParent(e) {
    var t;
    e.parent !== this && (e.parent && e.annotationElementId && (o(this, K).addDeletedAnnotationElement(e.annotationElementId), mt.deleteAnnotationElement(e), e.annotationElementId = null), this.attach(e), (t = e.parent) == null || t.detach(e), e.setParent(this), e.div && e.isAttachedToDOM && (e.div.remove(), this.div.append(e.div)));
  }
  add(e) {
    if (!(e.parent === this && e.isAttachedToDOM)) {
      if (this.changeParent(e), o(this, K).addEditor(e), this.attach(e), !e.isAttachedToDOM) {
        const t = e.render();
        this.div.append(t), e.isAttachedToDOM = !0;
      }
      e.fixAndSetPosition(), e.onceAdded(), o(this, K).addToAnnotationStorage(e), e._reportTelemetry(e.telemetryInitialData);
    }
  }
  moveEditorInDOM(e) {
    var s;
    if (!e.isAttachedToDOM)
      return;
    const {
      activeElement: t
    } = document;
    e.div.contains(t) && !o(this, Li) && (e._focusEventsAllowed = !1, v(this, Li, setTimeout(() => {
      v(this, Li, null), e.div.contains(document.activeElement) ? e._focusEventsAllowed = !0 : (e.div.addEventListener("focusin", () => {
        e._focusEventsAllowed = !0;
      }, {
        once: !0,
        signal: o(this, K)._signal
      }), t.focus());
    }, 0))), e._structTreeParentId = (s = o(this, Qr)) == null ? void 0 : s.moveElementInDOM(this.div, e.div, e.contentDiv, !0);
  }
  addOrRebuild(e) {
    e.needsToBeRebuilt() ? (e.parent || (e.parent = this), e.rebuild(), e.show()) : this.add(e);
  }
  addUndoableEditor(e) {
    const t = () => e._uiManager.rebuild(e), s = () => {
      e.remove();
    };
    this.addCommands({
      cmd: t,
      undo: s,
      mustExec: !1
    });
  }
  getNextId() {
    return o(this, K).getId();
  }
  combinedSignal(e) {
    return o(this, K).combinedSignal(e);
  }
  canCreateNewEmptyEditor() {
    var e;
    return (e = o(this, ce, qf)) == null ? void 0 : e.canCreateNewEmptyEditor();
  }
  pasteEditor(e, t) {
    o(this, K).updateToolbar(e), o(this, K).updateMode(e);
    const {
      offsetX: s,
      offsetY: i
    } = m(this, ce, ep).call(this), n = this.getNextId(), r = m(this, ce, tp).call(this, {
      parent: this,
      id: n,
      x: s,
      y: i,
      uiManager: o(this, K),
      isCentered: !0,
      ...t
    });
    r && this.add(r);
  }
  async deserialize(e) {
    var t;
    return await ((t = o(Ne, xn).get(e.annotationType ?? e.annotationEditorType)) == null ? void 0 : t.deserialize(e, this, o(this, K))) || null;
  }
  createAndAddNewEditor(e, t, s = {}) {
    const i = this.getNextId(), n = m(this, ce, tp).call(this, {
      parent: this,
      id: i,
      x: e.offsetX,
      y: e.offsetY,
      uiManager: o(this, K),
      isCentered: t,
      ...s
    });
    return n && this.add(n), n;
  }
  addNewEditor() {
    this.createAndAddNewEditor(m(this, ce, ep).call(this), !0);
  }
  setSelected(e) {
    o(this, K).setSelected(e);
  }
  toggleSelected(e) {
    o(this, K).toggleSelected(e);
  }
  isSelected(e) {
    return o(this, K).isSelected(e);
  }
  unselect(e) {
    o(this, K).unselect(e);
  }
  pointerup(e) {
    const {
      isMac: t
    } = ke.platform;
    if (!(e.button !== 0 || e.ctrlKey && t) && e.target === this.div && o(this, wn)) {
      if (v(this, wn, !1), !o(this, Io)) {
        v(this, Io, !0);
        return;
      }
      if (o(this, K).getMode() === it.STAMP) {
        o(this, K).unselectAll();
        return;
      }
      this.createAndAddNewEditor(e, !1);
    }
  }
  pointerdown(e) {
    if (o(this, K).getMode() === it.HIGHLIGHT && this.enableTextSelection(), o(this, wn)) {
      v(this, wn, !1);
      return;
    }
    const {
      isMac: t
    } = ke.platform;
    if (e.button !== 0 || e.ctrlKey && t || e.target !== this.div)
      return;
    v(this, wn, !0);
    const s = o(this, K).getActive();
    v(this, Io, !s || s.isEmpty());
  }
  findNewParent(e, t, s) {
    const i = o(this, K).findParent(t, s);
    return i === null || i === this ? !1 : (i.changeParent(e), !0);
  }
  destroy() {
    var e, t;
    ((e = o(this, K).getActive()) == null ? void 0 : e.parent) === this && (o(this, K).commitOrRemove(), o(this, K).setActiveEditor(null)), o(this, Li) && (clearTimeout(o(this, Li)), v(this, Li, null));
    for (const s of o(this, We).values())
      (t = o(this, Qr)) == null || t.removePointerInTextLayer(s.contentDiv), s.setParent(null), s.isAttachedToDOM = !1, s.div.remove();
    this.div = null, o(this, We).clear(), o(this, K).removeLayer(this);
  }
  render({
    viewport: e
  }) {
    this.viewport = e, pa(this.div, e);
    for (const t of o(this, K).getEditors(this.pageIndex))
      this.add(t), t.rebuild();
    this.updateMode();
  }
  update({
    viewport: e
  }) {
    o(this, K).commitOrRemove(), m(this, ce, Td).call(this);
    const t = this.viewport.rotation, s = e.rotation;
    if (this.viewport = e, pa(this.div, {
      rotation: s
    }), t !== s)
      for (const i of o(this, We).values())
        i.rotate(s);
    this.addInkEditorIfNeeded(!1);
  }
  get pageDimensions() {
    const {
      pageWidth: e,
      pageHeight: t
    } = this.viewport.rawDims;
    return [e, t];
  }
  get scale() {
    return o(this, K).viewParameters.realScale;
  }
}, Qr = new WeakMap(), Io = new WeakMap(), zs = new WeakMap(), En = new WeakMap(), Li = new WeakMap(), We = new WeakMap(), wn = new WeakMap(), Lo = new WeakMap(), Mo = new WeakMap(), ve = new WeakMap(), Mi = new WeakMap(), K = new WeakMap(), xn = new WeakMap(), ce = new WeakSet(), db = function(e) {
  o(this, K).unselectAll();
  const {
    target: t
  } = e;
  if (t === o(this, ve).div || (t.getAttribute("role") === "img" || t.classList.contains("endOfContent")) && o(this, ve).div.contains(t)) {
    const {
      isMac: s
    } = ke.platform;
    if (e.button !== 0 || e.ctrlKey && s)
      return;
    o(this, K).showAllEditors("highlight", !0, !0), o(this, ve).div.classList.add("free"), this.toggleDrawing(), Hd.startHighlighting(this, o(this, K).direction === "ltr", {
      target: o(this, ve).div,
      x: e.x,
      y: e.y
    }), o(this, ve).div.addEventListener("pointerup", () => {
      o(this, ve).div.classList.remove("free"), this.toggleDrawing(!0);
    }, {
      once: !0,
      signal: o(this, K)._signal
    }), e.preventDefault();
  }
}, qf = function() {
  return o(Ne, xn).get(o(this, K).getMode());
}, tp = function(e) {
  const t = o(this, ce, qf);
  return t ? new t.prototype.constructor(e) : null;
}, ep = function() {
  const {
    x: e,
    y: t,
    width: s,
    height: i
  } = this.div.getBoundingClientRect(), n = Math.max(0, e), r = Math.max(0, t), a = Math.min(window.innerWidth, e + s), h = Math.min(window.innerHeight, t + i), c = (n + a) / 2 - e, d = (r + h) / 2 - t, [u, f] = this.viewport.rotation % 180 === 0 ? [c, d] : [d, c];
  return {
    offsetX: u,
    offsetY: f
  };
}, Td = function() {
  v(this, Lo, !0);
  for (const e of o(this, We).values())
    e.isEmpty() && e.remove();
  v(this, Lo, !1);
}, Z(Ne, "_initialized", !1), y(Ne, xn, new Map([_f, $f, Qf, Hd].map((e) => [e._editorType, e]))), Ne);
var Ws, sc, Bt, Sn, ic, Ht, sp, va, ip, ub;
let vE = (Ht = class {
  constructor({
    pageIndex: e
  }) {
    y(this, va);
    y(this, Ws, null);
    y(this, sc, 0);
    y(this, Bt, /* @__PURE__ */ new Map());
    y(this, Sn, /* @__PURE__ */ new Map());
    this.pageIndex = e;
  }
  setParent(e) {
    if (!o(this, Ws)) {
      v(this, Ws, e);
      return;
    }
    if (o(this, Ws) !== e) {
      if (o(this, Bt).size > 0)
        for (const t of o(this, Bt).values())
          t.remove(), e.append(t);
      v(this, Ws, e);
    }
  }
  static get _svgFactory() {
    return ht(this, "_svgFactory", new $p());
  }
  highlight(e, t, s, i = !1) {
    const n = de(this, sc)._++, r = m(this, va, ip).call(this, e.box);
    r.classList.add("highlight"), e.free && r.classList.add("free");
    const a = Ht._svgFactory.createElement("defs");
    r.append(a);
    const h = Ht._svgFactory.createElement("path");
    a.append(h);
    const c = `path_p${this.pageIndex}_${n}`;
    h.setAttribute("id", c), h.setAttribute("d", e.toSVGPath()), i && o(this, Sn).set(n, h);
    const d = m(this, va, ub).call(this, a, c), u = Ht._svgFactory.createElement("use");
    return r.append(u), r.setAttribute("fill", t), r.setAttribute("fill-opacity", s), u.setAttribute("href", `#${c}`), o(this, Bt).set(n, r), {
      id: n,
      clipPathId: `url(#${d})`
    };
  }
  highlightOutline(e) {
    const t = de(this, sc)._++, s = m(this, va, ip).call(this, e.box);
    s.classList.add("highlightOutline");
    const i = Ht._svgFactory.createElement("defs");
    s.append(i);
    const n = Ht._svgFactory.createElement("path");
    i.append(n);
    const r = `path_p${this.pageIndex}_${t}`;
    n.setAttribute("id", r), n.setAttribute("d", e.toSVGPath()), n.setAttribute("vector-effect", "non-scaling-stroke");
    let a;
    if (e.free) {
      s.classList.add("free");
      const d = Ht._svgFactory.createElement("mask");
      i.append(d), a = `mask_p${this.pageIndex}_${t}`, d.setAttribute("id", a), d.setAttribute("maskUnits", "objectBoundingBox");
      const u = Ht._svgFactory.createElement("rect");
      d.append(u), u.setAttribute("width", "1"), u.setAttribute("height", "1"), u.setAttribute("fill", "white");
      const f = Ht._svgFactory.createElement("use");
      d.append(f), f.setAttribute("href", `#${r}`), f.setAttribute("stroke", "none"), f.setAttribute("fill", "black"), f.setAttribute("fill-rule", "nonzero"), f.classList.add("mask");
    }
    const h = Ht._svgFactory.createElement("use");
    s.append(h), h.setAttribute("href", `#${r}`), a && h.setAttribute("mask", `url(#${a})`);
    const c = h.cloneNode();
    return s.append(c), h.classList.add("mainOutline"), c.classList.add("secondaryOutline"), o(this, Bt).set(t, s), t;
  }
  finalizeLine(e, t) {
    const s = o(this, Sn).get(e);
    o(this, Sn).delete(e), this.updateBox(e, t.box), s.setAttribute("d", t.toSVGPath());
  }
  updateLine(e, t) {
    o(this, Bt).get(e).firstChild.firstChild.setAttribute("d", t.toSVGPath());
  }
  removeFreeHighlight(e) {
    this.remove(e), o(this, Sn).delete(e);
  }
  updatePath(e, t) {
    o(this, Sn).get(e).setAttribute("d", t.toSVGPath());
  }
  updateBox(e, t) {
    var s;
    m(s = Ht, ic, sp).call(s, o(this, Bt).get(e), t);
  }
  show(e, t) {
    o(this, Bt).get(e).classList.toggle("hidden", !t);
  }
  rotate(e, t) {
    o(this, Bt).get(e).setAttribute("data-main-rotation", t);
  }
  changeColor(e, t) {
    o(this, Bt).get(e).setAttribute("fill", t);
  }
  changeOpacity(e, t) {
    o(this, Bt).get(e).setAttribute("fill-opacity", t);
  }
  addClass(e, t) {
    o(this, Bt).get(e).classList.add(t);
  }
  removeClass(e, t) {
    o(this, Bt).get(e).classList.remove(t);
  }
  getSVGRoot(e) {
    return o(this, Bt).get(e);
  }
  remove(e) {
    o(this, Ws) !== null && (o(this, Bt).get(e).remove(), o(this, Bt).delete(e));
  }
  destroy() {
    v(this, Ws, null);
    for (const e of o(this, Bt).values())
      e.remove();
    o(this, Bt).clear();
  }
}, Ws = new WeakMap(), sc = new WeakMap(), Bt = new WeakMap(), Sn = new WeakMap(), ic = new WeakSet(), sp = function(e, {
  x: t = 0,
  y: s = 0,
  width: i = 1,
  height: n = 1
} = {}) {
  const {
    style: r
  } = e;
  r.top = `${100 * s}%`, r.left = `${100 * t}%`, r.width = `${100 * i}%`, r.height = `${100 * n}%`;
}, va = new WeakSet(), ip = function(e) {
  var s;
  const t = Ht._svgFactory.create(1, 1, !0);
  return o(this, Ws).append(t), t.setAttribute("aria-hidden", !0), m(s = Ht, ic, sp).call(s, t, e), t;
}, ub = function(e, t) {
  const s = Ht._svgFactory.createElement("clipPath");
  e.append(s);
  const i = `clip_${t}`;
  s.setAttribute("id", i), s.setAttribute("clipPathUnits", "objectBoundingBox");
  const n = Ht._svgFactory.createElement("use");
  return s.append(n), n.setAttribute("href", `#${t}`), n.classList.add("clip"), i;
}, y(Ht, ic), Ht);
q.AbortException;
q.AnnotationEditorLayer;
q.AnnotationEditorParamsType;
q.AnnotationEditorType;
q.AnnotationEditorUIManager;
var bE = q.AnnotationLayer;
q.AnnotationMode;
q.CMapCompressionType;
q.ColorPicker;
q.DOMSVGFactory;
q.DrawLayer;
q.FeatureTest;
var cx = q.GlobalWorkerOptions;
q.ImageKind;
q.InvalidPDFException;
q.MissingPDFException;
q.OPS;
q.OutputScale;
q.PDFDataRangeTransport;
q.PDFDateString;
q.PDFWorker;
var yE = q.PasswordResponses;
q.PermissionFlag;
q.PixelsPerInch;
q.RenderingCancelledException;
var AE = q.TextLayer;
q.UnexpectedResponseException;
q.Util;
q.VerbosityLevel;
q.XfaLayer;
q.build;
q.createValidAbsoluteUrl;
q.fetchData;
var EE = q.getDocument;
q.getFilenameFromUrl;
q.getPdfFilenameFromUrl;
q.getXfaPageViewport;
q.isDataScheme;
q.isPdfFile;
q.noContextMenu;
q.normalizeUnicode;
q.setLayerDimensions;
q.shadow;
q.version;
function wE(l, e, t) {
  const s = l.contentWindow.document.createElement("style");
  s.textContent = `
    @page {
      margin: 3mm;
      size: ${e}pt ${t}pt;
    }
    body {
      margin: 0;
    }
    canvas {
      width: 100%;
      page-break-after: always;
      page-break-before: avoid;
      page-break-inside: avoid;
    }
  `, l.contentWindow.document.head.appendChild(s), l.contentWindow.document.body.style.width = "100%";
}
function xE(l) {
  return new Promise((e) => {
    const t = document.createElement("iframe");
    t.width = "0", t.height = "0", t.style.position = "absolute", t.style.top = "0", t.style.left = "0", t.style.border = "none", t.style.overflow = "hidden", t.onload = () => e(t), l.appendChild(t);
  });
}
function SE(l, e) {
  const t = URL.createObjectURL(
    new Blob([l], {
      type: "application/pdf"
    })
  ), s = document.createElement("a");
  s.href = t, s.download = e, s.style.display = "none", document.body.append(s), s.click(), setTimeout(() => {
    URL.revokeObjectURL(t), document.body.removeChild(s);
  }, 1e3);
}
function Cg(l) {
  for (; l != null && l.firstChild; )
    l.removeChild(l.firstChild);
}
function Iu(l) {
  l == null || l.querySelectorAll("canvas").forEach((e) => {
    var t;
    e.width = 1, e.height = 1, (t = e.getContext("2d")) == null || t.clearRect(0, 0, 1, 1);
  });
}
function Rg(l) {
  return Object.prototype.hasOwnProperty.call(l, "_pdfInfo");
}
function TE({
  onError: l,
  onPasswordRequest: e,
  onProgress: t,
  source: s
}) {
  const i = Fd(null), n = Fd(null);
  return hy(async () => {
    const r = ig(s);
    if (r) {
      if (Rg(r)) {
        i.value = r;
        return;
      }
      try {
        n.value = EE(
          r
        ), e && (n.value.onPassword = (a, h) => {
          e({
            callback: a,
            isWrongPassword: h === yE.INCORRECT_PASSWORD
          });
        }), t && (n.value.onProgress = t), i.value = await n.value.promise;
      } catch (a) {
        if (i.value = null, l)
          l(a);
        else
          throw a;
      }
    }
  }), Bu(i, (r, a) => {
    a == null || a.destroy();
  }), um(() => {
    var r, a, h, c;
    (r = n.value) != null && r.onPassword && (n.value.onPassword = null), (a = n.value) != null && a.onProgress && (n.value.onProgress = null), (h = n.value) == null || h.destroy(), Rg(ig(s)) || (c = i.value) == null || c.destroy();
  }), {
    doc: i
  };
}
var Ml = {};
Ml.d = (l, e) => {
  for (var t in e)
    Ml.o(e, t) && !Ml.o(l, t) && Object.defineProperty(l, t, { enumerable: !0, get: e[t] });
};
Ml.o = (l, e) => Object.prototype.hasOwnProperty.call(l, e);
var Lt = globalThis.pdfjsViewer = {};
Ml.d(Lt, {
  AnnotationLayerBuilder: () => (
    /* reexport */
    Sb
  ),
  DownloadManager: () => (
    /* reexport */
    Aw
  ),
  EventBus: () => (
    /* reexport */
    Tb
  ),
  FindState: () => (
    /* reexport */
    Ki
  ),
  GenericL10n: () => (
    /* reexport */
    Jo
  ),
  LinkTarget: () => (
    /* reexport */
    Yn
  ),
  PDFFindController: () => (
    /* reexport */
    aw
  ),
  PDFHistory: () => (
    /* reexport */
    v0
  ),
  PDFLinkService: () => (
    /* reexport */
    $d
  ),
  PDFPageView: () => (
    /* reexport */
    Wb
  ),
  PDFScriptingManager: () => (
    /* reexport */
    I0
  ),
  PDFSinglePageViewer: () => (
    /* reexport */
    O0
  ),
  PDFViewer: () => (
    /* reexport */
    Qb
  ),
  ProgressBar: () => (
    /* reexport */
    FE
  ),
  RenderingStates: () => (
    /* reexport */
    Nt
  ),
  ScrollMode: () => (
    /* reexport */
    ct
  ),
  SimpleLinkService: () => (
    /* reexport */
    Zp
  ),
  SpreadMode: () => (
    /* reexport */
    be
  ),
  StructTreeLayerBuilder: () => (
    /* reexport */
    Bb
  ),
  TextLayerBuilder: () => (
    /* reexport */
    zd
  ),
  XfaLayerBuilder: () => (
    /* reexport */
    zb
  ),
  parseQueryString: () => (
    /* reexport */
    yu
  )
});
const PE = "auto", fb = 1, Ig = 1.1, CE = 0.1, RE = 10, Lu = 0, IE = 1.25, Lg = 40, Mg = 5, Nt = {
  INITIAL: 0,
  RUNNING: 1,
  PAUSED: 2,
  FINISHED: 3
}, Oa = {
  UNKNOWN: 0,
  NORMAL: 1,
  CHANGING: 2,
  FULLSCREEN: 3
}, Qs = {
  DISABLE: 0,
  ENABLE: 1,
  ENABLE_PERMISSIONS: 2
}, ct = {
  UNKNOWN: -1,
  VERTICAL: 0,
  HORIZONTAL: 1,
  WRAPPED: 2,
  PAGE: 3
}, be = {
  UNKNOWN: -1,
  NONE: 0,
  ODD: 1,
  EVEN: 2
};
function pb(l, e, t = !1) {
  let s = l.offsetParent;
  if (!s) {
    console.error("offsetParent is not set -- cannot scroll");
    return;
  }
  let i = l.offsetTop + l.clientTop, n = l.offsetLeft + l.clientLeft;
  for (; s.clientHeight === s.scrollHeight && s.clientWidth === s.scrollWidth || t && (s.classList.contains("markedContent") || getComputedStyle(s).overflow === "hidden"); )
    if (i += s.offsetTop, n += s.offsetLeft, s = s.offsetParent, !s)
      return;
  e && (e.top !== void 0 && (i += e.top), e.left !== void 0 && (n += e.left, s.scrollLeft = n)), s.scrollTop = i;
}
function LE(l, e, t = void 0) {
  const s = function(r) {
    n || (n = window.requestAnimationFrame(function() {
      n = null;
      const h = l.scrollLeft, c = i.lastX;
      h !== c && (i.right = h > c), i.lastX = h;
      const d = l.scrollTop, u = i.lastY;
      d !== u && (i.down = d > u), i.lastY = d, e(i);
    }));
  }, i = {
    right: !0,
    down: !0,
    lastX: l.scrollLeft,
    lastY: l.scrollTop,
    _eventHandler: s
  };
  let n = null;
  return l.addEventListener("scroll", s, {
    useCapture: !0,
    signal: t
  }), t == null || t.addEventListener("abort", () => window.cancelAnimationFrame(n), {
    once: !0
  }), i;
}
function yu(l) {
  const e = /* @__PURE__ */ new Map();
  for (const [t, s] of new URLSearchParams(l))
    e.set(t.toLowerCase(), s);
  return e;
}
const _g = /[\x00-\x1F]/g;
function _l(l, e = !1) {
  return _g.test(l) ? e ? l.replaceAll(_g, (t) => t === "\0" ? "" : " ") : l.replaceAll("\0", "") : l;
}
function Bl(l, e, t = 0) {
  let s = t, i = l.length - 1;
  if (i < 0 || !e(l[i]))
    return l.length;
  if (e(l[s]))
    return s;
  for (; s < i; ) {
    const n = s + i >> 1, r = l[n];
    e(r) ? i = n : s = n + 1;
  }
  return s;
}
function Og(l) {
  if (Math.floor(l) === l)
    return [l, 1];
  const e = 1 / l, t = 8;
  if (e > t)
    return [1, t];
  if (Math.floor(e) === e)
    return [1, e];
  const s = l > 1 ? e : l;
  let i = 0, n = 1, r = 1, a = 1;
  for (; ; ) {
    const c = i + r, d = n + a;
    if (d > t)
      break;
    s <= c / d ? (r = c, a = d) : (i = c, n = d);
  }
  let h;
  return s - i / n < r / a - s ? h = s === l ? [i, n] : [n, i] : h = s === l ? [r, a] : [a, r], h;
}
function $c(l, e) {
  return l - l % e;
}
function ME(l, e, t) {
  if (l < 2)
    return l;
  let s = e[l].div, i = s.offsetTop + s.clientTop;
  i >= t && (s = e[l - 1].div, i = s.offsetTop + s.clientTop);
  for (let n = l - 2; n >= 0 && (s = e[n].div, !(s.offsetTop + s.clientTop + s.clientHeight <= i)); --n)
    l = n;
  return l;
}
function _E({
  scrollEl: l,
  views: e,
  sortByVisibility: t = !1,
  horizontal: s = !1,
  rtl: i = !1
}) {
  const n = l.scrollTop, r = n + l.clientHeight, a = l.scrollLeft, h = a + l.clientWidth;
  function c(w) {
    const x = w.div;
    return x.offsetTop + x.clientTop + x.clientHeight > n;
  }
  function d(w) {
    const x = w.div, P = x.offsetLeft + x.clientLeft, T = P + x.clientWidth;
    return i ? P < h : T > a;
  }
  const u = [], f = /* @__PURE__ */ new Set(), p = e.length;
  let g = Bl(e, s ? d : c);
  g > 0 && g < p && !s && (g = ME(g, e, n));
  let b = s ? h : -1;
  for (let w = g; w < p; w++) {
    const x = e[w], P = x.div, T = P.offsetLeft + P.clientLeft, C = P.offsetTop + P.clientTop, R = P.clientWidth, M = P.clientHeight, S = T + R, I = C + M;
    if (b === -1)
      I >= r && (b = I);
    else if ((s ? T : C) > b)
      break;
    if (I <= n || C >= r || S <= a || T >= h)
      continue;
    const _ = Math.max(0, n - C) + Math.max(0, I - r), D = Math.max(0, a - T) + Math.max(0, S - h), k = (M - _) / M, j = (R - D) / R, H = k * j * 100 | 0;
    u.push({
      id: x.id,
      x: T,
      y: C,
      view: x,
      percent: H,
      widthPercent: j * 100 | 0
    }), f.add(x.id);
  }
  const E = u[0], A = u.at(-1);
  return t && u.sort(function(w, x) {
    const P = w.percent - x.percent;
    return Math.abs(P) > 1e-3 ? -P : w.id - x.id;
  }), {
    first: E,
    last: A,
    views: u,
    ids: f
  };
}
function gb(l) {
  return Number.isInteger(l) && l % 90 === 0;
}
function OE(l) {
  return Number.isInteger(l) && Object.values(ct).includes(l) && l !== ct.UNKNOWN;
}
function NE(l) {
  return Number.isInteger(l) && Object.values(be).includes(l) && l !== be.UNKNOWN;
}
function Ng(l) {
  return l.width <= l.height;
}
new Promise(function(l) {
  window.requestAnimationFrame(l);
});
const DE = document.documentElement.style;
function kE(l, e, t) {
  return Math.min(Math.max(l, e), t);
}
var Tn, Zr, Pn, _o, Jr;
class FE {
  constructor(e) {
    y(this, Tn, null);
    y(this, Zr, null);
    y(this, Pn, 0);
    y(this, _o, null);
    y(this, Jr, !0);
    v(this, Tn, e.classList), v(this, _o, e.style);
  }
  get percent() {
    return o(this, Pn);
  }
  set percent(e) {
    if (v(this, Pn, kE(e, 0, 100)), isNaN(e)) {
      o(this, Tn).add("indeterminate");
      return;
    }
    o(this, Tn).remove("indeterminate"), o(this, _o).setProperty("--progressBar-percent", `${o(this, Pn)}%`);
  }
  setWidth(e) {
    if (!e)
      return;
    const s = e.parentNode.offsetWidth - e.offsetWidth;
    s > 0 && o(this, _o).setProperty("--progressBar-end-offset", `${s}px`);
  }
  setDisableAutoFetch(e = 5e3) {
    o(this, Pn) === 100 || isNaN(o(this, Pn)) || (o(this, Zr) && clearTimeout(o(this, Zr)), this.show(), v(this, Zr, setTimeout(() => {
      v(this, Zr, null), this.hide();
    }, e)));
  }
  hide() {
    o(this, Jr) && (v(this, Jr, !1), o(this, Tn).add("hidden"));
  }
  show() {
    o(this, Jr) || (v(this, Jr, !0), o(this, Tn).remove("hidden"));
  }
}
Tn = new WeakMap(), Zr = new WeakMap(), Pn = new WeakMap(), _o = new WeakMap(), Jr = new WeakMap();
function jE(l) {
  let e = ct.VERTICAL, t = be.NONE;
  switch (l) {
    case "SinglePage":
      e = ct.PAGE;
      break;
    case "OneColumn":
      break;
    case "TwoPageLeft":
      e = ct.PAGE;
    case "TwoColumnLeft":
      t = be.ODD;
      break;
    case "TwoPageRight":
      e = ct.PAGE;
    case "TwoColumnRight":
      t = be.EVEN;
      break;
  }
  return {
    scrollMode: e,
    spreadMode: t
  };
}
const Vc = function() {
  const l = document.createElement("div");
  return l.style.width = "round(down, calc(1.6666666666666665 * 792px), 1px)", l.style.width === "calc(1320px)" ? Math.fround : (e) => e;
}(), ls = {
  SPACE: 0,
  ALPHA_LETTER: 1,
  PUNCT: 2,
  HAN_LETTER: 3,
  KATAKANA_LETTER: 4,
  HIRAGANA_LETTER: 5,
  HALFWIDTH_KATAKANA_LETTER: 6,
  THAI_LETTER: 7
};
function BE(l) {
  return l < 11904;
}
function HE(l) {
  return (l & 65408) === 0;
}
function $E(l) {
  return l >= 97 && l <= 122 || l >= 65 && l <= 90;
}
function VE(l) {
  return l >= 48 && l <= 57;
}
function UE(l) {
  return l === 32 || l === 9 || l === 13 || l === 10;
}
function zE(l) {
  return l >= 13312 && l <= 40959 || l >= 63744 && l <= 64255;
}
function WE(l) {
  return l >= 12448 && l <= 12543;
}
function GE(l) {
  return l >= 12352 && l <= 12447;
}
function XE(l) {
  return l >= 65376 && l <= 65439;
}
function KE(l) {
  return (l & 65408) === 3584;
}
function Uc(l) {
  return BE(l) ? HE(l) ? UE(l) ? ls.SPACE : $E(l) || VE(l) || l === 95 ? ls.ALPHA_LETTER : ls.PUNCT : KE(l) ? ls.THAI_LETTER : l === 160 ? ls.SPACE : ls.ALPHA_LETTER : zE(l) ? ls.HAN_LETTER : WE(l) ? ls.KATAKANA_LETTER : GE(l) ? ls.HIRAGANA_LETTER : XE(l) ? ls.HALFWIDTH_KATAKANA_LETTER : ls.ALPHA_LETTER;
}
let Dg;
function YE() {
  return Dg || (Dg = "Â Â¨ÂªÂ¯Â²-ÂµÂ¸-ÂºÂ¼-Â¾Ä²-Ä³Ä¿-ÅÅÅ¿Ç-ÇÇ±-Ç³Ê°-Ê¸Ë-ËË -Ë¤Í´ÍºÍ¾Î-ÎÎÏ-ÏÏ°-Ï²Ï´-ÏµÏ¹ÖÙµ-Ù¸à¥-à¥à§-à§à§à¨³à¨¶à©-à©à©à­-à­à¸³àº³à»-à»à¼à½à½à½à½à½à½©á¼á´¬-á´®á´°-á´ºá´¼-áµáµ-áµªáµ¸á¶-á¶¿áº-áºá½±á½³á½µá½·á½¹á½»á½½á¾»á¾½-á¿á¿á¿á¿-á¿á¿á¿á¿-á¿á¿£á¿«á¿­-á¿¯á¿¹á¿»á¿½-á¿¾â-ââââ¤-â¦â¯â³-â´â¶-â·â¼â¾â-ââââ°-â±â´-ââ-ââ¨â-ââ-ââ-ââ-ââ-ââ -â¢â¤â¦â¨âª-â­â¯-â±â³-â¹â»-ââ-ââ-â¿ââ¬-â­â¯-â°â©-âªâ -âªâ¨â©´-â©¶â«â±¼-â±½âµ¯âºâ»³â¼-â¿ãã¶ã¸-ãºã-ããã¿ã±-ãã-ãã-ãã -ãã-ã¾ã-ã¿ê-êê°ê²-ê´ê¸-ê¹ê­-ê­ê­©ï¤-ï¨ï¨ï¨ï¨-ï¨ï¨ ï¨¢ï¨¥-ï¨¦ï¨ª-ï©­ï©°-ï«ï¬-ï¬ï¬-ï¬ï¬ï¬-ï¬¶ï¬¸-ï¬¼ï¬¾ï­-ï­ï­-ï­ï­-ï®±ï¯-ï´½ïµ-ï¶ï¶-ï·ï·°-ï·¼ï¸-ï¸ï¸°-ï¹ï¹-ï¹ï¹-ï¹¦ï¹¨-ï¹«ï¹°-ï¹²ï¹´ï¹¶-ï»¼ï¼-ï¾¾ï¿-ï¿ï¿-ï¿ï¿-ï¿ï¿-ï¿ï¿ -ï¿¦"), Dg;
}
const Ki = {
  FOUND: 0,
  NOT_FOUND: 1,
  WRAPPED: 2,
  PENDING: 3
}, QE = 250, ZE = -50, JE = -400, kg = {
  "â": "-",
  "â": "'",
  "â": "'",
  "â": "'",
  "â": "'",
  "â": '"',
  "â": '"',
  "â": '"',
  "â": '"',
  "Â¼": "1/4",
  "Â½": "1/2",
  "Â¾": "3/4"
}, Fg = /* @__PURE__ */ new Set([12441, 12442, 2381, 2509, 2637, 2765, 2893, 3021, 3149, 3277, 3387, 3388, 3405, 3530, 3642, 3770, 3972, 4153, 4154, 5908, 5940, 6098, 6752, 6980, 7082, 7083, 7154, 7155, 11647, 43014, 43052, 43204, 43347, 43456, 43766, 44013, 3158, 3953, 3954, 3962, 3963, 3964, 3965, 3968, 3956]);
let jg;
const qE = new RegExp("\\p{M}+", "gu"), tw = new RegExp("([.*+?^${}()|[\\]\\\\])|(\\p{P})|(\\s+)|(\\p{M})|(\\p{L})", "gu"), ew = new RegExp("([^\\p{M}])\\p{M}*$", "u"), sw = new RegExp("^\\p{M}*([^\\p{M}])", "u"), iw = /[\uAC00-\uD7AF\uFA6C\uFACF-\uFAD1\uFAD5-\uFAD7]+/g, Bg = /* @__PURE__ */ new Map(), nw = "[\\u1100-\\u1112\\ud7a4-\\ud7af\\ud84a\\ud84c\\ud850\\ud854\\ud857\\ud85f]", Hg = /* @__PURE__ */ new Map();
let Mu = null, _u = null;
function Ou(l) {
  const e = [];
  let t;
  for (; (t = iw.exec(l)) !== null; ) {
    let {
      index: p
    } = t;
    for (const g of t[0]) {
      let b = Bg.get(g);
      b || (b = g.normalize("NFD").length, Bg.set(g, b)), e.push([b, p++]);
    }
  }
  let s;
  if (e.length === 0 && Mu)
    s = Mu;
  else if (e.length > 0 && _u)
    s = _u;
  else {
    const p = Object.keys(kg).join(""), g = YE(), w = `([${p}])|([${g}])|((?:ã|ã)\\n)|(\\p{M}+(?:-\\n)?)|(\\p{Ll}-\\n\\p{Lu})|(\\S-\\n)|((?:\\p{Ideographic}|[ã-ã¿])\\n)|(\\n)`;
    e.length === 0 ? s = Mu = new RegExp(w + "|(\\u0000)", "gum") : s = _u = new RegExp(w + `|(${nw})`, "gum");
  }
  const i = [];
  for (; (t = qE.exec(l)) !== null; )
    i.push([t[0].length, t.index]);
  let n = l.normalize("NFD");
  const r = [[0, 0]];
  let a = 0, h = 0, c = 0, d = 0, u = 0, f = !1;
  return n = n.replace(s, (p, g, b, E, A, w, x, P, T, C, R) => {
    var M, S, I;
    if (R -= d, g) {
      const _ = kg[g], D = _.length;
      for (let k = 1; k < D; k++)
        r.push([R - c + k, c - k]);
      return c -= D - 1, _;
    }
    if (b) {
      let _ = Hg.get(b);
      _ || (_ = b.normalize("NFKC"), Hg.set(b, _));
      const D = _.length;
      for (let k = 1; k < D; k++)
        r.push([R - c + k, c - k]);
      return c -= D - 1, _;
    }
    if (E)
      return f = !0, R + u === ((M = i[a]) == null ? void 0 : M[1]) ? ++a : (r.push([R - 1 - c + 1, c - 1]), c -= 1, d += 1), r.push([R - c + 1, c]), d += 1, u += 1, E.charAt(0);
    if (A) {
      const _ = A.endsWith(`
`), D = _ ? A.length - 2 : A.length;
      f = !0;
      let k = D;
      R + u === ((S = i[a]) == null ? void 0 : S[1]) && (k -= i[a][0], ++a);
      for (let j = 1; j <= k; j++)
        r.push([R - 1 - c + j, c - j]);
      return c -= k, d += k, _ ? (R += D - 1, r.push([R - c + 1, 1 + c]), c += 1, d += 1, u += 1, A.slice(0, D)) : A;
    }
    if (w)
      return r.push([R - c + 3, 1 + c]), c += 1, d += 1, u += 1, w.replace(`
`, "");
    if (x) {
      const _ = x.length - 2;
      return r.push([R - c + _, 1 + c]), c += 1, d += 1, u += 1, x.slice(0, -2);
    }
    if (P) {
      const _ = P.length - 1;
      return r.push([R - c + _, c]), d += 1, u += 1, P.slice(0, -1);
    }
    if (T)
      return r.push([R - c + 1, c - 1]), c -= 1, d += 1, u += 1, " ";
    if (R + u === ((I = e[h]) == null ? void 0 : I[1])) {
      const _ = e[h][0] - 1;
      ++h;
      for (let D = 1; D <= _; D++)
        r.push([R - (c - D), c - D]);
      c -= _, d += _;
    }
    return C;
  }), r.push([n.length, c]), [n, r, f];
}
function rw(l, e, t) {
  if (!l)
    return [e, t];
  const s = e, i = e + t - 1;
  let n = Bl(l, (d) => d[0] >= s);
  l[n][0] > s && --n;
  let r = Bl(l, (d) => d[0] >= i, n);
  l[r][0] > i && --r;
  const a = s + l[n][1], c = i + l[r][1] + 1 - a;
  return [a, c];
}
var ne, Oo, qr, G, mb, np, rp, vb, bb, ap, yb, Ab, Pd, xl, Ia, Eb, op, lp, Cd, wb, hp, cp, Sl;
class aw {
  constructor({
    linkService: e,
    eventBus: t,
    updateMatchesCountOnProgress: s = !0
  }) {
    y(this, G);
    y(this, ne, null);
    y(this, Oo, !0);
    y(this, qr, 0);
    this._linkService = e, this._eventBus = t, v(this, Oo, s), this.onIsPageVisible = null, m(this, G, np).call(this), t._on("find", m(this, G, mb).bind(this)), t._on("findbarclose", m(this, G, wb).bind(this));
  }
  get highlightMatches() {
    return this._highlightMatches;
  }
  get pageMatches() {
    return this._pageMatches;
  }
  get pageMatchesLength() {
    return this._pageMatchesLength;
  }
  get selected() {
    return this._selected;
  }
  get state() {
    return o(this, ne);
  }
  setDocument(e) {
    this._pdfDocument && m(this, G, np).call(this), e && (this._pdfDocument = e, this._firstPageCapability.resolve());
  }
  scrollMatchIntoView({
    element: e = null,
    selectedLeft: t = 0,
    pageIndex: s = -1,
    matchIndex: i = -1
  }) {
    if (!this._scrollMatches || !e)
      return;
    if (i === -1 || i !== this._selected.matchIdx)
      return;
    if (s === -1 || s !== this._selected.pageIdx)
      return;
    this._scrollMatches = !1;
    const n = {
      top: ZE,
      left: t + JE
    };
    pb(e, n, !0);
  }
  match(e, t, s) {
    const i = this._hasDiacritics[s];
    let n = !1;
    if (typeof e == "string" ? [n, e] = m(this, G, ap).call(this, e, i) : e = e.sort().reverse().map((u) => {
      const [f, p] = m(this, G, ap).call(this, u, i);
      return n || (n = f), `(${p})`;
    }).join("|"), !e)
      return;
    const {
      caseSensitive: r,
      entireWord: a
    } = o(this, ne), h = `g${n ? "u" : ""}${r ? "" : "i"}`;
    e = new RegExp(e, h);
    const c = [];
    let d;
    for (; (d = e.exec(t)) !== null; )
      a && !m(this, G, bb).call(this, t, d.index, d[0].length) || c.push({
        index: d.index,
        length: d[0].length
      });
    return c;
  }
}
ne = new WeakMap(), Oo = new WeakMap(), qr = new WeakMap(), G = new WeakSet(), mb = function(e) {
  if (!e)
    return;
  const t = this._pdfDocument, {
    type: s
  } = e;
  (o(this, ne) === null || m(this, G, vb).call(this, e)) && (this._dirtyMatch = !0), v(this, ne, e), s !== "highlightallchange" && m(this, G, Sl).call(this, Ki.PENDING), this._firstPageCapability.promise.then(() => {
    if (!this._pdfDocument || t && this._pdfDocument !== t)
      return;
    m(this, G, Ab).call(this);
    const i = !this._highlightMatches, n = !!this._findTimeout;
    this._findTimeout && (clearTimeout(this._findTimeout), this._findTimeout = null), s ? this._dirtyMatch ? m(this, G, Ia).call(this) : s === "again" ? (m(this, G, Ia).call(this), i && o(this, ne).highlightAll && m(this, G, xl).call(this)) : s === "highlightallchange" ? (n ? m(this, G, Ia).call(this) : this._highlightMatches = !0, m(this, G, xl).call(this)) : m(this, G, Ia).call(this) : this._findTimeout = setTimeout(() => {
      m(this, G, Ia).call(this), this._findTimeout = null;
    }, QE);
  });
}, np = function() {
  this._highlightMatches = !1, this._scrollMatches = !1, this._pdfDocument = null, this._pageMatches = [], this._pageMatchesLength = [], v(this, qr, 0), v(this, ne, null), this._selected = {
    pageIdx: -1,
    matchIdx: -1
  }, this._offset = {
    pageIdx: null,
    matchIdx: null,
    wrapped: !1
  }, this._extractTextPromises = [], this._pageContents = [], this._pageDiffs = [], this._hasDiacritics = [], this._matchesCountTotal = 0, this._pagesToSearch = null, this._pendingFindMatches = /* @__PURE__ */ new Set(), this._resumePageIdx = null, this._dirtyMatch = !1, clearTimeout(this._findTimeout), this._findTimeout = null, this._firstPageCapability = Promise.withResolvers();
}, rp = function() {
  const {
    query: e
  } = o(this, ne);
  return typeof e == "string" ? (e !== this._rawQuery && (this._rawQuery = e, [this._normalizedQuery] = Ou(e)), this._normalizedQuery) : (e || []).filter((t) => !!t).map((t) => Ou(t)[0]);
}, vb = function(e) {
  var r;
  const t = e.query, s = o(this, ne).query, i = typeof t;
  if (i !== typeof s)
    return !0;
  if (i === "string") {
    if (t !== s)
      return !0;
  } else if (JSON.stringify(t) !== JSON.stringify(s))
    return !0;
  switch (e.type) {
    case "again":
      const a = this._selected.pageIdx + 1, h = this._linkService;
      return a >= 1 && a <= h.pagesCount && a !== h.page && !(((r = this.onIsPageVisible) == null ? void 0 : r.call(this, a)) ?? !0);
    case "highlightallchange":
      return !1;
  }
  return !0;
}, bb = function(e, t, s) {
  let i = e.slice(0, t).match(ew);
  if (i) {
    const n = e.charCodeAt(t), r = i[1].charCodeAt(0);
    if (Uc(n) === Uc(r))
      return !1;
  }
  if (i = e.slice(t + s).match(sw), i) {
    const n = e.charCodeAt(t + s - 1), r = i[1].charCodeAt(0);
    if (Uc(n) === Uc(r))
      return !1;
  }
  return !0;
}, ap = function(e, t) {
  const {
    matchDiacritics: s
  } = o(this, ne);
  let i = !1;
  e = e.replaceAll(tw, (r, a, h, c, d, u) => a ? `[ ]*\\${a}[ ]*` : h ? `[ ]*${h}[ ]*` : c ? "[ ]+" : s ? d || u : d ? Fg.has(d.charCodeAt(0)) ? d : "" : t ? (i = !0, `${u}\\p{M}*`) : u);
  const n = "[ ]*";
  return e.endsWith(n) && (e = e.slice(0, e.length - n.length)), s && t && (jg || (jg = String.fromCharCode(...Fg)), i = !0, e = `${e}(?=[${jg}]|[^\\p{M}]|$)`), [i, e];
}, yb = function(e) {
  const t = o(this, G, rp);
  if (t.length === 0)
    return;
  const s = this._pageContents[e], i = this.match(t, s, e), n = this._pageMatches[e] = [], r = this._pageMatchesLength[e] = [], a = this._pageDiffs[e];
  i == null || i.forEach(({
    index: c,
    length: d
  }) => {
    const [u, f] = rw(a, c, d);
    f && (n.push(u), r.push(f));
  }), o(this, ne).highlightAll && m(this, G, Pd).call(this, e), this._resumePageIdx === e && (this._resumePageIdx = null, m(this, G, op).call(this));
  const h = n.length;
  this._matchesCountTotal += h, o(this, Oo) ? h > 0 && m(this, G, cp).call(this) : ++de(this, qr)._ === this._linkService.pagesCount && m(this, G, cp).call(this);
}, Ab = function() {
  if (this._extractTextPromises.length > 0)
    return;
  let e = Promise.resolve();
  const t = {
    disableNormalization: !0
  };
  for (let s = 0, i = this._linkService.pagesCount; s < i; s++) {
    const {
      promise: n,
      resolve: r
    } = Promise.withResolvers();
    this._extractTextPromises[s] = n, e = e.then(() => this._pdfDocument.getPage(s + 1).then((a) => a.getTextContent(t)).then((a) => {
      const h = [];
      for (const c of a.items)
        h.push(c.str), c.hasEOL && h.push(`
`);
      [this._pageContents[s], this._pageDiffs[s], this._hasDiacritics[s]] = Ou(h.join("")), r();
    }, (a) => {
      console.error(`Unable to get text content for page ${s + 1}`, a), this._pageContents[s] = "", this._pageDiffs[s] = null, this._hasDiacritics[s] = !1, r();
    }));
  }
}, Pd = function(e) {
  this._scrollMatches && this._selected.pageIdx === e && (this._linkService.page = e + 1), this._eventBus.dispatch("updatetextlayermatches", {
    source: this,
    pageIndex: e
  });
}, xl = function() {
  this._eventBus.dispatch("updatetextlayermatches", {
    source: this,
    pageIndex: -1
  });
}, Ia = function() {
  const e = o(this, ne).findPrevious, t = this._linkService.page - 1, s = this._linkService.pagesCount;
  if (this._highlightMatches = !0, this._dirtyMatch) {
    this._dirtyMatch = !1, this._selected.pageIdx = this._selected.matchIdx = -1, this._offset.pageIdx = t, this._offset.matchIdx = null, this._offset.wrapped = !1, this._resumePageIdx = null, this._pageMatches.length = 0, this._pageMatchesLength.length = 0, v(this, qr, 0), this._matchesCountTotal = 0, m(this, G, xl).call(this);
    for (let r = 0; r < s; r++)
      this._pendingFindMatches.has(r) || (this._pendingFindMatches.add(r), this._extractTextPromises[r].then(() => {
        this._pendingFindMatches.delete(r), m(this, G, yb).call(this, r);
      }));
  }
  if (o(this, G, rp).length === 0) {
    m(this, G, Sl).call(this, Ki.FOUND);
    return;
  }
  if (this._resumePageIdx)
    return;
  const n = this._offset;
  if (this._pagesToSearch = s, n.matchIdx !== null) {
    const r = this._pageMatches[n.pageIdx].length;
    if (!e && n.matchIdx + 1 < r || e && n.matchIdx > 0) {
      n.matchIdx = e ? n.matchIdx - 1 : n.matchIdx + 1, m(this, G, Cd).call(this, !0);
      return;
    }
    m(this, G, lp).call(this, e);
  }
  m(this, G, op).call(this);
}, Eb = function(e) {
  const t = this._offset, s = e.length, i = o(this, ne).findPrevious;
  return s ? (t.matchIdx = i ? s - 1 : 0, m(this, G, Cd).call(this, !0), !0) : (m(this, G, lp).call(this, i), t.wrapped && (t.matchIdx = null, this._pagesToSearch < 0) ? (m(this, G, Cd).call(this, !1), !0) : !1);
}, op = function() {
  this._resumePageIdx !== null && console.error("There can only be one pending page.");
  let e = null;
  do {
    const t = this._offset.pageIdx;
    if (e = this._pageMatches[t], !e) {
      this._resumePageIdx = t;
      break;
    }
  } while (!m(this, G, Eb).call(this, e));
}, lp = function(e) {
  const t = this._offset, s = this._linkService.pagesCount;
  t.pageIdx = e ? t.pageIdx - 1 : t.pageIdx + 1, t.matchIdx = null, this._pagesToSearch--, (t.pageIdx >= s || t.pageIdx < 0) && (t.pageIdx = e ? s - 1 : 0, t.wrapped = !0);
}, Cd = function(e = !1) {
  let t = Ki.NOT_FOUND;
  const s = this._offset.wrapped;
  if (this._offset.wrapped = !1, e) {
    const i = this._selected.pageIdx;
    this._selected.pageIdx = this._offset.pageIdx, this._selected.matchIdx = this._offset.matchIdx, t = s ? Ki.WRAPPED : Ki.FOUND, i !== -1 && i !== this._selected.pageIdx && m(this, G, Pd).call(this, i);
  }
  m(this, G, Sl).call(this, t, o(this, ne).findPrevious), this._selected.pageIdx !== -1 && (this._scrollMatches = !0, m(this, G, Pd).call(this, this._selected.pageIdx));
}, wb = function(e) {
  const t = this._pdfDocument;
  this._firstPageCapability.promise.then(() => {
    !this._pdfDocument || t && this._pdfDocument !== t || (this._findTimeout && (clearTimeout(this._findTimeout), this._findTimeout = null), this._resumePageIdx && (this._resumePageIdx = null, this._dirtyMatch = !0), m(this, G, Sl).call(this, Ki.FOUND), this._highlightMatches = !1, m(this, G, xl).call(this));
  });
}, hp = function() {
  var n;
  const {
    pageIdx: e,
    matchIdx: t
  } = this._selected;
  let s = 0, i = this._matchesCountTotal;
  if (t !== -1) {
    for (let r = 0; r < e; r++)
      s += ((n = this._pageMatches[r]) == null ? void 0 : n.length) || 0;
    s += t + 1;
  }
  return (s < 1 || s > i) && (s = i = 0), {
    current: s,
    total: i
  };
}, cp = function() {
  this._eventBus.dispatch("updatefindmatchescount", {
    source: this,
    matchesCount: m(this, G, hp).call(this)
  });
}, Sl = function(e, t = !1) {
  var s, i;
  !o(this, Oo) && (o(this, qr) !== this._linkService.pagesCount || e === Ki.PENDING) || this._eventBus.dispatch("updatefindcontrolstate", {
    source: this,
    state: e,
    previous: t,
    entireWord: ((s = o(this, ne)) == null ? void 0 : s.entireWord) ?? null,
    matchesCount: m(this, G, hp).call(this),
    rawQuery: ((i = o(this, ne)) == null ? void 0 : i.query) ?? null
  });
};
const ow = "noopener noreferrer nofollow", Yn = {
  NONE: 0,
  SELF: 1,
  BLANK: 2,
  PARENT: 3,
  TOP: 4
};
var lu, xb;
const hu = class hu {
  constructor({
    eventBus: e,
    externalLinkTarget: t = null,
    externalLinkRel: s = null,
    ignoreDestinationZoom: i = !1
  } = {}) {
    Z(this, "externalLinkEnabled", !0);
    this.eventBus = e, this.externalLinkTarget = t, this.externalLinkRel = s, this._ignoreDestinationZoom = i, this.baseUrl = null, this.pdfDocument = null, this.pdfViewer = null, this.pdfHistory = null;
  }
  setDocument(e, t = null) {
    this.baseUrl = t, this.pdfDocument = e;
  }
  setViewer(e) {
    this.pdfViewer = e;
  }
  setHistory(e) {
    this.pdfHistory = e;
  }
  get pagesCount() {
    return this.pdfDocument ? this.pdfDocument.numPages : 0;
  }
  get page() {
    return this.pdfDocument ? this.pdfViewer.currentPageNumber : 1;
  }
  set page(e) {
    this.pdfDocument && (this.pdfViewer.currentPageNumber = e);
  }
  get rotation() {
    return this.pdfDocument ? this.pdfViewer.pagesRotation : 0;
  }
  set rotation(e) {
    this.pdfDocument && (this.pdfViewer.pagesRotation = e);
  }
  get isInPresentationMode() {
    return this.pdfDocument ? this.pdfViewer.isInPresentationMode : !1;
  }
  async goToDestination(e) {
    if (!this.pdfDocument)
      return;
    let t, s, i;
    if (typeof e == "string" ? (t = e, s = await this.pdfDocument.getDestination(e)) : (t = null, s = await e), !Array.isArray(s)) {
      console.error(`goToDestination: "${s}" is not a valid destination array, for dest="${e}".`);
      return;
    }
    const [n] = s;
    if (n && typeof n == "object") {
      if (i = this.pdfDocument.cachedPageNumber(n), !i)
        try {
          i = await this.pdfDocument.getPageIndex(n) + 1;
        } catch {
          console.error(`goToDestination: "${n}" is not a valid page reference, for dest="${e}".`);
          return;
        }
    } else Number.isInteger(n) && (i = n + 1);
    if (!i || i < 1 || i > this.pagesCount) {
      console.error(`goToDestination: "${i}" is not a valid page number, for dest="${e}".`);
      return;
    }
    this.pdfHistory && (this.pdfHistory.pushCurrentPosition(), this.pdfHistory.push({
      namedDest: t,
      explicitDest: s,
      pageNumber: i
    })), this.pdfViewer.scrollPageIntoView({
      pageNumber: i,
      destArray: s,
      ignoreDestinationZoom: this._ignoreDestinationZoom
    });
  }
  goToPage(e) {
    if (!this.pdfDocument)
      return;
    const t = typeof e == "string" && this.pdfViewer.pageLabelToPageNumber(e) || e | 0;
    if (!(Number.isInteger(t) && t > 0 && t <= this.pagesCount)) {
      console.error(`PDFLinkService.goToPage: "${e}" is not a valid page.`);
      return;
    }
    this.pdfHistory && (this.pdfHistory.pushCurrentPosition(), this.pdfHistory.pushPage(t)), this.pdfViewer.scrollPageIntoView({
      pageNumber: t
    });
  }
  addLinkAttributes(e, t, s = !1) {
    if (!t || typeof t != "string")
      throw new Error('A valid "url" parameter must provided.');
    const i = s ? Yn.BLANK : this.externalLinkTarget, n = this.externalLinkRel;
    this.externalLinkEnabled ? e.href = e.title = t : (e.href = "", e.title = `Disabled: ${t}`, e.onclick = () => !1);
    let r = "";
    switch (i) {
      case Yn.NONE:
        break;
      case Yn.SELF:
        r = "_self";
        break;
      case Yn.BLANK:
        r = "_blank";
        break;
      case Yn.PARENT:
        r = "_parent";
        break;
      case Yn.TOP:
        r = "_top";
        break;
    }
    e.target = r, e.rel = typeof n == "string" ? n : ow;
  }
  getDestinationHash(e) {
    if (typeof e == "string") {
      if (e.length > 0)
        return this.getAnchorUrl("#" + escape(e));
    } else if (Array.isArray(e)) {
      const t = JSON.stringify(e);
      if (t.length > 0)
        return this.getAnchorUrl("#" + escape(t));
    }
    return this.getAnchorUrl("");
  }
  getAnchorUrl(e) {
    return this.baseUrl ? this.baseUrl + e : e;
  }
  setHash(e) {
    var i;
    if (!this.pdfDocument)
      return;
    let t, s;
    if (e.includes("=")) {
      const n = yu(e);
      if (n.has("search")) {
        const r = n.get("search").replaceAll('"', ""), a = n.get("phrase") === "true";
        this.eventBus.dispatch("findfromurlhash", {
          source: this,
          query: a ? r : r.match(/\S+/g)
        });
      }
      if (n.has("page") && (t = n.get("page") | 0 || 1), n.has("zoom")) {
        const r = n.get("zoom").split(","), a = r[0], h = parseFloat(a);
        a.includes("Fit") ? a === "Fit" || a === "FitB" ? s = [null, {
          name: a
        }] : a === "FitH" || a === "FitBH" || a === "FitV" || a === "FitBV" ? s = [null, {
          name: a
        }, r.length > 1 ? r[1] | 0 : null] : a === "FitR" ? r.length !== 5 ? console.error('PDFLinkService.setHash: Not enough parameters for "FitR".') : s = [null, {
          name: a
        }, r[1] | 0, r[2] | 0, r[3] | 0, r[4] | 0] : console.error(`PDFLinkService.setHash: "${a}" is not a valid zoom value.`) : s = [null, {
          name: "XYZ"
        }, r.length > 1 ? r[1] | 0 : null, r.length > 2 ? r[2] | 0 : null, h ? h / 100 : a];
      }
      s ? this.pdfViewer.scrollPageIntoView({
        pageNumber: t || this.page,
        destArray: s,
        allowNegativeOffset: !0
      }) : t && (this.page = t), n.has("pagemode") && this.eventBus.dispatch("pagemode", {
        source: this,
        mode: n.get("pagemode")
      }), n.has("nameddest") && this.goToDestination(n.get("nameddest"));
      return;
    }
    s = unescape(e);
    try {
      s = JSON.parse(s), Array.isArray(s) || (s = s.toString());
    } catch {
    }
    if (typeof s == "string" || m(i = hu, lu, xb).call(i, s)) {
      this.goToDestination(s);
      return;
    }
    console.error(`PDFLinkService.setHash: "${unescape(e)}" is not a valid destination.`);
  }
  executeNamedAction(e) {
    var t, s;
    if (this.pdfDocument) {
      switch (e) {
        case "GoBack":
          (t = this.pdfHistory) == null || t.back();
          break;
        case "GoForward":
          (s = this.pdfHistory) == null || s.forward();
          break;
        case "NextPage":
          this.pdfViewer.nextPage();
          break;
        case "PrevPage":
          this.pdfViewer.previousPage();
          break;
        case "LastPage":
          this.page = this.pagesCount;
          break;
        case "FirstPage":
          this.page = 1;
          break;
      }
      this.eventBus.dispatch("namedaction", {
        source: this,
        action: e
      });
    }
  }
  async executeSetOCGState(e) {
    if (!this.pdfDocument)
      return;
    const t = this.pdfDocument, s = await this.pdfViewer.optionalContentConfigPromise;
    t === this.pdfDocument && (s.setOCGState(e), this.pdfViewer.optionalContentConfigPromise = Promise.resolve(s));
  }
};
lu = new WeakSet(), xb = function(e) {
  if (!Array.isArray(e) || e.length < 2)
    return !1;
  const [t, s, ...i] = e;
  if (!(typeof t == "object" && Number.isInteger(t == null ? void 0 : t.num) && Number.isInteger(t == null ? void 0 : t.gen)) && !Number.isInteger(t) || !(typeof s == "object" && typeof (s == null ? void 0 : s.name) == "string"))
    return !1;
  const n = i.length;
  let r = !0;
  switch (s.name) {
    case "XYZ":
      if (n < 2 || n > 3)
        return !1;
      break;
    case "Fit":
    case "FitB":
      return n === 0;
    case "FitH":
    case "FitBH":
    case "FitV":
    case "FitBV":
      if (n > 1)
        return !1;
      break;
    case "FitR":
      if (n !== 4)
        return !1;
      r = !1;
      break;
    default:
      return !1;
  }
  for (const a of i)
    if (!(typeof a == "number" || r && a === null))
      return !1;
  return !0;
}, y(hu, lu);
let $d = hu;
class Zp extends $d {
  setDocument(e, t = null) {
  }
}
const {
  AbortException: lw,
  AnnotationEditorLayer: hw,
  AnnotationEditorParamsType: dx,
  AnnotationEditorType: je,
  AnnotationEditorUIManager: cw,
  AnnotationLayer: dw,
  AnnotationMode: Fi,
  build: ux,
  CMapCompressionType: fx,
  ColorPicker: px,
  createValidAbsoluteUrl: uw,
  DOMSVGFactory: gx,
  DrawLayer: fw,
  FeatureTest: mx,
  fetchData: $g,
  getDocument: vx,
  getFilenameFromUrl: bx,
  getPdfFilenameFromUrl: pw,
  getXfaPageViewport: yx,
  GlobalWorkerOptions: Ax,
  ImageKind: Ex,
  InvalidPDFException: wx,
  isDataScheme: xx,
  isPdfFile: gw,
  MissingPDFException: Sx,
  noContextMenu: Tx,
  normalizeUnicode: mw,
  OPS: Px,
  OutputScale: vw,
  PasswordResponses: Cx,
  PDFDataRangeTransport: Rx,
  PDFDateString: Ix,
  PDFWorker: Lx,
  PermissionFlag: zc,
  PixelsPerInch: li,
  RenderingCancelledException: dp,
  setLayerDimensions: bw,
  shadow: Vd,
  TextLayer: yw,
  UnexpectedResponseException: Mx,
  Util: _x,
  VerbosityLevel: Ox,
  version: Vg,
  XfaLayer: Nu
} = globalThis.pdfjsLib;
var nc, Cn, rc, up;
class Sb {
  constructor({
    pdfPage: e,
    linkService: t,
    downloadManager: s,
    annotationStorage: i = null,
    imageResourcesPath: n = "",
    renderForms: r = !0,
    enableScripting: a = !1,
    hasJSActionsPromise: h = null,
    fieldObjectsPromise: c = null,
    annotationCanvasMap: d = null,
    accessibilityManager: u = null,
    annotationEditorUIManager: f = null,
    onAppend: p = null
  }) {
    y(this, rc);
    y(this, nc, null);
    y(this, Cn, null);
    this.pdfPage = e, this.linkService = t, this.downloadManager = s, this.imageResourcesPath = n, this.renderForms = r, this.annotationStorage = i, this.enableScripting = a, this._hasJSActionsPromise = h || Promise.resolve(!1), this._fieldObjectsPromise = c || Promise.resolve(null), this._annotationCanvasMap = d, this._accessibilityManager = u, this._annotationEditorUIManager = f, v(this, nc, p), this.annotationLayer = null, this.div = null, this._cancelled = !1, this._eventBus = t.eventBus;
  }
  async render(e, t, s = "display") {
    var h, c;
    if (this.div) {
      if (this._cancelled || !this.annotationLayer)
        return;
      this.annotationLayer.update({
        viewport: e.clone({
          dontFlip: !0
        })
      });
      return;
    }
    const [i, n, r] = await Promise.all([this.pdfPage.getAnnotations({
      intent: s
    }), this._hasJSActionsPromise, this._fieldObjectsPromise]);
    if (this._cancelled)
      return;
    const a = this.div = document.createElement("div");
    if (a.className = "annotationLayer", (h = o(this, nc)) == null || h.call(this, a), i.length === 0) {
      this.hide();
      return;
    }
    this.annotationLayer = new dw({
      div: a,
      accessibilityManager: this._accessibilityManager,
      annotationCanvasMap: this._annotationCanvasMap,
      annotationEditorUIManager: this._annotationEditorUIManager,
      page: this.pdfPage,
      viewport: e.clone({
        dontFlip: !0
      }),
      structTreeLayer: (t == null ? void 0 : t.structTreeLayer) || null
    }), await this.annotationLayer.render({
      annotations: i,
      imageResourcesPath: this.imageResourcesPath,
      renderForms: this.renderForms,
      linkService: this.linkService,
      downloadManager: this.downloadManager,
      annotationStorage: this.annotationStorage,
      enableScripting: this.enableScripting,
      hasJSActions: n,
      fieldObjects: r
    }), this.linkService.isInPresentationMode && m(this, rc, up).call(this, Oa.FULLSCREEN), o(this, Cn) || (v(this, Cn, new AbortController()), (c = this._eventBus) == null || c._on("presentationmodechanged", (d) => {
      m(this, rc, up).call(this, d.state);
    }, {
      signal: o(this, Cn).signal
    }));
  }
  cancel() {
    var e;
    this._cancelled = !0, (e = o(this, Cn)) == null || e.abort(), v(this, Cn, null);
  }
  hide() {
    this.div && (this.div.hidden = !0);
  }
  hasEditableAnnotations() {
    var e;
    return !!((e = this.annotationLayer) != null && e.hasEditableAnnotations());
  }
}
nc = new WeakMap(), Cn = new WeakMap(), rc = new WeakSet(), up = function(e) {
  if (!this.div)
    return;
  let t = !1;
  switch (e) {
    case Oa.FULLSCREEN:
      t = !0;
      break;
    case Oa.NORMAL:
      break;
    default:
      return;
  }
  for (const s of this.div.childNodes)
    s.hasAttribute("data-internal-link") || (s.inert = t);
};
function Ug(l, e) {
  const t = document.createElement("a");
  if (!t.click)
    throw new Error('DownloadManager: "a.click()" is not supported.');
  t.href = l, t.target = "_parent", "download" in t && (t.download = e), (document.body || document.documentElement).append(t), t.click(), t.remove();
}
var jp;
class Aw {
  constructor() {
    y(this, jp, /* @__PURE__ */ new WeakMap());
  }
  downloadData(e, t, s) {
    const i = URL.createObjectURL(new Blob([e], {
      type: s
    }));
    Ug(i, t);
  }
  openOrDownloadData(e, t, s = null) {
    const n = gw(t) ? "application/pdf" : "";
    return this.downloadData(e, t, n), !1;
  }
  download(e, t, s) {
    let i;
    if (e)
      i = URL.createObjectURL(new Blob([e], {
        type: "application/pdf"
      }));
    else {
      if (!uw(t, "http://example.com")) {
        console.error(`download - not a valid URL: ${t}`);
        return;
      }
      i = t + "#pdfjs.action=download";
    }
    Ug(i, s);
  }
}
jp = new WeakMap();
const zg = {
  EVENT: "event",
  TIMEOUT: "timeout"
};
async function Ew({
  target: l,
  name: e,
  delay: t = 0
}) {
  if (typeof l != "object" || !(e && typeof e == "string") || !(Number.isInteger(t) && t >= 0))
    throw new Error("waitOnEventOrTimeout - invalid parameters.");
  const {
    promise: s,
    resolve: i
  } = Promise.withResolvers(), n = new AbortController();
  function r(c) {
    n.abort(), clearTimeout(h), i(c);
  }
  const a = l instanceof Tb ? "_on" : "addEventListener";
  l[a](e, r.bind(null, zg.EVENT), {
    signal: n.signal
  });
  const h = setTimeout(r.bind(null, zg.TIMEOUT), t);
  return s;
}
var No;
class Tb {
  constructor() {
    y(this, No, /* @__PURE__ */ Object.create(null));
  }
  on(e, t, s = null) {
    this._on(e, t, {
      external: !0,
      once: s == null ? void 0 : s.once,
      signal: s == null ? void 0 : s.signal
    });
  }
  off(e, t, s = null) {
    this._off(e, t);
  }
  dispatch(e, t) {
    const s = o(this, No)[e];
    if (!s || s.length === 0)
      return;
    let i;
    for (const {
      listener: n,
      external: r,
      once: a
    } of s.slice(0)) {
      if (a && this._off(e, n), r) {
        (i || (i = [])).push(n);
        continue;
      }
      n(t);
    }
    if (i) {
      for (const n of i)
        n(t);
      i = null;
    }
  }
  _on(e, t, s = null) {
    var r;
    let i = null;
    if ((s == null ? void 0 : s.signal) instanceof AbortSignal) {
      const {
        signal: a
      } = s;
      if (a.aborted) {
        console.error("Cannot use an `aborted` signal.");
        return;
      }
      const h = () => this._off(e, t);
      i = () => a.removeEventListener("abort", h), a.addEventListener("abort", h);
    }
    ((r = o(this, No))[e] || (r[e] = [])).push({
      listener: t,
      external: (s == null ? void 0 : s.external) === !0,
      once: (s == null ? void 0 : s.once) === !0,
      rmAbort: i
    });
  }
  _off(e, t, s = null) {
    var n;
    const i = o(this, No)[e];
    if (i)
      for (let r = 0, a = i.length; r < a; r++) {
        const h = i[r];
        if (h.listener === t) {
          (n = h.rmAbort) == null || n.call(h), i.splice(r, 1);
          return;
        }
      }
  }
}
No = new WeakMap();
class Au {
  constructor(e) {
    this.value = e;
  }
  valueOf() {
    return this.value;
  }
}
class $t extends Au {
  constructor(e = "???") {
    super(e);
  }
  toString(e) {
    return `{${this.value}}`;
  }
}
class Hi extends Au {
  constructor(e, t = {}) {
    super(e), this.opts = t;
  }
  toString(e) {
    try {
      return e.memoizeIntlObject(Intl.NumberFormat, this.opts).format(this.value);
    } catch (t) {
      return e.reportError(t), this.value.toString(10);
    }
  }
}
class Ol extends Au {
  constructor(e, t = {}) {
    super(e), this.opts = t;
  }
  toString(e) {
    try {
      return e.memoizeIntlObject(Intl.DateTimeFormat, this.opts).format(this.value);
    } catch (t) {
      return e.reportError(t), new Date(this.value).toISOString();
    }
  }
}
const Wg = 100, ww = "â¨", xw = "â©";
function Sw(l, e, t) {
  if (t === e || t instanceof Hi && e instanceof Hi && t.value === e.value)
    return !0;
  if (e instanceof Hi && typeof t == "string") {
    let s = l.memoizeIntlObject(Intl.PluralRules, e.opts).select(e.value);
    if (t === s)
      return !0;
  }
  return !1;
}
function Gg(l, e, t) {
  return e[t] ? Zo(l, e[t].value) : (l.reportError(new RangeError("No default")), new $t());
}
function fp(l, e) {
  const t = [], s = /* @__PURE__ */ Object.create(null);
  for (const i of e)
    i.type === "narg" ? s[i.name] = Hl(l, i.value) : t.push(Hl(l, i));
  return {
    positional: t,
    named: s
  };
}
function Hl(l, e) {
  switch (e.type) {
    case "str":
      return e.value;
    case "num":
      return new Hi(e.value, {
        minimumFractionDigits: e.precision
      });
    case "var":
      return Tw(l, e);
    case "mesg":
      return Pw(l, e);
    case "term":
      return Cw(l, e);
    case "func":
      return Rw(l, e);
    case "select":
      return Iw(l, e);
    default:
      return new $t();
  }
}
function Tw(l, {
  name: e
}) {
  let t;
  if (l.params)
    if (Object.prototype.hasOwnProperty.call(l.params, e))
      t = l.params[e];
    else
      return new $t(`$${e}`);
  else if (l.args && Object.prototype.hasOwnProperty.call(l.args, e))
    t = l.args[e];
  else
    return l.reportError(new ReferenceError(`Unknown variable: $${e}`)), new $t(`$${e}`);
  if (t instanceof Au)
    return t;
  switch (typeof t) {
    case "string":
      return t;
    case "number":
      return new Hi(t);
    case "object":
      if (t instanceof Date)
        return new Ol(t.getTime());
    default:
      return l.reportError(new TypeError(`Variable type not supported: $${e}, ${typeof t}`)), new $t(`$${e}`);
  }
}
function Pw(l, {
  name: e,
  attr: t
}) {
  const s = l.bundle._messages.get(e);
  if (!s)
    return l.reportError(new ReferenceError(`Unknown message: ${e}`)), new $t(e);
  if (t) {
    const i = s.attributes[t];
    return i ? Zo(l, i) : (l.reportError(new ReferenceError(`Unknown attribute: ${t}`)), new $t(`${e}.${t}`));
  }
  return s.value ? Zo(l, s.value) : (l.reportError(new ReferenceError(`No value: ${e}`)), new $t(e));
}
function Cw(l, {
  name: e,
  attr: t,
  args: s
}) {
  const i = `-${e}`, n = l.bundle._terms.get(i);
  if (!n)
    return l.reportError(new ReferenceError(`Unknown term: ${i}`)), new $t(i);
  if (t) {
    const a = n.attributes[t];
    if (a) {
      l.params = fp(l, s).named;
      const h = Zo(l, a);
      return l.params = null, h;
    }
    return l.reportError(new ReferenceError(`Unknown attribute: ${t}`)), new $t(`${i}.${t}`);
  }
  l.params = fp(l, s).named;
  const r = Zo(l, n.value);
  return l.params = null, r;
}
function Rw(l, {
  name: e,
  args: t
}) {
  let s = l.bundle._functions[e];
  if (!s)
    return l.reportError(new ReferenceError(`Unknown function: ${e}()`)), new $t(`${e}()`);
  if (typeof s != "function")
    return l.reportError(new TypeError(`Function ${e}() is not callable`)), new $t(`${e}()`);
  try {
    let i = fp(l, t);
    return s(i.positional, i.named);
  } catch (i) {
    return l.reportError(i), new $t(`${e}()`);
  }
}
function Iw(l, {
  selector: e,
  variants: t,
  star: s
}) {
  let i = Hl(l, e);
  if (i instanceof $t)
    return Gg(l, t, s);
  for (const n of t) {
    const r = Hl(l, n.key);
    if (Sw(l, i, r))
      return Zo(l, n.value);
  }
  return Gg(l, t, s);
}
function Pb(l, e) {
  if (l.dirty.has(e))
    return l.reportError(new RangeError("Cyclic reference")), new $t();
  l.dirty.add(e);
  const t = [], s = l.bundle._useIsolating && e.length > 1;
  for (const i of e) {
    if (typeof i == "string") {
      t.push(l.bundle._transform(i));
      continue;
    }
    if (l.placeables++, l.placeables > Wg)
      throw l.dirty.delete(e), new RangeError(`Too many placeables expanded: ${l.placeables}, max allowed is ${Wg}`);
    s && t.push(ww), t.push(Hl(l, i).toString(l)), s && t.push(xw);
  }
  return l.dirty.delete(e), t.join("");
}
function Zo(l, e) {
  return typeof e == "string" ? l.bundle._transform(e) : Pb(l, e);
}
class Lw {
  constructor(e, t, s) {
    this.dirty = /* @__PURE__ */ new WeakSet(), this.params = null, this.placeables = 0, this.bundle = e, this.errors = t, this.args = s;
  }
  reportError(e) {
    if (!this.errors || !(e instanceof Error))
      throw e;
    this.errors.push(e);
  }
  memoizeIntlObject(e, t) {
    let s = this.bundle._intls.get(e);
    s || (s = {}, this.bundle._intls.set(e, s));
    let i = JSON.stringify(t);
    return s[i] || (s[i] = new e(this.bundle.locales, t)), s[i];
  }
}
function Ud(l, e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const [s, i] of Object.entries(l))
    e.includes(s) && (t[s] = i.valueOf());
  return t;
}
const Xg = ["unitDisplay", "currencyDisplay", "useGrouping", "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", "minimumSignificantDigits", "maximumSignificantDigits"];
function Mw(l, e) {
  let t = l[0];
  if (t instanceof $t)
    return new $t(`NUMBER(${t.valueOf()})`);
  if (t instanceof Hi)
    return new Hi(t.valueOf(), {
      ...t.opts,
      ...Ud(e, Xg)
    });
  if (t instanceof Ol)
    return new Hi(t.valueOf(), {
      ...Ud(e, Xg)
    });
  throw new TypeError("Invalid argument to NUMBER");
}
const Kg = ["dateStyle", "timeStyle", "fractionalSecondDigits", "dayPeriod", "hour12", "weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName"];
function _w(l, e) {
  let t = l[0];
  if (t instanceof $t)
    return new $t(`DATETIME(${t.valueOf()})`);
  if (t instanceof Ol)
    return new Ol(t.valueOf(), {
      ...t.opts,
      ...Ud(e, Kg)
    });
  if (t instanceof Hi)
    return new Ol(t.valueOf(), {
      ...Ud(e, Kg)
    });
  throw new TypeError("Invalid argument to DATETIME");
}
const Yg = /* @__PURE__ */ new Map();
function Ow(l) {
  const e = Array.isArray(l) ? l.join(" ") : l;
  let t = Yg.get(e);
  return t === void 0 && (t = /* @__PURE__ */ new Map(), Yg.set(e, t)), t;
}
class Nw {
  constructor(e, {
    functions: t,
    useIsolating: s = !0,
    transform: i = (n) => n
  } = {}) {
    this._terms = /* @__PURE__ */ new Map(), this._messages = /* @__PURE__ */ new Map(), this.locales = Array.isArray(e) ? e : [e], this._functions = {
      NUMBER: Mw,
      DATETIME: _w,
      ...t
    }, this._useIsolating = s, this._transform = i, this._intls = Ow(e);
  }
  hasMessage(e) {
    return this._messages.has(e);
  }
  getMessage(e) {
    return this._messages.get(e);
  }
  addResource(e, {
    allowOverrides: t = !1
  } = {}) {
    const s = [];
    for (let i = 0; i < e.body.length; i++) {
      let n = e.body[i];
      if (n.id.startsWith("-")) {
        if (t === !1 && this._terms.has(n.id)) {
          s.push(new Error(`Attempt to override an existing term: "${n.id}"`));
          continue;
        }
        this._terms.set(n.id, n);
      } else {
        if (t === !1 && this._messages.has(n.id)) {
          s.push(new Error(`Attempt to override an existing message: "${n.id}"`));
          continue;
        }
        this._messages.set(n.id, n);
      }
    }
    return s;
  }
  formatPattern(e, t = null, s = null) {
    if (typeof e == "string")
      return this._transform(e);
    let i = new Lw(this, s, t);
    try {
      return Pb(i, e).toString(i);
    } catch (n) {
      if (i.errors && n instanceof Error)
        return i.errors.push(n), new $t().toString(i);
      throw n;
    }
  }
}
const Du = /^(-?[a-zA-Z][\w-]*) *= */gm, Qg = /\.([a-zA-Z][\w-]*) *= */y, Dw = /\*?\[/y, ku = /(-?[0-9]+(?:\.([0-9]+))?)/y, kw = /([a-zA-Z][\w-]*)/y, Zg = /([$-])?([a-zA-Z][\w-]*)(?:\.([a-zA-Z][\w-]*))?/y, Fw = /^[A-Z][A-Z0-9_-]*$/, Wc = /([^{}\n\r]+)/y, jw = /([^\\"\n\r]*)/y, Jg = /\\([\\"])/y, qg = /\\u([a-fA-F0-9]{4})|\\U([a-fA-F0-9]{6})/y, Bw = /^\n+/, tm = / +$/, Hw = / *\r?\n/g, $w = /( *)$/, Vw = /{\s*/y, em = /\s*}/y, Uw = /\[\s*/y, zw = /\s*] */y, Ww = /\s*\(\s*/y, Gw = /\s*->\s*/y, Xw = /\s*:\s*/y, Kw = /\s*,?\s*/y, Yw = /\s+/y;
class Qw {
  constructor(e) {
    this.body = [], Du.lastIndex = 0;
    let t = 0;
    for (; ; ) {
      let S = Du.exec(e);
      if (S === null)
        break;
      t = Du.lastIndex;
      try {
        this.body.push(h(S[1]));
      } catch (I) {
        if (I instanceof SyntaxError)
          continue;
        throw I;
      }
    }
    function s(S) {
      return S.lastIndex = t, S.test(e);
    }
    function i(S, I) {
      if (e[t] === S)
        return t++, !0;
      if (I)
        throw new I(`Expected ${S}`);
      return !1;
    }
    function n(S, I) {
      if (s(S))
        return t = S.lastIndex, !0;
      if (I)
        throw new I(`Expected ${S.toString()}`);
      return !1;
    }
    function r(S) {
      S.lastIndex = t;
      let I = S.exec(e);
      if (I === null)
        throw new SyntaxError(`Expected ${S.toString()}`);
      return t = S.lastIndex, I;
    }
    function a(S) {
      return r(S)[1];
    }
    function h(S) {
      let I = d(), _ = c();
      if (I === null && Object.keys(_).length === 0)
        throw new SyntaxError("Expected message value or attributes");
      return {
        id: S,
        value: I,
        attributes: _
      };
    }
    function c() {
      let S = /* @__PURE__ */ Object.create(null);
      for (; s(Qg); ) {
        let I = a(Qg), _ = d();
        if (_ === null)
          throw new SyntaxError("Expected attribute value");
        S[I] = _;
      }
      return S;
    }
    function d() {
      let S;
      if (s(Wc) && (S = a(Wc)), e[t] === "{" || e[t] === "}")
        return u(S ? [S] : [], 1 / 0);
      let I = C();
      return I ? S ? u([S, I], I.length) : (I.value = R(I.value, Bw), u([I], I.length)) : S ? R(S, tm) : null;
    }
    function u(S = [], I) {
      for (; ; ) {
        if (s(Wc)) {
          S.push(a(Wc));
          continue;
        }
        if (e[t] === "{") {
          S.push(f());
          continue;
        }
        if (e[t] === "}")
          throw new SyntaxError("Unbalanced closing brace");
        let j = C();
        if (j) {
          S.push(j), I = Math.min(I, j.length);
          continue;
        }
        break;
      }
      let _ = S.length - 1, D = S[_];
      typeof D == "string" && (S[_] = R(D, tm));
      let k = [];
      for (let j of S)
        j instanceof sm && (j = j.value.slice(0, j.value.length - I)), j && k.push(j);
      return k;
    }
    function f() {
      n(Vw, SyntaxError);
      let S = p();
      if (n(em))
        return S;
      if (n(Gw)) {
        let I = E();
        return n(em, SyntaxError), {
          type: "select",
          selector: S,
          ...I
        };
      }
      throw new SyntaxError("Unclosed placeable");
    }
    function p() {
      if (e[t] === "{")
        return f();
      if (s(Zg)) {
        let [, S, I, _ = null] = r(Zg);
        if (S === "$")
          return {
            type: "var",
            name: I
          };
        if (n(Ww)) {
          let D = g();
          if (S === "-")
            return {
              type: "term",
              name: I,
              attr: _,
              args: D
            };
          if (Fw.test(I))
            return {
              type: "func",
              name: I,
              args: D
            };
          throw new SyntaxError("Function names must be all upper-case");
        }
        return S === "-" ? {
          type: "term",
          name: I,
          attr: _,
          args: []
        } : {
          type: "mesg",
          name: I,
          attr: _
        };
      }
      return w();
    }
    function g() {
      let S = [];
      for (; ; ) {
        switch (e[t]) {
          case ")":
            return t++, S;
          case void 0:
            throw new SyntaxError("Unclosed argument list");
        }
        S.push(b()), n(Kw);
      }
    }
    function b() {
      let S = p();
      return S.type !== "mesg" ? S : n(Xw) ? {
        type: "narg",
        name: S.name,
        value: w()
      } : S;
    }
    function E() {
      let S = [], I = 0, _;
      for (; s(Dw); ) {
        i("*") && (_ = I);
        let D = A(), k = d();
        if (k === null)
          throw new SyntaxError("Expected variant value");
        S[I++] = {
          key: D,
          value: k
        };
      }
      if (I === 0)
        return null;
      if (_ === void 0)
        throw new SyntaxError("Expected default variant");
      return {
        variants: S,
        star: _
      };
    }
    function A() {
      n(Uw, SyntaxError);
      let S;
      return s(ku) ? S = x() : S = {
        type: "str",
        value: a(kw)
      }, n(zw, SyntaxError), S;
    }
    function w() {
      if (s(ku))
        return x();
      if (e[t] === '"')
        return P();
      throw new SyntaxError("Invalid expression");
    }
    function x() {
      let [, S, I = ""] = r(ku), _ = I.length;
      return {
        type: "num",
        value: parseFloat(S),
        precision: _
      };
    }
    function P() {
      i('"', SyntaxError);
      let S = "";
      for (; ; ) {
        if (S += a(jw), e[t] === "\\") {
          S += T();
          continue;
        }
        if (i('"'))
          return {
            type: "str",
            value: S
          };
        throw new SyntaxError("Unclosed string literal");
      }
    }
    function T() {
      if (s(Jg))
        return a(Jg);
      if (s(qg)) {
        let [, S, I] = r(qg), _ = parseInt(S || I, 16);
        return _ <= 55295 || 57344 <= _ ? String.fromCodePoint(_) : "ï¿½";
      }
      throw new SyntaxError("Unknown escape sequence");
    }
    function C() {
      let S = t;
      switch (n(Yw), e[t]) {
        case ".":
        case "[":
        case "*":
        case "}":
        case void 0:
          return !1;
        case "{":
          return M(e.slice(S, t));
      }
      return e[t - 1] === " " ? M(e.slice(S, t)) : !1;
    }
    function R(S, I) {
      return S.replace(I, "");
    }
    function M(S) {
      let I = S.replace(Hw, `
`), _ = $w.exec(S)[1].length;
      return new sm(I, _);
    }
  }
}
class sm {
  constructor(e, t) {
    this.value = e, this.length = t;
  }
}
const Zw = /<|&#?\w+;/, Jw = {
  "http://www.w3.org/1999/xhtml": ["em", "strong", "small", "s", "cite", "q", "dfn", "abbr", "data", "time", "code", "var", "samp", "kbd", "sub", "sup", "i", "b", "u", "mark", "bdi", "bdo", "span", "br", "wbr"]
}, qw = {
  "http://www.w3.org/1999/xhtml": {
    global: ["title", "aria-label", "aria-valuetext"],
    a: ["download"],
    area: ["download", "alt"],
    input: ["alt", "placeholder"],
    menuitem: ["label"],
    menu: ["label"],
    optgroup: ["label"],
    option: ["label"],
    track: ["label"],
    img: ["alt"],
    textarea: ["placeholder"],
    th: ["abbr"]
  },
  "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul": {
    global: ["accesskey", "aria-label", "aria-valuetext", "label", "title", "tooltiptext"],
    description: ["value"],
    key: ["key", "keycode"],
    label: ["value"],
    textbox: ["placeholder", "value"]
  }
};
function t0(l, e) {
  const {
    value: t
  } = e;
  if (typeof t == "string")
    if (l.localName === "title" && l.namespaceURI === "http://www.w3.org/1999/xhtml")
      l.textContent = t;
    else if (!Zw.test(t))
      l.textContent = t;
    else {
      const s = l.ownerDocument.createElementNS("http://www.w3.org/1999/xhtml", "template");
      s.innerHTML = t, e0(s.content, l);
    }
  Cb(e, l);
}
function e0(l, e) {
  for (const t of l.childNodes)
    if (t.nodeType !== t.TEXT_NODE) {
      if (t.hasAttribute("data-l10n-name")) {
        const s = i0(e, t);
        l.replaceChild(s, t);
        continue;
      }
      if (r0(t)) {
        const s = n0(t);
        l.replaceChild(s, t);
        continue;
      }
      console.warn(`An element of forbidden type "${t.localName}" was found in the translation. Only safe text-level elements and elements with data-l10n-name are allowed.`), l.replaceChild(pp(t), t);
    }
  e.textContent = "", e.appendChild(l);
}
function s0(l, e) {
  if (!l)
    return !1;
  for (let t of l)
    if (t.name === e)
      return !0;
  return !1;
}
function Cb(l, e) {
  const t = e.hasAttribute("data-l10n-attrs") ? e.getAttribute("data-l10n-attrs").split(",").map((s) => s.trim()) : null;
  for (const s of Array.from(e.attributes))
    im(s.name, e, t) && !s0(l.attributes, s.name) && e.removeAttribute(s.name);
  if (l.attributes)
    for (const s of Array.from(l.attributes))
      im(s.name, e, t) && e.getAttribute(s.name) !== s.value && e.setAttribute(s.name, s.value);
}
function i0(l, e) {
  const t = e.getAttribute("data-l10n-name"), s = l.querySelector(`[data-l10n-name="${t}"]`);
  if (!s)
    return console.warn(`An element named "${t}" wasn't found in the source.`), pp(e);
  if (s.localName !== e.localName)
    return console.warn(`An element named "${t}" was found in the translation but its type ${e.localName} didn't match the element found in the source (${s.localName}).`), pp(e);
  l.removeChild(s);
  const i = s.cloneNode(!1);
  return Rb(e, i);
}
function n0(l) {
  const e = l.ownerDocument.createElement(l.localName);
  return Rb(l, e);
}
function pp(l) {
  return l.ownerDocument.createTextNode(l.textContent);
}
function r0(l) {
  const e = Jw[l.namespaceURI];
  return e && e.includes(l.localName);
}
function im(l, e, t = null) {
  if (t && t.includes(l))
    return !0;
  const s = qw[e.namespaceURI];
  if (!s)
    return !1;
  const i = l.toLowerCase(), n = e.localName;
  if (s.global.includes(i))
    return !0;
  if (!s[n])
    return !1;
  if (s[n].includes(i))
    return !0;
  if (e.namespaceURI === "http://www.w3.org/1999/xhtml" && n === "input" && i === "value") {
    const r = e.type.toLowerCase();
    if (r === "submit" || r === "button" || r === "reset")
      return !0;
  }
  return !1;
}
function Rb(l, e) {
  return e.textContent = l.textContent, Cb(l, e), e;
}
class a0 extends Array {
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
}
class o0 extends a0 {
  constructor(e) {
    if (super(), Symbol.asyncIterator in Object(e))
      this.iterator = e[Symbol.asyncIterator]();
    else if (Symbol.iterator in Object(e))
      this.iterator = e[Symbol.iterator]();
    else
      throw new TypeError("Argument must implement the iteration protocol.");
  }
  [Symbol.asyncIterator]() {
    const e = this;
    let t = 0;
    return {
      async next() {
        return e.length <= t && e.push(e.iterator.next()), e[t++];
      }
    };
  }
  async touchNext(e = 1) {
    let t = 0;
    for (; t++ < e; ) {
      const s = this[this.length - 1];
      if (s && (await s).done)
        break;
      this.push(this.iterator.next());
    }
    return this[this.length - 1];
  }
}
class l0 {
  constructor(e = [], t) {
    this.resourceIds = e, this.generateBundles = t, this.onChange(!0);
  }
  addResourceIds(e, t = !1) {
    return this.resourceIds.push(...e), this.onChange(t), this.resourceIds.length;
  }
  removeResourceIds(e) {
    return this.resourceIds = this.resourceIds.filter((t) => !e.includes(t)), this.onChange(), this.resourceIds.length;
  }
  async formatWithFallback(e, t) {
    const s = [];
    let i = !1;
    for await (const n of this.bundles) {
      i = !0;
      const r = d0(t, n, e, s);
      if (r.size === 0)
        break;
      if (typeof console < "u") {
        const a = n.locales[0], h = Array.from(r).join(", ");
        console.warn(`[fluent] Missing translations in ${a}: ${h}`);
      }
    }
    return !i && typeof console < "u" && console.warn(`[fluent] Request for keys failed because no resource bundles got generated.
  keys: ${JSON.stringify(e)}.
  resourceIds: ${JSON.stringify(this.resourceIds)}.`), s;
  }
  formatMessages(e) {
    return this.formatWithFallback(e, c0);
  }
  formatValues(e) {
    return this.formatWithFallback(e, h0);
  }
  async formatValue(e, t) {
    const [s] = await this.formatValues([{
      id: e,
      args: t
    }]);
    return s;
  }
  handleEvent() {
    this.onChange();
  }
  onChange(e = !1) {
    this.bundles = o0.from(this.generateBundles(this.resourceIds)), e && this.bundles.touchNext(2);
  }
}
function h0(l, e, t, s) {
  return t.value ? l.formatPattern(t.value, s, e) : null;
}
function c0(l, e, t, s) {
  const i = {
    value: null,
    attributes: null
  };
  t.value && (i.value = l.formatPattern(t.value, s, e));
  let n = Object.keys(t.attributes);
  if (n.length > 0) {
    i.attributes = new Array(n.length);
    for (let [r, a] of n.entries()) {
      let h = l.formatPattern(t.attributes[a], s, e);
      i.attributes[r] = {
        name: a,
        value: h
      };
    }
  }
  return i;
}
function d0(l, e, t, s) {
  const i = [], n = /* @__PURE__ */ new Set();
  return t.forEach(({
    id: r,
    args: a
  }, h) => {
    if (s[h] !== void 0)
      return;
    let c = e.getMessage(r);
    if (c) {
      if (i.length = 0, s[h] = l(e, i, c, a), i.length > 0 && typeof console < "u") {
        const d = e.locales[0], u = i.join(", ");
        console.warn(`[fluent][resolver] errors in ${d}/${r}: ${u}.`);
      }
    } else
      n.add(r);
  }), n;
}
const Qn = "data-l10n-id", al = "data-l10n-args", u0 = `[${Qn}]`;
class f0 extends l0 {
  constructor(e, t) {
    super(e, t), this.roots = /* @__PURE__ */ new Set(), this.pendingrAF = null, this.pendingElements = /* @__PURE__ */ new Set(), this.windowElement = null, this.mutationObserver = null, this.observerConfig = {
      attributes: !0,
      characterData: !1,
      childList: !0,
      subtree: !0,
      attributeFilter: [Qn, al]
    };
  }
  onChange(e = !1) {
    super.onChange(e), this.roots && this.translateRoots();
  }
  setAttributes(e, t, s) {
    return e.setAttribute(Qn, t), s ? e.setAttribute(al, JSON.stringify(s)) : e.removeAttribute(al), e;
  }
  getAttributes(e) {
    return {
      id: e.getAttribute(Qn),
      args: JSON.parse(e.getAttribute(al) || null)
    };
  }
  connectRoot(e) {
    for (const t of this.roots)
      if (t === e || t.contains(e) || e.contains(t))
        throw new Error("Cannot add a root that overlaps with existing root.");
    if (this.windowElement) {
      if (this.windowElement !== e.ownerDocument.defaultView)
        throw new Error(`Cannot connect a root:
          DOMLocalization already has a root from a different window.`);
    } else
      this.windowElement = e.ownerDocument.defaultView, this.mutationObserver = new this.windowElement.MutationObserver((t) => this.translateMutations(t));
    this.roots.add(e), this.mutationObserver.observe(e, this.observerConfig);
  }
  disconnectRoot(e) {
    return this.roots.delete(e), this.pauseObserving(), this.roots.size === 0 ? (this.mutationObserver = null, this.windowElement && this.pendingrAF && this.windowElement.cancelAnimationFrame(this.pendingrAF), this.windowElement = null, this.pendingrAF = null, this.pendingElements.clear(), !0) : (this.resumeObserving(), !1);
  }
  translateRoots() {
    const e = Array.from(this.roots);
    return Promise.all(e.map((t) => this.translateFragment(t)));
  }
  pauseObserving() {
    this.mutationObserver && (this.translateMutations(this.mutationObserver.takeRecords()), this.mutationObserver.disconnect());
  }
  resumeObserving() {
    if (this.mutationObserver)
      for (const e of this.roots)
        this.mutationObserver.observe(e, this.observerConfig);
  }
  translateMutations(e) {
    for (const t of e)
      switch (t.type) {
        case "attributes":
          t.target.hasAttribute("data-l10n-id") && this.pendingElements.add(t.target);
          break;
        case "childList":
          for (const s of t.addedNodes)
            if (s.nodeType === s.ELEMENT_NODE)
              if (s.childElementCount)
                for (const i of this.getTranslatables(s))
                  this.pendingElements.add(i);
              else s.hasAttribute(Qn) && this.pendingElements.add(s);
          break;
      }
    this.pendingElements.size > 0 && this.pendingrAF === null && (this.pendingrAF = this.windowElement.requestAnimationFrame(() => {
      this.translateElements(Array.from(this.pendingElements)), this.pendingElements.clear(), this.pendingrAF = null;
    }));
  }
  translateFragment(e) {
    return this.translateElements(this.getTranslatables(e));
  }
  async translateElements(e) {
    if (!e.length)
      return;
    const t = e.map(this.getKeysForElement), s = await this.formatMessages(t);
    return this.applyTranslations(e, s);
  }
  applyTranslations(e, t) {
    this.pauseObserving();
    for (let s = 0; s < e.length; s++)
      t[s] !== void 0 && t0(e[s], t[s]);
    this.resumeObserving();
  }
  getTranslatables(e) {
    const t = Array.from(e.querySelectorAll(u0));
    return typeof e.hasAttribute == "function" && e.hasAttribute(Qn) && t.push(e), t;
  }
  getKeysForElement(e) {
    return {
      id: e.getAttribute(Qn),
      args: JSON.parse(e.getAttribute(al) || null)
    };
  }
}
var ac, Do, ko, Me, qo, Ib, Lb;
const Dl = class Dl {
  constructor({
    lang: e,
    isRTL: t
  }, s = null) {
    y(this, ac);
    y(this, Do, /* @__PURE__ */ new Set());
    y(this, ko);
    y(this, Me);
    var i, n;
    v(this, ko, m(i = Dl, qo, Ib).call(i, e)), v(this, Me, s), v(this, ac, t ?? m(n = Dl, qo, Lb).call(n, o(this, ko)) ? "rtl" : "ltr");
  }
  _setL10n(e) {
    v(this, Me, e);
  }
  getLanguage() {
    return o(this, ko);
  }
  getDirection() {
    return o(this, ac);
  }
  async get(e, t = null, s) {
    var n;
    return Array.isArray(e) ? (e = e.map((a) => ({
      id: a
    })), (await o(this, Me).formatMessages(e)).map((a) => a.value)) : ((n = (await o(this, Me).formatMessages([{
      id: e,
      args: t
    }]))[0]) == null ? void 0 : n.value) || s;
  }
  async translate(e) {
    o(this, Do).add(e);
    try {
      o(this, Me).connectRoot(e), await o(this, Me).translateRoots();
    } catch {
    }
  }
  async translateOnce(e) {
    try {
      await o(this, Me).translateElements([e]);
    } catch (t) {
      console.error(`translateOnce: "${t}".`);
    }
  }
  async destroy() {
    for (const e of o(this, Do))
      o(this, Me).disconnectRoot(e);
    o(this, Do).clear(), o(this, Me).pauseObserving();
  }
  pause() {
    o(this, Me).pauseObserving();
  }
  resume() {
    o(this, Me).resumeObserving();
  }
};
ac = new WeakMap(), Do = new WeakMap(), ko = new WeakMap(), Me = new WeakMap(), qo = new WeakSet(), Ib = function(e) {
  return e = (e == null ? void 0 : e.toLowerCase()) || "en-us", {
    en: "en-us",
    es: "es-es",
    fy: "fy-nl",
    ga: "ga-ie",
    gu: "gu-in",
    hi: "hi-in",
    hy: "hy-am",
    nb: "nb-no",
    ne: "ne-np",
    nn: "nn-no",
    pa: "pa-in",
    pt: "pt-pt",
    sv: "sv-se",
    zh: "zh-cn"
  }[e] || e;
}, Lb = function(e) {
  const t = e.split("-", 1)[0];
  return ["ar", "he", "fa", "ps", "ur"].includes(t);
}, y(Dl, qo);
let gp = Dl;
function nm(l, e) {
  const t = new Qw(e), s = new Nw(l), i = s.addResource(t);
  return i.length && console.error("L10n errors", i), s;
}
var Qe, Mb, _b, Ob, Nb, mp;
const qn = class qn extends gp {
  constructor(e) {
    super({
      lang: e
    });
    const t = e ? m(qn, Qe, Mb).bind(qn, "en-us", this.getLanguage()) : m(qn, Qe, Nb).bind(qn, this.getLanguage());
    this._setL10n(new f0([], t));
  }
};
Qe = new WeakSet(), Mb = async function* (e, t) {
  const {
    baseURL: s,
    paths: i
  } = await m(this, Qe, Ob).call(this), n = [t];
  if (e !== t) {
    const r = t.split("-", 1)[0];
    r !== t && n.push(r), n.push(e);
  }
  for (const r of n) {
    const a = await m(this, Qe, _b).call(this, r, s, i);
    a ? yield a : r === "en-us" && (yield m(this, Qe, mp).call(this, r));
  }
}, _b = async function(e, t, s) {
  const i = s[e];
  if (!i)
    return null;
  const n = new URL(i, t), r = await $g(n, "text");
  return nm(e, r);
}, Ob = async function() {
  try {
    const {
      href: e
    } = document.querySelector('link[type="application/l10n"]'), t = await $g(e, "json");
    return {
      baseURL: e.replace(/[^/]*$/, "") || "./",
      paths: t
    };
  } catch {
  }
  return {
    baseURL: "./",
    paths: /* @__PURE__ */ Object.create(null)
  };
}, Nb = async function* (e) {
  yield m(this, Qe, mp).call(this, e);
}, mp = async function(e) {
  return nm(e, `pdfjs-previous-button =
    .title = Previous Page
pdfjs-previous-button-label = Previous
pdfjs-next-button =
    .title = Next Page
pdfjs-next-button-label = Next
pdfjs-page-input =
    .title = Page
pdfjs-of-pages = of { $pagesCount }
pdfjs-page-of-pages = ({ $pageNumber } of { $pagesCount })
pdfjs-zoom-out-button =
    .title = Zoom Out
pdfjs-zoom-out-button-label = Zoom Out
pdfjs-zoom-in-button =
    .title = Zoom In
pdfjs-zoom-in-button-label = Zoom In
pdfjs-zoom-select =
    .title = Zoom
pdfjs-presentation-mode-button =
    .title = Switch to Presentation Mode
pdfjs-presentation-mode-button-label = Presentation Mode
pdfjs-open-file-button =
    .title = Open File
pdfjs-open-file-button-label = Open
pdfjs-print-button =
    .title = Print
pdfjs-print-button-label = Print
pdfjs-save-button =
    .title = Save
pdfjs-save-button-label = Save
pdfjs-download-button =
    .title = Download
pdfjs-download-button-label = Download
pdfjs-bookmark-button =
    .title = Current Page (View URL from Current Page)
pdfjs-bookmark-button-label = Current Page
pdfjs-tools-button =
    .title = Tools
pdfjs-tools-button-label = Tools
pdfjs-first-page-button =
    .title = Go to First Page
pdfjs-first-page-button-label = Go to First Page
pdfjs-last-page-button =
    .title = Go to Last Page
pdfjs-last-page-button-label = Go to Last Page
pdfjs-page-rotate-cw-button =
    .title = Rotate Clockwise
pdfjs-page-rotate-cw-button-label = Rotate Clockwise
pdfjs-page-rotate-ccw-button =
    .title = Rotate Counterclockwise
pdfjs-page-rotate-ccw-button-label = Rotate Counterclockwise
pdfjs-cursor-text-select-tool-button =
    .title = Enable Text Selection Tool
pdfjs-cursor-text-select-tool-button-label = Text Selection Tool
pdfjs-cursor-hand-tool-button =
    .title = Enable Hand Tool
pdfjs-cursor-hand-tool-button-label = Hand Tool
pdfjs-scroll-page-button =
    .title = Use Page Scrolling
pdfjs-scroll-page-button-label = Page Scrolling
pdfjs-scroll-vertical-button =
    .title = Use Vertical Scrolling
pdfjs-scroll-vertical-button-label = Vertical Scrolling
pdfjs-scroll-horizontal-button =
    .title = Use Horizontal Scrolling
pdfjs-scroll-horizontal-button-label = Horizontal Scrolling
pdfjs-scroll-wrapped-button =
    .title = Use Wrapped Scrolling
pdfjs-scroll-wrapped-button-label = Wrapped Scrolling
pdfjs-spread-none-button =
    .title = Do not join page spreads
pdfjs-spread-none-button-label = No Spreads
pdfjs-spread-odd-button =
    .title = Join page spreads starting with odd-numbered pages
pdfjs-spread-odd-button-label = Odd Spreads
pdfjs-spread-even-button =
    .title = Join page spreads starting with even-numbered pages
pdfjs-spread-even-button-label = Even Spreads
pdfjs-document-properties-button =
    .title = Document Propertiesâ¦
pdfjs-document-properties-button-label = Document Propertiesâ¦
pdfjs-document-properties-file-name = File name:
pdfjs-document-properties-file-size = File size:
pdfjs-document-properties-size-kb = { NUMBER($kb, maximumSignificantDigits: 3) } KB ({ $b } bytes)
pdfjs-document-properties-size-mb = { NUMBER($mb, maximumSignificantDigits: 3) } MB ({ $b } bytes)
pdfjs-document-properties-title = Title:
pdfjs-document-properties-author = Author:
pdfjs-document-properties-subject = Subject:
pdfjs-document-properties-keywords = Keywords:
pdfjs-document-properties-creation-date = Creation Date:
pdfjs-document-properties-modification-date = Modification Date:
pdfjs-document-properties-date-time-string = { DATETIME($dateObj, dateStyle: "short", timeStyle: "medium") }
pdfjs-document-properties-creator = Creator:
pdfjs-document-properties-producer = PDF Producer:
pdfjs-document-properties-version = PDF Version:
pdfjs-document-properties-page-count = Page Count:
pdfjs-document-properties-page-size = Page Size:
pdfjs-document-properties-page-size-unit-inches = in
pdfjs-document-properties-page-size-unit-millimeters = mm
pdfjs-document-properties-page-size-orientation-portrait = portrait
pdfjs-document-properties-page-size-orientation-landscape = landscape
pdfjs-document-properties-page-size-name-a-three = A3
pdfjs-document-properties-page-size-name-a-four = A4
pdfjs-document-properties-page-size-name-letter = Letter
pdfjs-document-properties-page-size-name-legal = Legal
pdfjs-document-properties-page-size-dimension-string = { $width } Ã { $height } { $unit } ({ $orientation })
pdfjs-document-properties-page-size-dimension-name-string = { $width } Ã { $height } { $unit } ({ $name }, { $orientation })
pdfjs-document-properties-linearized = Fast Web View:
pdfjs-document-properties-linearized-yes = Yes
pdfjs-document-properties-linearized-no = No
pdfjs-document-properties-close-button = Close
pdfjs-print-progress-message = Preparing document for printingâ¦
pdfjs-print-progress-percent = { $progress }%
pdfjs-print-progress-close-button = Cancel
pdfjs-printing-not-supported = Warning: Printing is not fully supported by this browser.
pdfjs-printing-not-ready = Warning: The PDF is not fully loaded for printing.
pdfjs-toggle-sidebar-button =
    .title = Toggle Sidebar
pdfjs-toggle-sidebar-notification-button =
    .title = Toggle Sidebar (document contains outline/attachments/layers)
pdfjs-toggle-sidebar-button-label = Toggle Sidebar
pdfjs-document-outline-button =
    .title = Show Document Outline (double-click to expand/collapse all items)
pdfjs-document-outline-button-label = Document Outline
pdfjs-attachments-button =
    .title = Show Attachments
pdfjs-attachments-button-label = Attachments
pdfjs-layers-button =
    .title = Show Layers (double-click to reset all layers to the default state)
pdfjs-layers-button-label = Layers
pdfjs-thumbs-button =
    .title = Show Thumbnails
pdfjs-thumbs-button-label = Thumbnails
pdfjs-current-outline-item-button =
    .title = Find Current Outline Item
pdfjs-current-outline-item-button-label = Current Outline Item
pdfjs-findbar-button =
    .title = Find in Document
pdfjs-findbar-button-label = Find
pdfjs-additional-layers = Additional Layers
pdfjs-thumb-page-title =
    .title = Page { $page }
pdfjs-thumb-page-canvas =
    .aria-label = Thumbnail of Page { $page }
pdfjs-find-input =
    .title = Find
    .placeholder = Find in documentâ¦
pdfjs-find-previous-button =
    .title = Find the previous occurrence of the phrase
pdfjs-find-previous-button-label = Previous
pdfjs-find-next-button =
    .title = Find the next occurrence of the phrase
pdfjs-find-next-button-label = Next
pdfjs-find-highlight-checkbox = Highlight All
pdfjs-find-match-case-checkbox-label = Match Case
pdfjs-find-match-diacritics-checkbox-label = Match Diacritics
pdfjs-find-entire-word-checkbox-label = Whole Words
pdfjs-find-reached-top = Reached top of document, continued from bottom
pdfjs-find-reached-bottom = Reached end of document, continued from top
pdfjs-find-match-count =
    { $total ->
        [one] { $current } of { $total } match
       *[other] { $current } of { $total } matches
    }
pdfjs-find-match-count-limit =
    { $limit ->
        [one] More than { $limit } match
       *[other] More than { $limit } matches
    }
pdfjs-find-not-found = Phrase not found
pdfjs-page-scale-width = Page Width
pdfjs-page-scale-fit = Page Fit
pdfjs-page-scale-auto = Automatic Zoom
pdfjs-page-scale-actual = Actual Size
pdfjs-page-scale-percent = { $scale }%
pdfjs-page-landmark =
    .aria-label = Page { $page }
pdfjs-loading-error = An error occurred while loading the PDF.
pdfjs-invalid-file-error = Invalid or corrupted PDF file.
pdfjs-missing-file-error = Missing PDF file.
pdfjs-unexpected-response-error = Unexpected server response.
pdfjs-rendering-error = An error occurred while rendering the page.
pdfjs-annotation-date-time-string = { DATETIME($dateObj, dateStyle: "short", timeStyle: "medium") }
pdfjs-text-annotation-type =
    .alt = [{ $type } Annotation]
pdfjs-password-label = Enter the password to open this PDF file.
pdfjs-password-invalid = Invalid password. Please try again.
pdfjs-password-ok-button = OK
pdfjs-password-cancel-button = Cancel
pdfjs-web-fonts-disabled = Web fonts are disabled: unable to use embedded PDF fonts.
pdfjs-editor-free-text-button =
    .title = Text
pdfjs-editor-free-text-button-label = Text
pdfjs-editor-ink-button =
    .title = Draw
pdfjs-editor-ink-button-label = Draw
pdfjs-editor-stamp-button =
    .title = Add or edit images
pdfjs-editor-stamp-button-label = Add or edit images
pdfjs-editor-highlight-button =
    .title = Highlight
pdfjs-editor-highlight-button-label = Highlight
pdfjs-highlight-floating-button1 =
    .title = Highlight
    .aria-label = Highlight
pdfjs-highlight-floating-button-label = Highlight
pdfjs-editor-remove-ink-button =
    .title = Remove drawing
pdfjs-editor-remove-freetext-button =
    .title = Remove text
pdfjs-editor-remove-stamp-button =
    .title = Remove image
pdfjs-editor-remove-highlight-button =
    .title = Remove highlight
pdfjs-editor-free-text-color-input = Color
pdfjs-editor-free-text-size-input = Size
pdfjs-editor-ink-color-input = Color
pdfjs-editor-ink-thickness-input = Thickness
pdfjs-editor-ink-opacity-input = Opacity
pdfjs-editor-stamp-add-image-button =
    .title = Add image
pdfjs-editor-stamp-add-image-button-label = Add image
pdfjs-editor-free-highlight-thickness-input = Thickness
pdfjs-editor-free-highlight-thickness-title =
    .title = Change thickness when highlighting items other than text
pdfjs-free-text =
    .aria-label = Text Editor
pdfjs-free-text-default-content = Start typingâ¦
pdfjs-ink =
    .aria-label = Draw Editor
pdfjs-ink-canvas =
    .aria-label = User-created image
pdfjs-editor-alt-text-button-label = Alt text
pdfjs-editor-alt-text-edit-button-label = Edit alt text
pdfjs-editor-alt-text-dialog-label = Choose an option
pdfjs-editor-alt-text-dialog-description = Alt text (alternative text) helps when people canât see the image or when it doesnât load.
pdfjs-editor-alt-text-add-description-label = Add a description
pdfjs-editor-alt-text-add-description-description = Aim for 1-2 sentences that describe the subject, setting, or actions.
pdfjs-editor-alt-text-mark-decorative-label = Mark as decorative
pdfjs-editor-alt-text-mark-decorative-description = This is used for ornamental images, like borders or watermarks.
pdfjs-editor-alt-text-cancel-button = Cancel
pdfjs-editor-alt-text-save-button = Save
pdfjs-editor-alt-text-decorative-tooltip = Marked as decorative
pdfjs-editor-alt-text-textarea =
    .placeholder = For example, âA young man sits down at a table to eat a mealâ
pdfjs-editor-resizer-top-left =
    .aria-label = Top left corner â resize
pdfjs-editor-resizer-top-middle =
    .aria-label = Top middle â resize
pdfjs-editor-resizer-top-right =
    .aria-label = Top right corner â resize
pdfjs-editor-resizer-middle-right =
    .aria-label = Middle right â resize
pdfjs-editor-resizer-bottom-right =
    .aria-label = Bottom right corner â resize
pdfjs-editor-resizer-bottom-middle =
    .aria-label = Bottom middle â resize
pdfjs-editor-resizer-bottom-left =
    .aria-label = Bottom left corner â resize
pdfjs-editor-resizer-middle-left =
    .aria-label = Middle left â resize
pdfjs-editor-highlight-colorpicker-label = Highlight color
pdfjs-editor-colorpicker-button =
    .title = Change color
pdfjs-editor-colorpicker-dropdown =
    .aria-label = Color choices
pdfjs-editor-colorpicker-yellow =
    .title = Yellow
pdfjs-editor-colorpicker-green =
    .title = Green
pdfjs-editor-colorpicker-blue =
    .title = Blue
pdfjs-editor-colorpicker-pink =
    .title = Pink
pdfjs-editor-colorpicker-red =
    .title = Red
pdfjs-editor-highlight-show-all-button-label = Show all
pdfjs-editor-highlight-show-all-button =
    .title = Show all
pdfjs-editor-new-alt-text-dialog-edit-label = Edit alt text (image description)
pdfjs-editor-new-alt-text-dialog-add-label = Add alt text (image description)
pdfjs-editor-new-alt-text-textarea =
    .placeholder = Write your description hereâ¦
pdfjs-editor-new-alt-text-description = Short description for people who canât see the image or when the image doesnât load.
pdfjs-editor-new-alt-text-disclaimer1 = This alt text was created automatically and may be inaccurate.
pdfjs-editor-new-alt-text-disclaimer-learn-more-url = Learn more
pdfjs-editor-new-alt-text-create-automatically-button-label = Create alt text automatically
pdfjs-editor-new-alt-text-not-now-button = Not now
pdfjs-editor-new-alt-text-error-title = Couldnât create alt text automatically
pdfjs-editor-new-alt-text-error-description = Please write your own alt text or try again later.
pdfjs-editor-new-alt-text-error-close-button = Close
pdfjs-editor-new-alt-text-ai-model-downloading-progress = Downloading alt text AI model ({ $downloadedSize } of { $totalSize } MB)
    .aria-valuetext = Downloading alt text AI model ({ $downloadedSize } of { $totalSize } MB)
pdfjs-editor-new-alt-text-added-button-label = Alt text added
pdfjs-editor-new-alt-text-missing-button-label = Missing alt text
pdfjs-editor-new-alt-text-to-review-button-label = Review alt text
pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer = Created automatically: { $generatedAltText }
pdfjs-image-alt-text-settings-button =
    .title = Image alt text settings
pdfjs-image-alt-text-settings-button-label = Image alt text settings
pdfjs-editor-alt-text-settings-dialog-label = Image alt text settings
pdfjs-editor-alt-text-settings-automatic-title = Automatic alt text
pdfjs-editor-alt-text-settings-create-model-button-label = Create alt text automatically
pdfjs-editor-alt-text-settings-create-model-description = Suggests descriptions to help people who canât see the image or when the image doesnât load.
pdfjs-editor-alt-text-settings-download-model-label = Alt text AI model ({ $totalSize } MB)
pdfjs-editor-alt-text-settings-ai-model-description = Runs locally on your device so your data stays private. Required for automatic alt text.
pdfjs-editor-alt-text-settings-delete-model-button = Delete
pdfjs-editor-alt-text-settings-download-model-button = Download
pdfjs-editor-alt-text-settings-downloading-model-button = Downloadingâ¦
pdfjs-editor-alt-text-settings-editor-title = Alt text editor
pdfjs-editor-alt-text-settings-show-dialog-button-label = Show alt text editor right away when adding an image
pdfjs-editor-alt-text-settings-show-dialog-description = Helps you make sure all your images have alt text.
pdfjs-editor-alt-text-settings-close-button = Close`);
}, y(qn, Qe);
let Jo = qn;
const p0 = 1e3, g0 = 50, m0 = 1e3;
function Fu() {
  return document.location.hash;
}
var Rn, tt, ri, Rd, Id, Tl, Ld, vp, Db, kb, bp, Fb, jb;
class v0 {
  constructor({
    linkService: e,
    eventBus: t
  }) {
    y(this, tt);
    y(this, Rn, null);
    this.linkService = e, this.eventBus = t, this._initialized = !1, this._fingerprint = "", this.reset(), this.eventBus._on("pagesinit", () => {
      this._isPagesLoaded = !1, this.eventBus._on("pagesloaded", (s) => {
        this._isPagesLoaded = !!s.pagesCount;
      }, {
        once: !0
      });
    });
  }
  initialize({
    fingerprint: e,
    resetHistory: t = !1,
    updateUrl: s = !1
  }) {
    if (!e || typeof e != "string") {
      console.error('PDFHistory.initialize: The "fingerprint" must be a non-empty string.');
      return;
    }
    this._initialized && this.reset();
    const i = this._fingerprint !== "" && this._fingerprint !== e;
    this._fingerprint = e, this._updateUrl = s === !0, this._initialized = !0, m(this, tt, Fb).call(this);
    const n = window.history.state;
    if (this._popStateInProgress = !1, this._blockHashChange = 0, this._currentHash = Fu(), this._numPositionUpdates = 0, this._uid = this._maxUid = 0, this._destination = null, this._position = null, !m(this, tt, Tl).call(this, n, !0) || t) {
      const {
        hash: a,
        page: h,
        rotation: c
      } = m(this, tt, vp).call(this, !0);
      if (!a || i || t) {
        m(this, tt, ri).call(this, null, !0);
        return;
      }
      m(this, tt, ri).call(this, {
        hash: a,
        page: h,
        rotation: c
      }, !0);
      return;
    }
    const r = n.destination;
    m(this, tt, Ld).call(this, r, n.uid, !0), r.rotation !== void 0 && (this._initialRotation = r.rotation), r.dest ? (this._initialBookmark = JSON.stringify(r.dest), this._destination.page = null) : r.hash ? this._initialBookmark = r.hash : r.page && (this._initialBookmark = `page=${r.page}`);
  }
  reset() {
    this._initialized && (m(this, tt, bp).call(this), this._initialized = !1, m(this, tt, jb).call(this)), this._updateViewareaTimeout && (clearTimeout(this._updateViewareaTimeout), this._updateViewareaTimeout = null), this._initialBookmark = null, this._initialRotation = null;
  }
  push({
    namedDest: e = null,
    explicitDest: t,
    pageNumber: s
  }) {
    if (!this._initialized)
      return;
    if (e && typeof e != "string") {
      console.error(`PDFHistory.push: "${e}" is not a valid namedDest parameter.`);
      return;
    } else if (Array.isArray(t)) {
      if (!m(this, tt, Id).call(this, s) && (s !== null || this._destination)) {
        console.error(`PDFHistory.push: "${s}" is not a valid pageNumber parameter.`);
        return;
      }
    } else {
      console.error(`PDFHistory.push: "${t}" is not a valid explicitDest parameter.`);
      return;
    }
    const i = e || JSON.stringify(t);
    if (!i)
      return;
    let n = !1;
    if (this._destination && (b0(this._destination.hash, i) || y0(this._destination.dest, t))) {
      if (this._destination.page)
        return;
      n = !0;
    }
    this._popStateInProgress && !n || (m(this, tt, ri).call(this, {
      dest: t,
      hash: i,
      page: s,
      rotation: this.linkService.rotation
    }, n), this._popStateInProgress || (this._popStateInProgress = !0, Promise.resolve().then(() => {
      this._popStateInProgress = !1;
    })));
  }
  pushPage(e) {
    var t;
    if (this._initialized) {
      if (!m(this, tt, Id).call(this, e)) {
        console.error(`PDFHistory.pushPage: "${e}" is not a valid page number.`);
        return;
      }
      ((t = this._destination) == null ? void 0 : t.page) !== e && (this._popStateInProgress || (m(this, tt, ri).call(this, {
        dest: null,
        hash: `page=${e}`,
        page: e,
        rotation: this.linkService.rotation
      }), this._popStateInProgress || (this._popStateInProgress = !0, Promise.resolve().then(() => {
        this._popStateInProgress = !1;
      }))));
    }
  }
  pushCurrentPosition() {
    !this._initialized || this._popStateInProgress || m(this, tt, Rd).call(this);
  }
  back() {
    if (!this._initialized || this._popStateInProgress)
      return;
    const e = window.history.state;
    m(this, tt, Tl).call(this, e) && e.uid > 0 && window.history.back();
  }
  forward() {
    if (!this._initialized || this._popStateInProgress)
      return;
    const e = window.history.state;
    m(this, tt, Tl).call(this, e) && e.uid < this._maxUid && window.history.forward();
  }
  get popStateInProgress() {
    return this._initialized && (this._popStateInProgress || this._blockHashChange > 0);
  }
  get initialBookmark() {
    return this._initialized ? this._initialBookmark : null;
  }
  get initialRotation() {
    return this._initialized ? this._initialRotation : null;
  }
}
Rn = new WeakMap(), tt = new WeakSet(), ri = function(e, t = !1) {
  const s = t || !this._destination, i = {
    fingerprint: this._fingerprint,
    uid: s ? this._uid : this._uid + 1,
    destination: e
  };
  m(this, tt, Ld).call(this, e, i.uid);
  let n;
  if (this._updateUrl && (e != null && e.hash)) {
    const r = document.location.href.split("#", 1)[0];
    r.startsWith("file://") || (n = `${r}#${e.hash}`);
  }
  s ? window.history.replaceState(i, "", n) : window.history.pushState(i, "", n);
}, Rd = function(e = !1) {
  if (!this._position)
    return;
  let t = this._position;
  if (e && (t = Object.assign(/* @__PURE__ */ Object.create(null), this._position), t.temporary = !0), !this._destination) {
    m(this, tt, ri).call(this, t);
    return;
  }
  if (this._destination.temporary) {
    m(this, tt, ri).call(this, t, !0);
    return;
  }
  if (this._destination.hash === t.hash || !this._destination.page && this._numPositionUpdates <= g0)
    return;
  let s = !1;
  if (this._destination.page >= t.first && this._destination.page <= t.page) {
    if (this._destination.dest !== void 0 || !this._destination.first)
      return;
    s = !0;
  }
  m(this, tt, ri).call(this, t, s);
}, Id = function(e) {
  return Number.isInteger(e) && e > 0 && e <= this.linkService.pagesCount;
}, Tl = function(e, t = !1) {
  if (!e)
    return !1;
  if (e.fingerprint !== this._fingerprint)
    if (t) {
      if (typeof e.fingerprint != "string" || e.fingerprint.length !== this._fingerprint.length)
        return !1;
      const [s] = performance.getEntriesByType("navigation");
      if ((s == null ? void 0 : s.type) !== "reload")
        return !1;
    } else
      return !1;
  return !(!Number.isInteger(e.uid) || e.uid < 0 || e.destination === null || typeof e.destination != "object");
}, Ld = function(e, t, s = !1) {
  this._updateViewareaTimeout && (clearTimeout(this._updateViewareaTimeout), this._updateViewareaTimeout = null), s && (e != null && e.temporary) && delete e.temporary, this._destination = e, this._uid = t, this._maxUid = Math.max(this._maxUid, t), this._numPositionUpdates = 0;
}, vp = function(e = !1) {
  const t = unescape(Fu()).substring(1), s = yu(t), i = s.get("nameddest") || "";
  let n = s.get("page") | 0;
  return (!m(this, tt, Id).call(this, n) || e && i.length > 0) && (n = null), {
    hash: t,
    page: n,
    rotation: this.linkService.rotation
  };
}, Db = function({
  location: e
}) {
  this._updateViewareaTimeout && (clearTimeout(this._updateViewareaTimeout), this._updateViewareaTimeout = null), this._position = {
    hash: e.pdfOpenParams.substring(1),
    page: this.linkService.page,
    first: e.pageNumber,
    rotation: e.rotation
  }, !this._popStateInProgress && (this._isPagesLoaded && this._destination && !this._destination.page && this._numPositionUpdates++, this._updateViewareaTimeout = setTimeout(() => {
    this._popStateInProgress || m(this, tt, Rd).call(this, !0), this._updateViewareaTimeout = null;
  }, m0));
}, kb = function({
  state: e
}) {
  const t = Fu(), s = this._currentHash !== t;
  if (this._currentHash = t, !e) {
    this._uid++;
    const {
      hash: n,
      page: r,
      rotation: a
    } = m(this, tt, vp).call(this);
    m(this, tt, ri).call(this, {
      hash: n,
      page: r,
      rotation: a
    }, !0);
    return;
  }
  if (!m(this, tt, Tl).call(this, e))
    return;
  this._popStateInProgress = !0, s && (this._blockHashChange++, Ew({
    target: window,
    name: "hashchange",
    delay: p0
  }).then(() => {
    this._blockHashChange--;
  }));
  const i = e.destination;
  m(this, tt, Ld).call(this, i, e.uid, !0), gb(i.rotation) && (this.linkService.rotation = i.rotation), i.dest ? this.linkService.goToDestination(i.dest) : i.hash ? this.linkService.setHash(i.hash) : i.page && (this.linkService.page = i.page), Promise.resolve().then(() => {
    this._popStateInProgress = !1;
  });
}, bp = function() {
  (!this._destination || this._destination.temporary) && m(this, tt, Rd).call(this);
}, Fb = function() {
  if (o(this, Rn))
    return;
  v(this, Rn, new AbortController());
  const {
    signal: e
  } = o(this, Rn);
  this.eventBus._on("updateviewarea", m(this, tt, Db).bind(this), {
    signal: e
  }), window.addEventListener("popstate", m(this, tt, kb).bind(this), {
    signal: e
  }), window.addEventListener("pagehide", m(this, tt, bp).bind(this), {
    signal: e
  });
}, jb = function() {
  var e;
  (e = o(this, Rn)) == null || e.abort(), v(this, Rn, null);
};
function b0(l, e) {
  return typeof l != "string" || typeof e != "string" ? !1 : l === e || yu(l).get("nameddest") === e;
}
function y0(l, e) {
  function t(s, i) {
    if (typeof s != typeof i || Array.isArray(s) || Array.isArray(i))
      return !1;
    if (s !== null && typeof s == "object" && i !== null) {
      if (Object.keys(s).length !== Object.keys(i).length)
        return !1;
      for (const n in s)
        if (!t(s[n], i[n]))
          return !1;
      return !0;
    }
    return s === i || Number.isNaN(s) && Number.isNaN(i);
  }
  if (!(Array.isArray(l) && Array.isArray(e)) || l.length !== e.length)
    return !1;
  for (let s = 0, i = l.length; s < i; s++)
    if (!t(l[s], e[s]))
      return !1;
  return !0;
}
var oc, lc, hc, cc, dc, Fo;
class A0 {
  constructor(e) {
    y(this, oc, null);
    y(this, lc, null);
    y(this, hc, null);
    y(this, cc, null);
    y(this, dc, null);
    y(this, Fo);
    this.pdfPage = e.pdfPage, this.accessibilityManager = e.accessibilityManager, this.l10n = e.l10n, this.l10n || (this.l10n = new Jo()), this.annotationEditorLayer = null, this.div = null, this._cancelled = !1, v(this, Fo, e.uiManager), v(this, oc, e.annotationLayer || null), v(this, dc, e.textLayer || null), v(this, lc, e.drawLayer || null), v(this, hc, e.onAppend || null), v(this, cc, e.structTreeLayer || null);
  }
  async render(e, t = "display") {
    var r;
    if (t !== "display" || this._cancelled)
      return;
    const s = e.clone({
      dontFlip: !0
    });
    if (this.div) {
      this.annotationEditorLayer.update({
        viewport: s
      }), this.show();
      return;
    }
    const i = this.div = document.createElement("div");
    i.className = "annotationEditorLayer", i.hidden = !0, i.dir = o(this, Fo).direction, (r = o(this, hc)) == null || r.call(this, i), this.annotationEditorLayer = new hw({
      uiManager: o(this, Fo),
      div: i,
      structTreeLayer: o(this, cc),
      accessibilityManager: this.accessibilityManager,
      pageIndex: this.pdfPage.pageNumber - 1,
      l10n: this.l10n,
      viewport: s,
      annotationLayer: o(this, oc),
      textLayer: o(this, dc),
      drawLayer: o(this, lc)
    });
    const n = {
      viewport: s,
      div: i,
      annotations: null,
      intent: t
    };
    this.annotationEditorLayer.render(n), this.show();
  }
  cancel() {
    this._cancelled = !0, this.div && this.annotationEditorLayer.destroy();
  }
  hide() {
    this.div && (this.div.hidden = !0);
  }
  show() {
    !this.div || this.annotationEditorLayer.isInvisible || (this.div.hidden = !1);
  }
}
oc = new WeakMap(), lc = new WeakMap(), hc = new WeakMap(), cc = new WeakMap(), dc = new WeakMap(), Fo = new WeakMap();
{
  var yp = /* @__PURE__ */ new Map();
  const l = navigator.userAgent || "", e = navigator.platform || "", t = navigator.maxTouchPoints || 1, s = /Android/.test(l), i = /\b(iPad|iPhone|iPod)(?=;)/.test(l) || e === "MacIntel" && t > 1;
  (function() {
    (i || s) && yp.set("maxCanvasPixels", 5242880);
  })(), function() {
    s && yp.set("useSystemFonts", !1);
  }();
}
const O = {
  BROWSER: 1,
  VIEWER: 2,
  API: 4,
  WORKER: 8,
  EVENT_DISPATCH: 16,
  PREFERENCE: 128
}, Ap = {
  BOOLEAN: 1,
  NUMBER: 2,
  OBJECT: 4,
  STRING: 8,
  UNDEFINED: 16
}, Js = {
  allowedGlobalEvents: {
    value: null,
    kind: O.BROWSER
  },
  canvasMaxAreaInBytes: {
    value: -1,
    kind: O.BROWSER + O.API
  },
  isInAutomation: {
    value: !1,
    kind: O.BROWSER
  },
  localeProperties: {
    value: {
      lang: navigator.language || "en-US"
    },
    kind: O.BROWSER
  },
  nimbusDataStr: {
    value: "",
    kind: O.BROWSER
  },
  supportsCaretBrowsingMode: {
    value: !1,
    kind: O.BROWSER
  },
  supportsDocumentFonts: {
    value: !0,
    kind: O.BROWSER
  },
  supportsIntegratedFind: {
    value: !1,
    kind: O.BROWSER
  },
  supportsMouseWheelZoomCtrlKey: {
    value: !0,
    kind: O.BROWSER
  },
  supportsMouseWheelZoomMetaKey: {
    value: !0,
    kind: O.BROWSER
  },
  supportsPinchToZoom: {
    value: !0,
    kind: O.BROWSER
  },
  toolbarDensity: {
    value: 0,
    kind: O.BROWSER + O.EVENT_DISPATCH
  },
  altTextLearnMoreUrl: {
    value: "",
    kind: O.VIEWER + O.PREFERENCE
  },
  annotationEditorMode: {
    value: 0,
    kind: O.VIEWER + O.PREFERENCE
  },
  annotationMode: {
    value: 2,
    kind: O.VIEWER + O.PREFERENCE
  },
  cursorToolOnLoad: {
    value: 0,
    kind: O.VIEWER + O.PREFERENCE
  },
  debuggerSrc: {
    value: "./debugger.mjs",
    kind: O.VIEWER
  },
  defaultZoomDelay: {
    value: 400,
    kind: O.VIEWER + O.PREFERENCE
  },
  defaultZoomValue: {
    value: "",
    kind: O.VIEWER + O.PREFERENCE
  },
  disableHistory: {
    value: !1,
    kind: O.VIEWER
  },
  disablePageLabels: {
    value: !1,
    kind: O.VIEWER + O.PREFERENCE
  },
  enableAltText: {
    value: !1,
    kind: O.VIEWER + O.PREFERENCE
  },
  enableAltTextModelDownload: {
    value: !0,
    kind: O.VIEWER + O.PREFERENCE + O.EVENT_DISPATCH
  },
  enableGuessAltText: {
    value: !0,
    kind: O.VIEWER + O.PREFERENCE + O.EVENT_DISPATCH
  },
  enableHighlightFloatingButton: {
    value: !1,
    kind: O.VIEWER + O.PREFERENCE
  },
  enableNewAltTextWhenAddingImage: {
    value: !0,
    kind: O.VIEWER + O.PREFERENCE
  },
  enablePermissions: {
    value: !1,
    kind: O.VIEWER + O.PREFERENCE
  },
  enablePrintAutoRotate: {
    value: !0,
    kind: O.VIEWER + O.PREFERENCE
  },
  enableScripting: {
    value: !0,
    kind: O.VIEWER + O.PREFERENCE
  },
  enableUpdatedAddImage: {
    value: !1,
    kind: O.VIEWER + O.PREFERENCE
  },
  externalLinkRel: {
    value: "noopener noreferrer nofollow",
    kind: O.VIEWER
  },
  externalLinkTarget: {
    value: 0,
    kind: O.VIEWER + O.PREFERENCE
  },
  highlightEditorColors: {
    value: "yellow=#FFFF98,green=#53FFBC,blue=#80EBFF,pink=#FFCBE6,red=#FF4F5F",
    kind: O.VIEWER + O.PREFERENCE
  },
  historyUpdateUrl: {
    value: !1,
    kind: O.VIEWER + O.PREFERENCE
  },
  ignoreDestinationZoom: {
    value: !1,
    kind: O.VIEWER + O.PREFERENCE
  },
  imageResourcesPath: {
    value: "./images/",
    kind: O.VIEWER
  },
  maxCanvasPixels: {
    value: 2 ** 25,
    kind: O.VIEWER
  },
  forcePageColors: {
    value: !1,
    kind: O.VIEWER + O.PREFERENCE
  },
  pageColorsBackground: {
    value: "Canvas",
    kind: O.VIEWER + O.PREFERENCE
  },
  pageColorsForeground: {
    value: "CanvasText",
    kind: O.VIEWER + O.PREFERENCE
  },
  pdfBugEnabled: {
    value: !1,
    kind: O.VIEWER + O.PREFERENCE
  },
  printResolution: {
    value: 150,
    kind: O.VIEWER
  },
  sidebarViewOnLoad: {
    value: -1,
    kind: O.VIEWER + O.PREFERENCE
  },
  scrollModeOnLoad: {
    value: -1,
    kind: O.VIEWER + O.PREFERENCE
  },
  spreadModeOnLoad: {
    value: -1,
    kind: O.VIEWER + O.PREFERENCE
  },
  textLayerMode: {
    value: 1,
    kind: O.VIEWER + O.PREFERENCE
  },
  viewOnLoad: {
    value: 0,
    kind: O.VIEWER + O.PREFERENCE
  },
  cMapPacked: {
    value: !0,
    kind: O.API
  },
  cMapUrl: {
    value: "../web/cmaps/",
    kind: O.API
  },
  disableAutoFetch: {
    value: !1,
    kind: O.API + O.PREFERENCE
  },
  disableFontFace: {
    value: !1,
    kind: O.API + O.PREFERENCE
  },
  disableRange: {
    value: !1,
    kind: O.API + O.PREFERENCE
  },
  disableStream: {
    value: !1,
    kind: O.API + O.PREFERENCE
  },
  docBaseUrl: {
    value: "",
    kind: O.API
  },
  enableHWA: {
    value: !0,
    kind: O.API + O.VIEWER + O.PREFERENCE
  },
  enableXfa: {
    value: !0,
    kind: O.API + O.PREFERENCE
  },
  fontExtraProperties: {
    value: !1,
    kind: O.API
  },
  isEvalSupported: {
    value: !0,
    kind: O.API
  },
  isOffscreenCanvasSupported: {
    value: !0,
    kind: O.API
  },
  maxImageSize: {
    value: -1,
    kind: O.API
  },
  pdfBug: {
    value: !1,
    kind: O.API
  },
  standardFontDataUrl: {
    value: "../web/standard_fonts/",
    kind: O.API
  },
  useSystemFonts: {
    value: void 0,
    kind: O.API,
    type: Ap.BOOLEAN + Ap.UNDEFINED
  },
  verbosity: {
    value: 1,
    kind: O.API
  },
  workerPort: {
    value: null,
    kind: O.WORKER
  },
  workerSrc: {
    value: "../build/pdf.worker.mjs",
    kind: O.WORKER
  }
};
Js.defaultUrl = {
  value: "compressed.tracemonkey-pldi-09.pdf",
  kind: O.VIEWER
}, Js.sandboxBundleSrc = {
  value: "../build/pdf.sandbox.mjs",
  kind: O.VIEWER
}, Js.viewerCssTheme = {
  value: 0,
  kind: O.VIEWER + O.PREFERENCE
}, Js.enableFakeMLManager = {
  value: !0,
  kind: O.VIEWER
};
Js.disablePreferences = {
  value: !1,
  kind: O.VIEWER
};
var In;
const Ps = class Ps {
  static get(e) {
    return o(this, In).get(e);
  }
  static getAll(e = null, t = !1) {
    const s = /* @__PURE__ */ Object.create(null);
    for (const i in Js) {
      const n = Js[i];
      e && !(e & n.kind) || (s[i] = t ? n.value : o(this, In).get(i));
    }
    return s;
  }
  static set(e, t) {
    this.setAll({
      [e]: t
    });
  }
  static setAll(e, t = !1) {
    this._hasInvokedSet || (this._hasInvokedSet = !0);
    let s;
    for (const i in e) {
      const n = Js[i], r = e[i];
      if (!n || !(typeof r == typeof n.value || Ap[(typeof r).toUpperCase()] & n.type))
        continue;
      const {
        kind: a
      } = n;
      t && !(a & O.BROWSER || a & O.PREFERENCE) || (this.eventBus && a & O.EVENT_DISPATCH && (s || (s = /* @__PURE__ */ new Map())).set(i, r), o(this, In).set(i, r));
    }
    if (s)
      for (const [i, n] of s)
        this.eventBus.dispatch(i.toLowerCase(), {
          source: this,
          value: n
        });
  }
};
In = new WeakMap(), Z(Ps, "eventBus"), y(Ps, In, /* @__PURE__ */ new Map()), (() => {
  for (const e in Js)
    o(Ps, In).set(e, Js[e].value);
  for (const [e, t] of yp)
    o(Ps, In).set(e, t);
  Ps._hasInvokedSet = !1, Ps._checkDisablePreferences = () => Ps.get("disablePreferences") ? !0 : (Ps._hasInvokedSet && console.warn('The Preferences may override manually set AppOptions; please use the "disablePreferences"-option to prevent that.'), !1);
})();
let Ep = Ps;
var Gs;
class E0 {
  constructor(e) {
    y(this, Gs, null);
    this.pageIndex = e.pageIndex;
  }
  async render(e = "display") {
    e !== "display" || o(this, Gs) || this._cancelled || v(this, Gs, new fw({
      pageIndex: this.pageIndex
    }));
  }
  cancel() {
    this._cancelled = !0, o(this, Gs) && (o(this, Gs).destroy(), v(this, Gs, null));
  }
  setParent(e) {
    var t;
    (t = o(this, Gs)) == null || t.setParent(e);
  }
  getDrawLayer() {
    return o(this, Gs);
  }
}
Gs = new WeakMap();
const rm = {
  Document: null,
  DocumentFragment: null,
  Part: "group",
  Sect: "group",
  Div: "group",
  Aside: "note",
  NonStruct: "none",
  P: null,
  H: "heading",
  Title: null,
  FENote: "note",
  Sub: "group",
  Lbl: null,
  Span: null,
  Em: null,
  Strong: null,
  Link: "link",
  Annot: "note",
  Form: "form",
  Ruby: null,
  RB: null,
  RT: null,
  RP: null,
  Warichu: null,
  WT: null,
  WP: null,
  L: "list",
  LI: "listitem",
  LBody: null,
  Table: "table",
  TR: "row",
  TH: "columnheader",
  TD: "cell",
  THead: "columnheader",
  TBody: null,
  TFoot: null,
  Caption: null,
  Figure: "figure",
  Formula: null,
  Artifact: null
}, w0 = /^H(\d+)$/;
var jo, ws, Bo, Ho, $o, Ln, ei, wp, Hb, xp;
class Bb {
  constructor(e, t) {
    y(this, ei);
    y(this, jo);
    y(this, ws, null);
    y(this, Bo);
    y(this, Ho, /* @__PURE__ */ new Map());
    y(this, $o);
    y(this, Ln, null);
    v(this, jo, e.getStructTree()), v(this, $o, t);
  }
  async render() {
    var i;
    if (o(this, Bo))
      return o(this, Bo);
    const {
      promise: e,
      resolve: t,
      reject: s
    } = Promise.withResolvers();
    v(this, Bo, e);
    try {
      v(this, ws, m(this, ei, xp).call(this, await o(this, jo)));
    } catch (n) {
      s(n);
    }
    return v(this, jo, null), (i = o(this, ws)) == null || i.classList.add("structTree"), t(o(this, ws)), e;
  }
  async getAriaAttributes(e) {
    return await this.render(), o(this, Ho).get(e);
  }
  hide() {
    o(this, ws) && !o(this, ws).hidden && (o(this, ws).hidden = !0);
  }
  show() {
    var e;
    (e = o(this, ws)) != null && e.hidden && (o(this, ws).hidden = !1);
  }
  addElementsToTextLayer() {
    var e;
    if (o(this, Ln)) {
      for (const [t, s] of o(this, Ln))
        (e = document.getElementById(t)) == null || e.append(s);
      o(this, Ln).clear(), v(this, Ln, null);
    }
  }
}
jo = new WeakMap(), ws = new WeakMap(), Bo = new WeakMap(), Ho = new WeakMap(), $o = new WeakMap(), Ln = new WeakMap(), ei = new WeakSet(), wp = function(e, t) {
  const {
    alt: s,
    id: i,
    lang: n
  } = e;
  if (s !== void 0) {
    let r = !1;
    const a = _l(s);
    for (const h of e.children)
      if (h.type === "annotation") {
        let c = o(this, Ho).get(h.id);
        c || (c = /* @__PURE__ */ new Map(), o(this, Ho).set(h.id, c)), c.set("aria-label", a), r = !0;
      }
    r || t.setAttribute("aria-label", a);
  }
  i !== void 0 && t.setAttribute("aria-owns", i), n !== void 0 && t.setAttribute("lang", _l(n, !0));
}, Hb = function(e, t) {
  const {
    alt: s,
    bbox: i,
    children: n
  } = e, r = n == null ? void 0 : n[0];
  if (!o(this, $o) || !s || !i || (r == null ? void 0 : r.type) !== "content")
    return !1;
  const {
    id: a
  } = r;
  if (!a)
    return !1;
  t.setAttribute("aria-owns", a);
  const h = document.createElement("span");
  (o(this, Ln) || v(this, Ln, /* @__PURE__ */ new Map())).set(a, h), h.setAttribute("role", "img"), h.setAttribute("aria-label", _l(s));
  const {
    pageHeight: c,
    pageX: d,
    pageY: u
  } = o(this, $o), f = "calc(var(--scale-factor)*", {
    style: p
  } = h;
  return p.width = `${f}${i[2] - i[0]}px)`, p.height = `${f}${i[3] - i[1]}px)`, p.left = `${f}${i[0] - d}px)`, p.top = `${f}${c - i[3] + u}px)`, !0;
}, xp = function(e) {
  if (!e)
    return null;
  const t = document.createElement("span");
  if ("role" in e) {
    const {
      role: s
    } = e, i = s.match(w0);
    if (i ? (t.setAttribute("role", "heading"), t.setAttribute("aria-level", i[1])) : rm[s] && t.setAttribute("role", rm[s]), s === "Figure" && m(this, ei, Hb).call(this, e, t))
      return t;
  }
  if (m(this, ei, wp).call(this, e, t), e.children)
    if (e.children.length === 1 && "id" in e.children[0])
      m(this, ei, wp).call(this, e.children[0], t);
    else
      for (const s of e.children)
        t.append(m(this, ei, xp).call(this, s));
  return t;
};
var _i, is, Oi, Mn, Vo, Md, uc, Tp;
const Ma = class Ma {
  constructor() {
    y(this, uc);
    y(this, _i, !1);
    y(this, is, null);
    y(this, Oi, /* @__PURE__ */ new Map());
    y(this, Mn, /* @__PURE__ */ new Map());
  }
  setTextMapping(e) {
    v(this, is, e);
  }
  enable() {
    if (o(this, _i))
      throw new Error("TextAccessibilityManager is already enabled.");
    if (!o(this, is))
      throw new Error("Text divs and strings have not been set.");
    if (v(this, _i, !0), v(this, is, o(this, is).slice()), o(this, is).sort(m(Ma, Vo, Md)), o(this, Oi).size > 0) {
      const e = o(this, is);
      for (const [t, s] of o(this, Oi)) {
        if (!document.getElementById(t)) {
          o(this, Oi).delete(t);
          continue;
        }
        m(this, uc, Tp).call(this, t, e[s]);
      }
    }
    for (const [e, t] of o(this, Mn))
      this.addPointerInTextLayer(e, t);
    o(this, Mn).clear();
  }
  disable() {
    o(this, _i) && (o(this, Mn).clear(), v(this, is, null), v(this, _i, !1));
  }
  removePointerInTextLayer(e) {
    if (!o(this, _i)) {
      o(this, Mn).delete(e);
      return;
    }
    const t = o(this, is);
    if (!t || t.length === 0)
      return;
    const {
      id: s
    } = e, i = o(this, Oi).get(s);
    if (i === void 0)
      return;
    const n = t[i];
    o(this, Oi).delete(s);
    let r = n.getAttribute("aria-owns");
    r != null && r.includes(s) && (r = r.split(" ").filter((a) => a !== s).join(" "), r ? n.setAttribute("aria-owns", r) : (n.removeAttribute("aria-owns"), n.setAttribute("role", "presentation")));
  }
  addPointerInTextLayer(e, t) {
    const {
      id: s
    } = e;
    if (!s)
      return null;
    if (!o(this, _i))
      return o(this, Mn).set(e, t), null;
    t && this.removePointerInTextLayer(e);
    const i = o(this, is);
    if (!i || i.length === 0)
      return null;
    const n = Bl(i, (c) => {
      var d;
      return m(d = Ma, Vo, Md).call(d, e, c) < 0;
    }), r = Math.max(0, n - 1), a = i[r];
    m(this, uc, Tp).call(this, s, a), o(this, Oi).set(s, r);
    const h = a.parentNode;
    return h != null && h.classList.contains("markedContent") ? h.id : null;
  }
  moveElementInDOM(e, t, s, i) {
    const n = this.addPointerInTextLayer(s, i);
    if (!e.hasChildNodes())
      return e.append(t), n;
    const r = Array.from(e.childNodes).filter((c) => c !== t);
    if (r.length === 0)
      return n;
    const a = s || t, h = Bl(r, (c) => {
      var d;
      return m(d = Ma, Vo, Md).call(d, a, c) < 0;
    });
    return h === 0 ? r[0].before(t) : r[h - 1].after(t), n;
  }
};
_i = new WeakMap(), is = new WeakMap(), Oi = new WeakMap(), Mn = new WeakMap(), Vo = new WeakSet(), Md = function(e, t) {
  const s = e.getBoundingClientRect(), i = t.getBoundingClientRect();
  if (s.width === 0 && s.height === 0)
    return 1;
  if (i.width === 0 && i.height === 0)
    return -1;
  const n = s.y, r = s.y + s.height, a = s.y + s.height / 2, h = i.y, c = i.y + i.height, d = i.y + i.height / 2;
  if (a <= h && d >= r)
    return -1;
  if (d <= n && a >= c)
    return 1;
  const u = s.x + s.width / 2, f = i.x + i.width / 2;
  return u - f;
}, uc = new WeakSet(), Tp = function(e, t) {
  const s = t.getAttribute("aria-owns");
  s != null && s.includes(e) || t.setAttribute("aria-owns", s ? `${s} ${e}` : e), t.removeAttribute("role");
}, y(Ma, Vo);
let Sp = Ma;
var _n;
class x0 {
  constructor({
    findController: e,
    eventBus: t,
    pageIndex: s
  }) {
    y(this, _n, null);
    this.findController = e, this.matches = [], this.eventBus = t, this.pageIdx = s, this.textDivs = null, this.textContentItemsStr = null, this.enabled = !1;
  }
  setTextMapping(e, t) {
    this.textDivs = e, this.textContentItemsStr = t;
  }
  enable() {
    if (!this.textDivs || !this.textContentItemsStr)
      throw new Error("Text divs and strings have not been set.");
    if (this.enabled)
      throw new Error("TextHighlighter is already enabled.");
    this.enabled = !0, o(this, _n) || (v(this, _n, new AbortController()), this.eventBus._on("updatetextlayermatches", (e) => {
      (e.pageIndex === this.pageIdx || e.pageIndex === -1) && this._updateMatches();
    }, {
      signal: o(this, _n).signal
    })), this._updateMatches();
  }
  disable() {
    var e;
    this.enabled && (this.enabled = !1, (e = o(this, _n)) == null || e.abort(), v(this, _n, null), this._updateMatches(!0));
  }
  _convertMatches(e, t) {
    if (!e)
      return [];
    const {
      textContentItemsStr: s
    } = this;
    let i = 0, n = 0;
    const r = s.length - 1, a = [];
    for (let h = 0, c = e.length; h < c; h++) {
      let d = e[h];
      for (; i !== r && d >= n + s[i].length; )
        n += s[i].length, i++;
      i === s.length && console.error("Could not find a matching mapping");
      const u = {
        begin: {
          divIdx: i,
          offset: d - n
        }
      };
      for (d += t[h]; i !== r && d > n + s[i].length; )
        n += s[i].length, i++;
      u.end = {
        divIdx: i,
        offset: d - n
      }, a.push(u);
    }
    return a;
  }
  _renderMatches(e) {
    if (e.length === 0)
      return;
    const {
      findController: t,
      pageIdx: s
    } = this, {
      textContentItemsStr: i,
      textDivs: n
    } = this, r = s === t.selected.pageIdx, a = t.selected.matchIdx, h = t.state.highlightAll;
    let c = null;
    const d = {
      divIdx: -1,
      offset: void 0
    };
    function u(A, w) {
      const x = A.divIdx;
      return n[x].textContent = "", f(x, 0, A.offset, w);
    }
    function f(A, w, x, P) {
      let T = n[A];
      if (T.nodeType === Node.TEXT_NODE) {
        const M = document.createElement("span");
        T.before(M), M.append(T), n[A] = M, T = M;
      }
      const C = i[A].substring(w, x), R = document.createTextNode(C);
      if (P) {
        const M = document.createElement("span");
        return M.className = `${P} appended`, M.append(R), T.append(M), P.includes("selected") ? M.offsetLeft : 0;
      }
      return T.append(R), 0;
    }
    let p = a, g = p + 1;
    if (h)
      p = 0, g = e.length;
    else if (!r)
      return;
    let b = -1, E = -1;
    for (let A = p; A < g; A++) {
      const w = e[A], x = w.begin;
      if (x.divIdx === b && x.offset === E)
        continue;
      b = x.divIdx, E = x.offset;
      const P = w.end, T = r && A === a, C = T ? " selected" : "";
      let R = 0;
      if (!c || x.divIdx !== c.divIdx ? (c !== null && f(c.divIdx, c.offset, d.offset), u(x)) : f(c.divIdx, c.offset, x.offset), x.divIdx === P.divIdx)
        R = f(x.divIdx, x.offset, P.offset, "highlight" + C);
      else {
        R = f(x.divIdx, x.offset, d.offset, "highlight begin" + C);
        for (let M = x.divIdx + 1, S = P.divIdx; M < S; M++)
          n[M].className = "highlight middle" + C;
        u(P, "highlight end" + C);
      }
      c = P, T && t.scrollMatchIntoView({
        element: n[x.divIdx],
        selectedLeft: R,
        pageIndex: s,
        matchIndex: a
      });
    }
    c && f(c.divIdx, c.offset, d.offset);
  }
  _updateMatches(e = !1) {
    if (!this.enabled && !e)
      return;
    const {
      findController: t,
      matches: s,
      pageIdx: i
    } = this, {
      textContentItemsStr: n,
      textDivs: r
    } = this;
    let a = -1;
    for (const d of s) {
      const u = Math.max(a, d.begin.divIdx);
      for (let f = u, p = d.end.divIdx; f <= p; f++) {
        const g = r[f];
        g.textContent = n[f], g.className = "";
      }
      a = d.end.divIdx + 1;
    }
    if (!(t != null && t.highlightMatches) || e)
      return;
    const h = t.pageMatches[i] || null, c = t.pageMatchesLength[i] || null;
    this.matches = this._convertMatches(h, c), this._renderMatches(this.matches);
  }
}
_n = new WeakMap();
var fc, pc, ta, Xs, _e, On, cu, $b, tl, Vb, Ub;
const Qi = class Qi {
  constructor({
    pdfPage: e,
    highlighter: t = null,
    accessibilityManager: s = null,
    enablePermissions: i = !1,
    onAppend: n = null
  }) {
    y(this, cu);
    y(this, fc, !1);
    y(this, pc, null);
    y(this, ta, !1);
    y(this, Xs, null);
    this.pdfPage = e, this.highlighter = t, this.accessibilityManager = s, v(this, fc, i === !0), v(this, pc, n), this.div = document.createElement("div"), this.div.tabIndex = 0, this.div.className = "textLayer";
  }
  async render(e, t = null) {
    var r, a, h, c, d;
    if (o(this, ta) && o(this, Xs)) {
      o(this, Xs).update({
        viewport: e,
        onBefore: this.hide.bind(this)
      }), this.show();
      return;
    }
    this.cancel(), v(this, Xs, new yw({
      textContentSource: this.pdfPage.streamTextContent(t || {
        includeMarkedContent: !0,
        disableNormalization: !0
      }),
      container: this.div,
      viewport: e
    }));
    const {
      textDivs: s,
      textContentItemsStr: i
    } = o(this, Xs);
    (r = this.highlighter) == null || r.setTextMapping(s, i), (a = this.accessibilityManager) == null || a.setTextMapping(s), await o(this, Xs).render(), v(this, ta, !0);
    const n = document.createElement("div");
    n.className = "endOfContent", this.div.append(n), m(this, cu, $b).call(this, n), (h = o(this, pc)) == null || h.call(this, this.div), (c = this.highlighter) == null || c.enable(), (d = this.accessibilityManager) == null || d.enable();
  }
  hide() {
    var e;
    !this.div.hidden && o(this, ta) && ((e = this.highlighter) == null || e.disable(), this.div.hidden = !0);
  }
  show() {
    var e;
    this.div.hidden && o(this, ta) && (this.div.hidden = !1, (e = this.highlighter) == null || e.enable());
  }
  cancel() {
    var e, t, s, i;
    (e = o(this, Xs)) == null || e.cancel(), v(this, Xs, null), (t = this.highlighter) == null || t.disable(), (s = this.accessibilityManager) == null || s.disable(), m(i = Qi, tl, Vb).call(i, this.div);
  }
};
fc = new WeakMap(), pc = new WeakMap(), ta = new WeakMap(), Xs = new WeakMap(), _e = new WeakMap(), On = new WeakMap(), cu = new WeakSet(), $b = function(e) {
  var s;
  const {
    div: t
  } = this;
  t.addEventListener("mousedown", () => {
    t.classList.add("selecting");
  }), t.addEventListener("copy", (i) => {
    if (!o(this, fc)) {
      const n = document.getSelection();
      i.clipboardData.setData("text/plain", _l(mw(n.toString())));
    }
    i.preventDefault(), i.stopPropagation();
  }), o(Qi, _e).set(t, e), m(s = Qi, tl, Ub).call(s);
}, tl = new WeakSet(), Vb = function(e) {
  var t;
  o(this, _e).delete(e), o(this, _e).size === 0 && ((t = o(this, On)) == null || t.abort(), v(this, On, null));
}, Ub = function() {
  if (o(this, On))
    return;
  v(this, On, new AbortController());
  const {
    signal: e
  } = o(this, On), t = (r, a) => {
    a.append(r), r.style.width = "", r.style.height = "", a.classList.remove("selecting");
  };
  let s = !1;
  document.addEventListener("pointerdown", () => {
    s = !0;
  }, {
    signal: e
  }), document.addEventListener("pointerup", () => {
    s = !1, o(this, _e).forEach(t);
  }, {
    signal: e
  }), window.addEventListener("blur", () => {
    s = !1, o(this, _e).forEach(t);
  }, {
    signal: e
  }), document.addEventListener("keyup", () => {
    s || o(this, _e).forEach(t);
  }, {
    signal: e
  });
  var i, n;
  document.addEventListener("selectionchange", () => {
    const r = document.getSelection();
    if (r.rangeCount === 0) {
      o(this, _e).forEach(t);
      return;
    }
    const a = /* @__PURE__ */ new Set();
    for (let p = 0; p < r.rangeCount; p++) {
      const g = r.getRangeAt(p);
      for (const b of o(this, _e).keys())
        !a.has(b) && g.intersectsNode(b) && a.add(b);
    }
    for (const [p, g] of o(this, _e))
      a.has(p) ? p.classList.add("selecting") : t(g, p);
    if (i ?? (i = getComputedStyle(o(this, _e).values().next().value).getPropertyValue("-moz-user-select") === "none"), i)
      return;
    const h = r.getRangeAt(0), c = n && (h.compareBoundaryPoints(Range.END_TO_END, n) === 0 || h.compareBoundaryPoints(Range.START_TO_END, n) === 0);
    let d = c ? h.startContainer : h.endContainer;
    d.nodeType === Node.TEXT_NODE && (d = d.parentNode);
    const u = d.parentElement.closest(".textLayer"), f = o(this, _e).get(u);
    f && (f.style.width = u.style.width, f.style.height = u.style.height, d.parentElement.insertBefore(f, c ? d : d.nextSibling)), n = h.cloneRange();
  }, {
    signal: e
  });
}, y(Qi, tl), y(Qi, _e, /* @__PURE__ */ new Map()), y(Qi, On, null);
let zd = Qi;
class zb {
  constructor({
    pdfPage: e,
    annotationStorage: t = null,
    linkService: s,
    xfaHtml: i = null
  }) {
    this.pdfPage = e, this.annotationStorage = t, this.linkService = s, this.xfaHtml = i, this.div = null, this._cancelled = !1;
  }
  async render(e, t = "display") {
    if (t === "print") {
      const n = {
        viewport: e.clone({
          dontFlip: !0
        }),
        div: this.div,
        xfaHtml: this.xfaHtml,
        annotationStorage: this.annotationStorage,
        linkService: this.linkService,
        intent: t
      };
      return this.div = document.createElement("div"), n.div = this.div, Nu.render(n);
    }
    const s = await this.pdfPage.getXfa();
    if (this._cancelled || !s)
      return {
        textDivs: []
      };
    const i = {
      viewport: e.clone({
        dontFlip: !0
      }),
      div: this.div,
      xfaHtml: s,
      annotationStorage: this.annotationStorage,
      linkService: this.linkService,
      intent: t
    };
    return this.div ? Nu.update(i) : (this.div = document.createElement("div"), i.div = this.div, Nu.render(i));
  }
  cancel() {
    this._cancelled = !0;
  }
  hide() {
    this.div && (this.div.hidden = !0);
  }
}
const S0 = {
  annotationEditorUIManager: null,
  annotationStorage: null,
  downloadManager: null,
  enableScripting: !1,
  fieldObjectsPromise: null,
  findController: null,
  hasJSActionsPromise: null,
  get linkService() {
    return new Zp();
  }
}, T0 = /* @__PURE__ */ new Map([["canvasWrapper", 0], ["textLayer", 1], ["annotationLayer", 2], ["annotationEditorLayer", 3], ["xfaLayer", 3]]);
var ea, gc, sa, mc, Nn, Dn, vc, bc, yc, ia, Uo, zo, Ni, na, kn, at, La, _d, Pl, Pp, Cp, Rp, Ip, Lp, Gb, Xb, Mp;
class Wb {
  constructor(e) {
    y(this, at);
    y(this, ea, Fi.ENABLE_FORMS);
    y(this, gc, !1);
    y(this, sa, !1);
    y(this, mc, !1);
    y(this, Nn, null);
    y(this, Dn, null);
    y(this, vc, null);
    y(this, bc, 1);
    y(this, yc, 1);
    y(this, ia, null);
    y(this, Uo, Nt.INITIAL);
    y(this, zo, Qs.ENABLE);
    y(this, Ni, {
      directDrawing: !0,
      initialOptionalContent: !0,
      regularAnnotations: !0
    });
    y(this, na, /* @__PURE__ */ new WeakMap());
    y(this, kn, [null, null, null, null]);
    var n, r;
    const t = e.container, s = e.defaultViewport;
    this.id = e.id, this.renderingId = "page" + this.id, v(this, Nn, e.layerProperties || S0), this.pdfPage = null, this.pageLabel = null, this.rotation = 0, this.scale = e.scale || fb, this.viewport = s, this.pdfPageRotate = s.rotation, this._optionalContentConfigPromise = e.optionalContentConfigPromise || null, v(this, zo, e.textLayerMode ?? Qs.ENABLE), v(this, ea, e.annotationMode ?? Fi.ENABLE_FORMS), this.imageResourcesPath = e.imageResourcesPath || "", this.maxCanvasPixels = e.maxCanvasPixels ?? Ep.get("maxCanvasPixels"), this.pageColors = e.pageColors || null, v(this, gc, e.enableHWA || !1), this.eventBus = e.eventBus, this.renderingQueue = e.renderingQueue, this.l10n = e.l10n, this.l10n || (this.l10n = new Jo()), this.renderTask = null, this.resume = null, this._isStandalone = !((n = this.renderingQueue) != null && n.hasViewer()), this._container = t, this._annotationCanvasMap = null, this.annotationLayer = null, this.annotationEditorLayer = null, this.textLayer = null, this.zoomLayer = null, this.xfaLayer = null, this.structTreeLayer = null, this.drawLayer = null;
    const i = document.createElement("div");
    if (i.className = "page", i.setAttribute("data-page-number", this.id), i.setAttribute("role", "region"), i.setAttribute("data-l10n-id", "pdfjs-page-landmark"), i.setAttribute("data-l10n-args", JSON.stringify({
      page: this.id
    })), this.div = i, m(this, at, _d).call(this), t == null || t.append(i), this._isStandalone) {
      t == null || t.style.setProperty("--scale-factor", this.scale * li.PDF_TO_CSS_UNITS), (r = this.pageColors) != null && r.background && (t == null || t.style.setProperty("--page-bg-color", this.pageColors.background));
      const {
        optionalContentConfigPromise: a
      } = e;
      a && a.then((h) => {
        a === this._optionalContentConfigPromise && (o(this, Ni).initialOptionalContent = h.hasInitialVisibility);
      }), e.l10n || this.l10n.translate(this.div);
    }
  }
  get renderingState() {
    return o(this, Uo);
  }
  set renderingState(e) {
    if (e !== o(this, Uo))
      switch (v(this, Uo, e), o(this, Dn) && (clearTimeout(o(this, Dn)), v(this, Dn, null)), e) {
        case Nt.PAUSED:
          this.div.classList.remove("loading");
          break;
        case Nt.RUNNING:
          this.div.classList.add("loadingIcon"), v(this, Dn, setTimeout(() => {
            this.div.classList.add("loading"), v(this, Dn, null);
          }, 0));
          break;
        case Nt.INITIAL:
        case Nt.FINISHED:
          this.div.classList.remove("loadingIcon", "loading");
          break;
      }
  }
  setPdfPage(e) {
    var s, i, n, r;
    this._isStandalone && (((s = this.pageColors) == null ? void 0 : s.foreground) === "CanvasText" || ((i = this.pageColors) == null ? void 0 : i.background) === "Canvas") && ((n = this._container) == null || n.style.setProperty("--hcm-highlight-filter", e.filterFactory.addHighlightHCMFilter("highlight", "CanvasText", "Canvas", "HighlightText", "Highlight")), (r = this._container) == null || r.style.setProperty("--hcm-highlight-selected-filter", e.filterFactory.addHighlightHCMFilter("highlight_selected", "CanvasText", "Canvas", "HighlightText", "Highlight"))), this.pdfPage = e, this.pdfPageRotate = e.rotate;
    const t = (this.rotation + this.pdfPageRotate) % 360;
    this.viewport = e.getViewport({
      scale: this.scale * li.PDF_TO_CSS_UNITS,
      rotation: t
    }), m(this, at, _d).call(this), this.reset();
  }
  destroy() {
    var e;
    this.reset(), (e = this.pdfPage) == null || e.cleanup();
  }
  hasEditableAnnotations() {
    var e;
    return !!((e = this.annotationLayer) != null && e.hasEditableAnnotations());
  }
  get _textHighlighter() {
    return Vd(this, "_textHighlighter", new x0({
      pageIndex: this.id - 1,
      eventBus: this.eventBus,
      findController: o(this, Nn).findController
    }));
  }
  _resetZoomLayer(e = !1) {
    if (!this.zoomLayer)
      return;
    const t = this.zoomLayer.firstChild;
    o(this, na).delete(t), t.width = 0, t.height = 0, e && this.zoomLayer.remove(), this.zoomLayer = null;
  }
  reset({
    keepZoomLayer: e = !1,
    keepAnnotationLayer: t = !1,
    keepAnnotationEditorLayer: s = !1,
    keepXfaLayer: i = !1,
    keepTextLayer: n = !1
  } = {}) {
    var p, g, b, E, A;
    this.cancelRendering({
      keepAnnotationLayer: t,
      keepAnnotationEditorLayer: s,
      keepXfaLayer: i,
      keepTextLayer: n
    }), this.renderingState = Nt.INITIAL;
    const r = this.div, a = r.childNodes, h = e && this.zoomLayer || null, c = t && ((p = this.annotationLayer) == null ? void 0 : p.div) || null, d = s && ((g = this.annotationEditorLayer) == null ? void 0 : g.div) || null, u = i && ((b = this.xfaLayer) == null ? void 0 : b.div) || null, f = n && ((E = this.textLayer) == null ? void 0 : E.div) || null;
    for (let w = a.length - 1; w >= 0; w--) {
      const x = a[w];
      switch (x) {
        case h:
        case c:
        case d:
        case u:
        case f:
          continue;
      }
      x.remove();
      const P = o(this, kn).indexOf(x);
      P >= 0 && (o(this, kn)[P] = null);
    }
    r.removeAttribute("data-loaded"), c && this.annotationLayer.hide(), d && this.annotationEditorLayer.hide(), u && this.xfaLayer.hide(), f && this.textLayer.hide(), (A = this.structTreeLayer) == null || A.hide(), h || (this.canvas && (o(this, na).delete(this.canvas), this.canvas.width = 0, this.canvas.height = 0, delete this.canvas), this._resetZoomLayer());
  }
  toggleEditingMode(e) {
    this.hasEditableAnnotations() && (v(this, mc, e), this.reset({
      keepZoomLayer: !0,
      keepAnnotationLayer: !0,
      keepAnnotationEditorLayer: !0,
      keepXfaLayer: !0,
      keepTextLayer: !0
    }));
  }
  update({
    scale: e = 0,
    rotation: t = null,
    optionalContentConfigPromise: s = null,
    drawingDelay: i = -1
  }) {
    var r;
    this.scale = e || this.scale, typeof t == "number" && (this.rotation = t), s instanceof Promise && (this._optionalContentConfigPromise = s, s.then((a) => {
      s === this._optionalContentConfigPromise && (o(this, Ni).initialOptionalContent = a.hasInitialVisibility);
    })), o(this, Ni).directDrawing = !0;
    const n = (this.rotation + this.pdfPageRotate) % 360;
    if (this.viewport = this.viewport.clone({
      scale: this.scale * li.PDF_TO_CSS_UNITS,
      rotation: n
    }), m(this, at, _d).call(this), this._isStandalone && ((r = this._container) == null || r.style.setProperty("--scale-factor", this.viewport.scale)), this.canvas) {
      let a = !1;
      if (o(this, sa)) {
        if (this.maxCanvasPixels === 0)
          a = !0;
        else if (this.maxCanvasPixels > 0) {
          const {
            width: c,
            height: d
          } = this.viewport, {
            sx: u,
            sy: f
          } = this.outputScale;
          a = (Math.floor(c) * u | 0) * (Math.floor(d) * f | 0) > this.maxCanvasPixels;
        }
      }
      const h = i >= 0 && i < 1e3;
      if (h || a) {
        if (h && !a && this.renderingState !== Nt.FINISHED && (this.cancelRendering({
          keepZoomLayer: !0,
          keepAnnotationLayer: !0,
          keepAnnotationEditorLayer: !0,
          keepXfaLayer: !0,
          keepTextLayer: !0,
          cancelExtraDelay: i
        }), this.renderingState = Nt.FINISHED, o(this, Ni).directDrawing = !1), this.cssTransform({
          target: this.canvas,
          redrawAnnotationLayer: !0,
          redrawAnnotationEditorLayer: !0,
          redrawXfaLayer: !0,
          redrawTextLayer: !h,
          hideTextLayer: h
        }), h)
          return;
        this.eventBus.dispatch("pagerendered", {
          source: this,
          pageNumber: this.id,
          cssTransform: !0,
          timestamp: performance.now(),
          error: o(this, ia)
        });
        return;
      }
      !this.zoomLayer && !this.canvas.hidden && (this.zoomLayer = this.canvas.parentNode, this.zoomLayer.style.position = "absolute");
    }
    this.zoomLayer && this.cssTransform({
      target: this.zoomLayer.firstChild
    }), this.reset({
      keepZoomLayer: !0,
      keepAnnotationLayer: !0,
      keepAnnotationEditorLayer: !0,
      keepXfaLayer: !0,
      keepTextLayer: !0
    });
  }
  cancelRendering({
    keepAnnotationLayer: e = !1,
    keepAnnotationEditorLayer: t = !1,
    keepXfaLayer: s = !1,
    keepTextLayer: i = !1,
    cancelExtraDelay: n = 0
  } = {}) {
    var r;
    this.renderTask && (this.renderTask.cancel(n), this.renderTask = null), this.resume = null, this.textLayer && (!i || !this.textLayer.div) && (this.textLayer.cancel(), this.textLayer = null), this.annotationLayer && (!e || !this.annotationLayer.div) && (this.annotationLayer.cancel(), this.annotationLayer = null, this._annotationCanvasMap = null), this.structTreeLayer && !this.textLayer && (this.structTreeLayer = null), this.annotationEditorLayer && (!t || !this.annotationEditorLayer.div) && (this.drawLayer && (this.drawLayer.cancel(), this.drawLayer = null), this.annotationEditorLayer.cancel(), this.annotationEditorLayer = null), this.xfaLayer && (!s || !this.xfaLayer.div) && (this.xfaLayer.cancel(), this.xfaLayer = null, (r = this._textHighlighter) == null || r.disable());
  }
  cssTransform({
    target: e,
    redrawAnnotationLayer: t = !1,
    redrawAnnotationEditorLayer: s = !1,
    redrawXfaLayer: i = !1,
    redrawTextLayer: n = !1,
    hideTextLayer: r = !1
  }) {
    var h;
    if (!e.hasAttribute("zooming")) {
      e.setAttribute("zooming", !0);
      const {
        style: c
      } = e;
      c.width = c.height = "";
    }
    const a = o(this, na).get(e);
    if (this.viewport !== a) {
      const c = this.viewport.rotation - a.rotation, d = Math.abs(c);
      let u = 1, f = 1;
      if (d === 90 || d === 270) {
        const {
          width: p,
          height: g
        } = this.viewport;
        u = g / p, f = p / g;
      }
      e.style.transform = `rotate(${c}deg) scale(${u}, ${f})`;
    }
    t && this.annotationLayer && m(this, at, Pp).call(this), s && this.annotationEditorLayer && (this.drawLayer && m(this, at, Rp).call(this), m(this, at, Cp).call(this)), i && this.xfaLayer && m(this, at, Ip).call(this), this.textLayer && (r ? (this.textLayer.hide(), (h = this.structTreeLayer) == null || h.hide()) : n && m(this, at, Lp).call(this));
  }
  get width() {
    return this.viewport.width;
  }
  get height() {
    return this.viewport.height;
  }
  getPagePoint(e, t) {
    return this.viewport.convertToPdfPoint(e, t);
  }
  async draw() {
    this.renderingState !== Nt.INITIAL && (console.error("Must be in new state before drawing"), this.reset());
    const {
      div: e,
      l10n: t,
      pageColors: s,
      pdfPage: i,
      viewport: n
    } = this;
    if (!i)
      throw this.renderingState = Nt.FINISHED, new Error("pdfPage is not loaded");
    this.renderingState = Nt.RUNNING;
    const r = document.createElement("div");
    if (r.classList.add("canvasWrapper"), m(this, at, La).call(this, r, "canvasWrapper"), !this.textLayer && o(this, zo) !== Qs.DISABLE && !i.isPureXfa && (this._accessibilityManager || (this._accessibilityManager = new Sp()), this.textLayer = new zd({
      pdfPage: i,
      highlighter: this._textHighlighter,
      accessibilityManager: this._accessibilityManager,
      enablePermissions: o(this, zo) === Qs.ENABLE_PERMISSIONS,
      onAppend: (S) => {
        this.l10n.pause(), m(this, at, La).call(this, S, "textLayer"), this.l10n.resume();
      }
    })), !this.annotationLayer && o(this, ea) !== Fi.DISABLE) {
      const {
        annotationStorage: S,
        annotationEditorUIManager: I,
        downloadManager: _,
        enableScripting: D,
        fieldObjectsPromise: k,
        hasJSActionsPromise: j,
        linkService: H
      } = o(this, Nn);
      this._annotationCanvasMap || (this._annotationCanvasMap = /* @__PURE__ */ new Map()), this.annotationLayer = new Sb({
        pdfPage: i,
        annotationStorage: S,
        imageResourcesPath: this.imageResourcesPath,
        renderForms: o(this, ea) === Fi.ENABLE_FORMS,
        linkService: H,
        downloadManager: _,
        enableScripting: D,
        hasJSActionsPromise: j,
        fieldObjectsPromise: k,
        annotationCanvasMap: this._annotationCanvasMap,
        accessibilityManager: this._accessibilityManager,
        annotationEditorUIManager: I,
        onAppend: (L) => {
          m(this, at, La).call(this, L, "annotationLayer");
        }
      });
    }
    const a = (S) => {
      if (f == null || f(!1), this.renderingQueue && !this.renderingQueue.isHighestPriority(this)) {
        this.renderingState = Nt.PAUSED, this.resume = () => {
          this.renderingState = Nt.RUNNING, S();
        };
        return;
      }
      S();
    }, {
      width: h,
      height: c
    } = n, d = document.createElement("canvas");
    d.setAttribute("role", "presentation"), d.hidden = !0;
    const u = !!(s != null && s.background && (s != null && s.foreground));
    let f = (S) => {
      (!u || S) && (d.hidden = !1, f = null);
    };
    r.append(d), this.canvas = d;
    const p = d.getContext("2d", {
      alpha: !1,
      willReadFrequently: !o(this, gc)
    }), g = this.outputScale = new vw();
    if (this.maxCanvasPixels === 0) {
      const S = 1 / this.scale;
      g.sx *= S, g.sy *= S, v(this, sa, !0);
    } else if (this.maxCanvasPixels > 0) {
      const S = h * c, I = Math.sqrt(this.maxCanvasPixels / S);
      g.sx > I || g.sy > I ? (g.sx = I, g.sy = I, v(this, sa, !0)) : v(this, sa, !1);
    }
    const b = Og(g.sx), E = Og(g.sy), A = d.width = $c(Vc(h * g.sx), b[0]), w = d.height = $c(Vc(c * g.sy), E[0]), x = $c(Vc(h), b[1]), P = $c(Vc(c), E[1]);
    g.sx = A / x, g.sy = w / P, o(this, bc) !== b[1] && (e.style.setProperty("--scale-round-x", `${b[1]}px`), v(this, bc, b[1])), o(this, yc) !== E[1] && (e.style.setProperty("--scale-round-y", `${E[1]}px`), v(this, yc, E[1])), o(this, na).set(d, n);
    const T = g.scaled ? [g.sx, 0, 0, g.sy, 0, 0] : null, C = {
      canvasContext: p,
      transform: T,
      viewport: n,
      annotationMode: o(this, ea),
      optionalContentConfigPromise: this._optionalContentConfigPromise,
      annotationCanvasMap: this._annotationCanvasMap,
      pageColors: s,
      isEditing: o(this, mc)
    }, R = this.renderTask = i.render(C);
    R.onContinue = a;
    const M = R.promise.then(async () => {
      var I;
      f == null || f(!0), await m(this, at, Mp).call(this, R), this.structTreeLayer || (this.structTreeLayer = new Bb(i, n.rawDims)), m(this, at, Lp).call(this), this.annotationLayer && await m(this, at, Pp).call(this);
      const {
        annotationEditorUIManager: S
      } = o(this, Nn);
      S && (this.drawLayer || (this.drawLayer = new E0({
        pageIndex: this.id
      })), await m(this, at, Rp).call(this), this.drawLayer.setParent(r), this.annotationEditorLayer || (this.annotationEditorLayer = new A0({
        uiManager: S,
        pdfPage: i,
        l10n: t,
        structTreeLayer: this.structTreeLayer,
        accessibilityManager: this._accessibilityManager,
        annotationLayer: (I = this.annotationLayer) == null ? void 0 : I.annotationLayer,
        textLayer: this.textLayer,
        drawLayer: this.drawLayer.getDrawLayer(),
        onAppend: (_) => {
          m(this, at, La).call(this, _, "annotationEditorLayer");
        }
      })), m(this, at, Cp).call(this));
    }, (S) => (S instanceof dp || f == null || f(!0), m(this, at, Mp).call(this, R, S)));
    if (i.isPureXfa) {
      if (!this.xfaLayer) {
        const {
          annotationStorage: S,
          linkService: I
        } = o(this, Nn);
        this.xfaLayer = new zb({
          pdfPage: i,
          annotationStorage: S,
          linkService: I
        });
      }
      m(this, at, Ip).call(this);
    }
    return e.setAttribute("data-loaded", !0), this.eventBus.dispatch("pagerender", {
      source: this,
      pageNumber: this.id
    }), M;
  }
  setPageLabel(e) {
    this.pageLabel = typeof e == "string" ? e : null, this.div.setAttribute("data-l10n-args", JSON.stringify({
      page: this.pageLabel ?? this.id
    })), this.pageLabel !== null ? this.div.setAttribute("data-page-label", this.pageLabel) : this.div.removeAttribute("data-page-label");
  }
  get thumbnailCanvas() {
    const {
      directDrawing: e,
      initialOptionalContent: t,
      regularAnnotations: s
    } = o(this, Ni);
    return e && t && s ? this.canvas : null;
  }
}
ea = new WeakMap(), gc = new WeakMap(), sa = new WeakMap(), mc = new WeakMap(), Nn = new WeakMap(), Dn = new WeakMap(), vc = new WeakMap(), bc = new WeakMap(), yc = new WeakMap(), ia = new WeakMap(), Uo = new WeakMap(), zo = new WeakMap(), Ni = new WeakMap(), na = new WeakMap(), kn = new WeakMap(), at = new WeakSet(), La = function(e, t) {
  const s = T0.get(t), i = o(this, kn)[s];
  if (o(this, kn)[s] = e, i) {
    i.replaceWith(e);
    return;
  }
  for (let n = s - 1; n >= 0; n--) {
    const r = o(this, kn)[n];
    if (r) {
      r.after(e);
      return;
    }
  }
  this.div.prepend(e);
}, _d = function() {
  const {
    viewport: e
  } = this;
  if (this.pdfPage) {
    if (o(this, vc) === e.rotation)
      return;
    v(this, vc, e.rotation);
  }
  bw(this.div, e, !0, !1);
}, Pl = function(e, t) {
  this.eventBus.dispatch(e, {
    source: this,
    pageNumber: this.id,
    error: t
  });
}, Pp = async function() {
  let e = null;
  try {
    await this.annotationLayer.render(this.viewport, {
      structTreeLayer: this.structTreeLayer
    }, "display");
  } catch (t) {
    console.error(`#renderAnnotationLayer: "${t}".`), e = t;
  } finally {
    m(this, at, Pl).call(this, "annotationlayerrendered", e);
  }
}, Cp = async function() {
  let e = null;
  try {
    await this.annotationEditorLayer.render(this.viewport, "display");
  } catch (t) {
    console.error(`#renderAnnotationEditorLayer: "${t}".`), e = t;
  } finally {
    m(this, at, Pl).call(this, "annotationeditorlayerrendered", e);
  }
}, Rp = async function() {
  try {
    await this.drawLayer.render("display");
  } catch (e) {
    console.error(`#renderDrawLayer: "${e}".`);
  }
}, Ip = async function() {
  var t;
  let e = null;
  try {
    const s = await this.xfaLayer.render(this.viewport, "display");
    s != null && s.textDivs && this._textHighlighter && m(this, at, Xb).call(this, s.textDivs);
  } catch (s) {
    console.error(`#renderXfaLayer: "${s}".`), e = s;
  } finally {
    (t = this.xfaLayer) != null && t.div && (this.l10n.pause(), m(this, at, La).call(this, this.xfaLayer.div, "xfaLayer"), this.l10n.resume()), m(this, at, Pl).call(this, "xfalayerrendered", e);
  }
}, Lp = async function() {
  if (!this.textLayer)
    return;
  let e = null;
  try {
    await this.textLayer.render(this.viewport);
  } catch (t) {
    if (t instanceof lw)
      return;
    console.error(`#renderTextLayer: "${t}".`), e = t;
  }
  m(this, at, Pl).call(this, "textlayerrendered", e), m(this, at, Gb).call(this);
}, Gb = async function() {
  var t, s, i;
  if (!this.textLayer)
    return;
  const e = await ((t = this.structTreeLayer) == null ? void 0 : t.render());
  e && (this.l10n.pause(), (s = this.structTreeLayer) == null || s.addElementsToTextLayer(), this.canvas && e.parentNode !== this.canvas && this.canvas.append(e), this.l10n.resume()), (i = this.structTreeLayer) == null || i.show();
}, Xb = async function(e) {
  const t = await this.pdfPage.getTextContent(), s = [];
  for (const i of t.items)
    s.push(i.str);
  this._textHighlighter.setTextMapping(e, s), this._textHighlighter.enable();
}, Mp = async function(e, t = null) {
  if (e === this.renderTask && (this.renderTask = null), t instanceof dp) {
    v(this, ia, null);
    return;
  }
  if (v(this, ia, t), this.renderingState = Nt.FINISHED, this._resetZoomLayer(!0), o(this, Ni).regularAnnotations = !e.separateAnnots, this.eventBus.dispatch("pagerendered", {
    source: this,
    pageNumber: this.id,
    cssTransform: !1,
    timestamp: performance.now(),
    error: o(this, ia)
  }), t)
    throw t;
};
async function P0(l) {
  const e = "", t = e.split("#", 1)[0];
  let {
    info: s,
    metadata: i,
    contentDispositionFilename: n,
    contentLength: r
  } = await l.getMetadata();
  if (!r) {
    const {
      length: a
    } = await l.getDownloadInfo();
    r = a;
  }
  return {
    ...s,
    baseURL: t,
    filesize: r,
    filename: n || pw(e),
    metadata: i == null ? void 0 : i.getRaw(),
    authors: i == null ? void 0 : i.get("dc:creator"),
    numPages: l.numPages,
    URL: e
  };
}
class C0 {
  constructor(e) {
    this._ready = new Promise((t, s) => {
      import(
        /*webpackIgnore: true*/
        e
      ).then((n) => {
        t(n.QuickJSSandbox());
      }).catch(s);
    });
  }
  async createSandbox(e) {
    (await this._ready).create(e);
  }
  async dispatchEventInSandbox(e) {
    const t = await this._ready;
    setTimeout(() => t.dispatchEvent(e), 0);
  }
  async destroySandbox() {
    (await this._ready).nukeSandbox();
  }
}
var Ks, ra, Ac, aa, oa, Ec, we, Di, Wo, Yt, ns, re, Kb, Od, _p, Yb, Cl;
class R0 {
  constructor({
    eventBus: e,
    externalServices: t = null,
    docProperties: s = null
  }) {
    y(this, re);
    y(this, Ks, null);
    y(this, ra, null);
    y(this, Ac, null);
    y(this, aa, null);
    y(this, oa, null);
    y(this, Ec, null);
    y(this, we, null);
    y(this, Di, null);
    y(this, Wo, !1);
    y(this, Yt, null);
    y(this, ns, null);
    v(this, oa, e), v(this, Ec, t), v(this, Ac, s);
  }
  setViewer(e) {
    v(this, Di, e);
  }
  async setDocument(e) {
    var a;
    if (o(this, we) && await m(this, re, Cl).call(this), v(this, we, e), !e)
      return;
    const [t, s, i] = await Promise.all([e.getFieldObjects(), e.getCalculationOrderIds(), e.getJSActions()]);
    if (!t && !i) {
      await m(this, re, Cl).call(this);
      return;
    }
    if (e !== o(this, we))
      return;
    try {
      v(this, Yt, m(this, re, Yb).call(this));
    } catch (h) {
      console.error(`setDocument: "${h.message}".`), await m(this, re, Cl).call(this);
      return;
    }
    const n = o(this, oa);
    v(this, aa, new AbortController());
    const {
      signal: r
    } = o(this, aa);
    n._on("updatefromsandbox", (h) => {
      (h == null ? void 0 : h.source) === window && m(this, re, Kb).call(this, h.detail);
    }, {
      signal: r
    }), n._on("dispatcheventinsandbox", (h) => {
      var c;
      (c = o(this, Yt)) == null || c.dispatchEventInSandbox(h.detail);
    }, {
      signal: r
    }), n._on("pagechanging", ({
      pageNumber: h,
      previous: c
    }) => {
      h !== c && (m(this, re, _p).call(this, c), m(this, re, Od).call(this, h));
    }, {
      signal: r
    }), n._on("pagerendered", ({
      pageNumber: h
    }) => {
      this._pageOpenPending.has(h) && h === o(this, Di).currentPageNumber && m(this, re, Od).call(this, h);
    }, {
      signal: r
    }), n._on("pagesdestroy", async () => {
      var h, c;
      await m(this, re, _p).call(this, o(this, Di).currentPageNumber), await ((h = o(this, Yt)) == null ? void 0 : h.dispatchEventInSandbox({
        id: "doc",
        name: "WillClose"
      })), (c = o(this, Ks)) == null || c.resolve();
    }, {
      signal: r
    });
    try {
      const h = await o(this, Ac).call(this, e);
      if (e !== o(this, we))
        return;
      await o(this, Yt).createSandbox({
        objects: t,
        calculationOrder: s,
        appInfo: {
          platform: navigator.platform,
          language: navigator.language
        },
        docInfo: {
          ...h,
          actions: i
        }
      }), n.dispatch("sandboxcreated", {
        source: this
      });
    } catch (h) {
      console.error(`setDocument: "${h.message}".`), await m(this, re, Cl).call(this);
      return;
    }
    await ((a = o(this, Yt)) == null ? void 0 : a.dispatchEventInSandbox({
      id: "doc",
      name: "Open"
    })), await m(this, re, Od).call(this, o(this, Di).currentPageNumber, !0), Promise.resolve().then(() => {
      e === o(this, we) && v(this, Wo, !0);
    });
  }
  async dispatchWillSave() {
    var e;
    return (e = o(this, Yt)) == null ? void 0 : e.dispatchEventInSandbox({
      id: "doc",
      name: "WillSave"
    });
  }
  async dispatchDidSave() {
    var e;
    return (e = o(this, Yt)) == null ? void 0 : e.dispatchEventInSandbox({
      id: "doc",
      name: "DidSave"
    });
  }
  async dispatchWillPrint() {
    var e;
    if (o(this, Yt)) {
      await ((e = o(this, ns)) == null ? void 0 : e.promise), v(this, ns, Promise.withResolvers());
      try {
        await o(this, Yt).dispatchEventInSandbox({
          id: "doc",
          name: "WillPrint"
        });
      } catch (t) {
        throw o(this, ns).resolve(), v(this, ns, null), t;
      }
      await o(this, ns).promise;
    }
  }
  async dispatchDidPrint() {
    var e;
    return (e = o(this, Yt)) == null ? void 0 : e.dispatchEventInSandbox({
      id: "doc",
      name: "DidPrint"
    });
  }
  get destroyPromise() {
    var e;
    return ((e = o(this, ra)) == null ? void 0 : e.promise) || null;
  }
  get ready() {
    return o(this, Wo);
  }
  get _pageOpenPending() {
    return Vd(this, "_pageOpenPending", /* @__PURE__ */ new Set());
  }
  get _visitedPages() {
    return Vd(this, "_visitedPages", /* @__PURE__ */ new Map());
  }
}
Ks = new WeakMap(), ra = new WeakMap(), Ac = new WeakMap(), aa = new WeakMap(), oa = new WeakMap(), Ec = new WeakMap(), we = new WeakMap(), Di = new WeakMap(), Wo = new WeakMap(), Yt = new WeakMap(), ns = new WeakMap(), re = new WeakSet(), Kb = async function(e) {
  var c, d;
  const t = o(this, Di), s = t.isInPresentationMode || t.isChangingPresentationMode, {
    id: i,
    siblings: n,
    command: r,
    value: a
  } = e;
  if (!i) {
    switch (r) {
      case "clear":
        console.clear();
        break;
      case "error":
        console.error(a);
        break;
      case "layout":
        if (!s) {
          const u = jE(a);
          t.spreadMode = u.spreadMode;
        }
        break;
      case "page-num":
        t.currentPageNumber = a + 1;
        break;
      case "print":
        await t.pagesPromise, o(this, oa).dispatch("print", {
          source: this
        });
        break;
      case "println":
        console.log(a);
        break;
      case "zoom":
        s || (t.currentScaleValue = a);
        break;
      case "SaveAs":
        o(this, oa).dispatch("download", {
          source: this
        });
        break;
      case "FirstPage":
        t.currentPageNumber = 1;
        break;
      case "LastPage":
        t.currentPageNumber = t.pagesCount;
        break;
      case "NextPage":
        t.nextPage();
        break;
      case "PrevPage":
        t.previousPage();
        break;
      case "ZoomViewIn":
        s || t.increaseScale();
        break;
      case "ZoomViewOut":
        s || t.decreaseScale();
        break;
      case "WillPrintFinished":
        (c = o(this, ns)) == null || c.resolve(), v(this, ns, null);
        break;
    }
    return;
  }
  if (s && e.focus)
    return;
  delete e.id, delete e.siblings;
  const h = n ? [i, ...n] : [i];
  for (const u of h) {
    const f = document.querySelector(`[data-element-id="${u}"]`);
    f ? f.dispatchEvent(new CustomEvent("updatefromsandbox", {
      detail: e
    })) : (d = o(this, we)) == null || d.annotationStorage.setValue(u, e);
  }
}, Od = async function(e, t = !1) {
  const s = o(this, we), i = this._visitedPages;
  if (t && v(this, Ks, Promise.withResolvers()), !o(this, Ks))
    return;
  const n = o(this, Di).getPageView(e - 1);
  if ((n == null ? void 0 : n.renderingState) !== Nt.FINISHED) {
    this._pageOpenPending.add(e);
    return;
  }
  this._pageOpenPending.delete(e);
  const r = (async () => {
    var h, c;
    const a = await (i.has(e) ? null : (h = n.pdfPage) == null ? void 0 : h.getJSActions());
    s === o(this, we) && await ((c = o(this, Yt)) == null ? void 0 : c.dispatchEventInSandbox({
      id: "page",
      name: "PageOpen",
      pageNumber: e,
      actions: a
    }));
  })();
  i.set(e, r);
}, _p = async function(e) {
  var n;
  const t = o(this, we), s = this._visitedPages;
  if (!o(this, Ks) || this._pageOpenPending.has(e))
    return;
  const i = s.get(e);
  i && (s.set(e, null), await i, t === o(this, we) && await ((n = o(this, Yt)) == null ? void 0 : n.dispatchEventInSandbox({
    id: "page",
    name: "PageClose",
    pageNumber: e
  })));
}, Yb = function() {
  if (v(this, ra, Promise.withResolvers()), o(this, Yt))
    throw new Error("#initScripting: Scripting already exists.");
  return o(this, Ec).createScripting();
}, Cl = async function() {
  var e, t, s, i;
  if (!o(this, Yt)) {
    v(this, we, null), (e = o(this, ra)) == null || e.resolve();
    return;
  }
  o(this, Ks) && (await Promise.race([o(this, Ks).promise, new Promise((n) => {
    setTimeout(n, 1e3);
  })]).catch(() => {
  }), v(this, Ks, null)), v(this, we, null);
  try {
    await o(this, Yt).destroySandbox();
  } catch {
  }
  (t = o(this, ns)) == null || t.reject(new Error("Scripting destroyed.")), v(this, ns, null), (s = o(this, aa)) == null || s.abort(), v(this, aa, null), this._pageOpenPending.clear(), this._visitedPages.clear(), v(this, Yt, null), v(this, Wo, !1), (i = o(this, ra)) == null || i.resolve();
};
class I0 extends R0 {
  constructor(e) {
    e.externalServices || window.addEventListener("updatefromsandbox", (t) => {
      e.eventBus.dispatch("updatefromsandbox", {
        source: window,
        detail: t.detail
      });
    }), e.externalServices || (e.externalServices = {
      createScripting: () => new C0(e.sandboxBundleSrc)
    }), e.docProperties || (e.docProperties = (t) => P0(t)), super(e);
  }
}
const L0 = 3e4;
class M0 {
  constructor() {
    this.pdfViewer = null, this.pdfThumbnailViewer = null, this.onIdle = null, this.highestPriorityPage = null, this.idleTimeout = null, this.printing = !1, this.isThumbnailViewEnabled = !1, Object.defineProperty(this, "hasViewer", {
      value: () => !!this.pdfViewer
    });
  }
  setViewer(e) {
    this.pdfViewer = e;
  }
  setThumbnailViewer(e) {
    this.pdfThumbnailViewer = e;
  }
  isHighestPriority(e) {
    return this.highestPriorityPage === e.renderingId;
  }
  renderHighestPriority(e) {
    var t;
    this.idleTimeout && (clearTimeout(this.idleTimeout), this.idleTimeout = null), !this.pdfViewer.forceRendering(e) && (this.isThumbnailViewEnabled && ((t = this.pdfThumbnailViewer) != null && t.forceRendering()) || this.printing || this.onIdle && (this.idleTimeout = setTimeout(this.onIdle.bind(this), L0)));
  }
  getHighestPriority(e, t, s, i = !1) {
    const n = e.views, r = n.length;
    if (r === 0)
      return null;
    for (let u = 0; u < r; u++) {
      const f = n[u].view;
      if (!this.isViewFinished(f))
        return f;
    }
    const a = e.first.id, h = e.last.id;
    if (h - a + 1 > r) {
      const u = e.ids;
      for (let f = 1, p = h - a; f < p; f++) {
        const g = s ? a + f : h - f;
        if (u.has(g))
          continue;
        const b = t[g - 1];
        if (!this.isViewFinished(b))
          return b;
      }
    }
    let c = s ? h : a - 2, d = t[c];
    return d && !this.isViewFinished(d) || i && (c += s ? 1 : -1, d = t[c], d && !this.isViewFinished(d)) ? d : null;
  }
  isViewFinished(e) {
    return e.renderingState === Nt.FINISHED;
  }
  renderView(e) {
    switch (e.renderingState) {
      case Nt.FINISHED:
        return !1;
      case Nt.PAUSED:
        this.highestPriorityPage = e.renderingId, e.resume();
        break;
      case Nt.RUNNING:
        this.highestPriorityPage = e.renderingId;
        break;
      case Nt.INITIAL:
        this.highestPriorityPage = e.renderingId, e.draw().finally(() => {
          this.renderHighestPriority();
        }).catch((t) => {
          t instanceof dp || console.error(`renderView: "${t}"`);
        });
        break;
    }
    return !0;
  }
}
const am = 10, Gc = {
  FORCE_SCROLL_MODE_PAGE: 1e4,
  FORCE_LAZY_PAGE_INIT: 5e3,
  PAUSE_EAGER_PAGE_INIT: 250
};
function om(l) {
  return Object.values(je).includes(l) && l !== je.DISABLE;
}
var ki, la, wc, Op;
class _0 {
  constructor(e) {
    y(this, wc);
    y(this, ki, /* @__PURE__ */ new Set());
    y(this, la, 0);
    v(this, la, e);
  }
  push(e) {
    const t = o(this, ki);
    t.has(e) && t.delete(e), t.add(e), t.size > o(this, la) && m(this, wc, Op).call(this);
  }
  resize(e, t = null) {
    v(this, la, e);
    const s = o(this, ki);
    if (t) {
      const i = s.size;
      let n = 1;
      for (const r of s)
        if (t.has(r.id) && (s.delete(r), s.add(r)), ++n > i)
          break;
    }
    for (; s.size > o(this, la); )
      m(this, wc, Op).call(this);
  }
  has(e) {
    return o(this, ki).has(e);
  }
  [Symbol.iterator]() {
    return o(this, ki).keys();
  }
}
ki = new WeakMap(), la = new WeakMap(), wc = new WeakSet(), Op = function() {
  const e = o(this, ki).keys().next().value;
  e == null || e.destroy(), o(this, ki).delete(e);
};
var Fn, xc, Sc, Ys, Ge, ha, Tc, Pc, Cc, Rc, Ic, Lc, jn, ca, da, ua, Go, Bn, Xo, Mc, Ko, fa, Hn, Yo, Y, Zb, Jb, qb, Rl, Nd, ty, Np, ey, Yi, Dp, sy, iy, ny, kp, ry, Dd;
class Qb {
  constructor(e) {
    y(this, Y);
    y(this, Fn, null);
    y(this, xc, null);
    y(this, Sc, null);
    y(this, Ys, je.NONE);
    y(this, Ge, null);
    y(this, ha, Fi.ENABLE_FORMS);
    y(this, Tc, null);
    y(this, Pc, !1);
    y(this, Cc, !1);
    y(this, Rc, !1);
    y(this, Ic, !1);
    y(this, Lc, !1);
    y(this, jn, null);
    y(this, ca, null);
    y(this, da, null);
    y(this, ua, null);
    y(this, Go, !1);
    y(this, Bn, null);
    y(this, Xo, !1);
    y(this, Mc, 0);
    y(this, Ko, new ResizeObserver(m(this, Y, ry).bind(this)));
    y(this, fa, null);
    y(this, Hn, null);
    y(this, Yo, Qs.ENABLE);
    var i, n;
    const t = "4.7.76";
    if (Vg !== t)
      throw new Error(`The API version "${Vg}" does not match the Viewer version "${t}".`);
    if (this.container = e.container, this.viewer = e.viewer || e.container.firstElementChild, ((i = this.container) == null ? void 0 : i.tagName) !== "DIV" || ((n = this.viewer) == null ? void 0 : n.tagName) !== "DIV")
      throw new Error("Invalid `container` and/or `viewer` option.");
    if (this.container.offsetParent && getComputedStyle(this.container).position !== "absolute")
      throw new Error("The `container` must be absolutely positioned.");
    o(this, Ko).observe(this.container), this.eventBus = e.eventBus, this.linkService = e.linkService || new Zp(), this.downloadManager = e.downloadManager || null, this.findController = e.findController || null, v(this, xc, e.altTextManager || null), this.findController && (this.findController.onIsPageVisible = (r) => this._getVisiblePages().ids.has(r)), this._scriptingManager = e.scriptingManager || null, v(this, Yo, e.textLayerMode ?? Qs.ENABLE), v(this, ha, e.annotationMode ?? Fi.ENABLE_FORMS), v(this, Ys, e.annotationEditorMode ?? je.NONE), v(this, Sc, e.annotationEditorHighlightColors || null), v(this, Cc, e.enableHighlightFloatingButton === !0), v(this, Ic, e.enableUpdatedAddImage === !0), v(this, Lc, e.enableNewAltTextWhenAddingImage === !0), this.imageResourcesPath = e.imageResourcesPath || "", this.enablePrintAutoRotate = e.enablePrintAutoRotate || !1, this.removePageBorders = e.removePageBorders || !1, this.maxCanvasPixels = e.maxCanvasPixels, this.l10n = e.l10n, this.l10n || (this.l10n = new Jo()), v(this, Rc, e.enablePermissions || !1), this.pageColors = e.pageColors || null, v(this, ca, e.mlManager || null), v(this, Pc, e.enableHWA || !1), this.defaultRenderingQueue = !e.renderingQueue, this.defaultRenderingQueue ? (this.renderingQueue = new M0(), this.renderingQueue.setViewer(this)) : this.renderingQueue = e.renderingQueue;
    const {
      abortSignal: s
    } = e;
    s == null || s.addEventListener("abort", () => {
      o(this, Ko).disconnect(), v(this, Ko, null);
    }, {
      once: !0
    }), this.scroll = LE(this.container, this._scrollUpdate.bind(this), s), this.presentationModeState = Oa.UNKNOWN, this._resetView(), this.removePageBorders && this.viewer.classList.add("removePageBorders"), m(this, Y, kp).call(this), this.eventBus._on("thumbnailrendered", ({
      pageNumber: r,
      pdfPage: a
    }) => {
      const h = this._pages[r - 1];
      o(this, Fn).has(h) || a == null || a.cleanup();
    }), e.l10n || this.l10n.translate(this.container);
  }
  get pagesCount() {
    return this._pages.length;
  }
  getPageView(e) {
    return this._pages[e];
  }
  getCachedPageViews() {
    return new Set(o(this, Fn));
  }
  get pageViewsReady() {
    return this._pages.every((e) => e == null ? void 0 : e.pdfPage);
  }
  get renderForms() {
    return o(this, ha) === Fi.ENABLE_FORMS;
  }
  get enableScripting() {
    return !!this._scriptingManager;
  }
  get currentPageNumber() {
    return this._currentPageNumber;
  }
  set currentPageNumber(e) {
    if (!Number.isInteger(e))
      throw new Error("Invalid page number.");
    this.pdfDocument && (this._setCurrentPageNumber(e, !0) || console.error(`currentPageNumber: "${e}" is not a valid page.`));
  }
  _setCurrentPageNumber(e, t = !1) {
    var i;
    if (this._currentPageNumber === e)
      return t && m(this, Y, Dp).call(this), !0;
    if (!(0 < e && e <= this.pagesCount))
      return !1;
    const s = this._currentPageNumber;
    return this._currentPageNumber = e, this.eventBus.dispatch("pagechanging", {
      source: this,
      pageNumber: e,
      pageLabel: ((i = this._pageLabels) == null ? void 0 : i[e - 1]) ?? null,
      previous: s
    }), t && m(this, Y, Dp).call(this), !0;
  }
  get currentPageLabel() {
    var e;
    return ((e = this._pageLabels) == null ? void 0 : e[this._currentPageNumber - 1]) ?? null;
  }
  set currentPageLabel(e) {
    if (!this.pdfDocument)
      return;
    let t = e | 0;
    if (this._pageLabels) {
      const s = this._pageLabels.indexOf(e);
      s >= 0 && (t = s + 1);
    }
    this._setCurrentPageNumber(t, !0) || console.error(`currentPageLabel: "${e}" is not a valid page.`);
  }
  get currentScale() {
    return this._currentScale !== Lu ? this._currentScale : fb;
  }
  set currentScale(e) {
    if (isNaN(e))
      throw new Error("Invalid numeric scale.");
    this.pdfDocument && m(this, Y, Yi).call(this, e, {
      noScroll: !1
    });
  }
  get currentScaleValue() {
    return this._currentScaleValue;
  }
  set currentScaleValue(e) {
    this.pdfDocument && m(this, Y, Yi).call(this, e, {
      noScroll: !1
    });
  }
  get pagesRotation() {
    return this._pagesRotation;
  }
  set pagesRotation(e) {
    if (!gb(e))
      throw new Error("Invalid pages rotation angle.");
    if (!this.pdfDocument || (e %= 360, e < 0 && (e += 360), this._pagesRotation === e))
      return;
    this._pagesRotation = e;
    const t = this._currentPageNumber;
    this.refresh(!0, {
      rotation: e
    }), this._currentScaleValue && m(this, Y, Yi).call(this, this._currentScaleValue, {
      noScroll: !0
    }), this.eventBus.dispatch("rotationchanging", {
      source: this,
      pagesRotation: e,
      pageNumber: t
    }), this.defaultRenderingQueue && this.update();
  }
  get firstPagePromise() {
    return this.pdfDocument ? this._firstPageCapability.promise : null;
  }
  get onePageRendered() {
    return this.pdfDocument ? this._onePageRenderedCapability.promise : null;
  }
  get pagesPromise() {
    return this.pdfDocument ? this._pagesCapability.promise : null;
  }
  get _layerProperties() {
    const e = this;
    return Vd(this, "_layerProperties", {
      get annotationEditorUIManager() {
        return o(e, Ge);
      },
      get annotationStorage() {
        var t;
        return (t = e.pdfDocument) == null ? void 0 : t.annotationStorage;
      },
      get downloadManager() {
        return e.downloadManager;
      },
      get enableScripting() {
        return !!e._scriptingManager;
      },
      get fieldObjectsPromise() {
        var t;
        return (t = e.pdfDocument) == null ? void 0 : t.getFieldObjects();
      },
      get findController() {
        return e.findController;
      },
      get hasJSActionsPromise() {
        var t;
        return (t = e.pdfDocument) == null ? void 0 : t.hasJSActions();
      },
      get linkService() {
        return e.linkService;
      }
    });
  }
  async getAllText() {
    const e = [], t = [];
    for (let s = 1, i = this.pdfDocument.numPages; s <= i; ++s) {
      if (o(this, Xo))
        return null;
      t.length = 0;
      const n = await this.pdfDocument.getPage(s), {
        items: r
      } = await n.getTextContent();
      for (const a of r)
        a.str && t.push(a.str), a.hasEOL && t.push(`
`);
      e.push(_l(t.join("")));
    }
    return e.join(`
`);
  }
  setDocument(e) {
    var f, p, g;
    if (this.pdfDocument && (this.eventBus.dispatch("pagesdestroy", {
      source: this
    }), this._cancelRendering(), this._resetView(), (f = this.findController) == null || f.setDocument(null), (p = this._scriptingManager) == null || p.setDocument(null), (g = o(this, Ge)) == null || g.destroy(), v(this, Ge, null)), this.pdfDocument = e, !e)
      return;
    const t = e.numPages, s = e.getPage(1), i = e.getOptionalContentConfig({
      intent: "display"
    }), n = o(this, Rc) ? e.getPermissions() : Promise.resolve(), {
      eventBus: r,
      pageColors: a,
      viewer: h
    } = this;
    v(this, jn, new AbortController());
    const {
      signal: c
    } = o(this, jn);
    if (t > Gc.FORCE_SCROLL_MODE_PAGE) {
      console.warn("Forcing PAGE-scrolling for performance reasons, given the length of the document.");
      const b = this._scrollMode = ct.PAGE;
      r.dispatch("scrollmodechanged", {
        source: this,
        mode: b
      });
    }
    this._pagesCapability.promise.then(() => {
      r.dispatch("pagesloaded", {
        source: this,
        pagesCount: t
      });
    }, () => {
    });
    const d = (b) => {
      const E = this._pages[b.pageNumber - 1];
      E && o(this, Fn).push(E);
    };
    r._on("pagerender", d, {
      signal: c
    });
    const u = (b) => {
      b.cssTransform || (this._onePageRenderedCapability.resolve({
        timestamp: b.timestamp
      }), r._off("pagerendered", u));
    };
    r._on("pagerendered", u, {
      signal: c
    }), Promise.all([s, n]).then(([b, E]) => {
      var R, M;
      if (e !== this.pdfDocument)
        return;
      this._firstPageCapability.resolve(b), this._optionalContentConfigPromise = i;
      const {
        annotationEditorMode: A,
        annotationMode: w,
        textLayerMode: x
      } = m(this, Y, Zb).call(this, E);
      if (x !== Qs.DISABLE) {
        const S = v(this, Bn, document.createElement("div"));
        S.id = "hiddenCopyElement", h.before(S);
      }
      if (typeof AbortSignal.any == "function" && A !== je.DISABLE) {
        const S = A;
        e.isPureXfa ? console.warn("Warning: XFA-editing is not implemented.") : om(S) ? (v(this, Ge, new cw(this.container, h, o(this, xc), r, e, a, o(this, Sc), o(this, Cc), o(this, Ic), o(this, Lc), o(this, ca))), r.dispatch("annotationeditoruimanager", {
          source: this,
          uiManager: o(this, Ge)
        }), S !== je.NONE && (S === je.STAMP && ((R = o(this, ca)) == null || R.loadModel("altText")), o(this, Ge).updateMode(S))) : console.error(`Invalid AnnotationEditor mode: ${S}`);
      }
      const P = this._scrollMode === ct.PAGE ? null : h, T = this.currentScale, C = b.getViewport({
        scale: T * li.PDF_TO_CSS_UNITS
      });
      h.style.setProperty("--scale-factor", C.scale), a != null && a.background && h.style.setProperty("--page-bg-color", a.background), ((a == null ? void 0 : a.foreground) === "CanvasText" || (a == null ? void 0 : a.background) === "Canvas") && (h.style.setProperty("--hcm-highlight-filter", e.filterFactory.addHighlightHCMFilter("highlight", "CanvasText", "Canvas", "HighlightText", "Highlight")), h.style.setProperty("--hcm-highlight-selected-filter", e.filterFactory.addHighlightHCMFilter("highlight_selected", "CanvasText", "Canvas", "HighlightText", "ButtonText")));
      for (let S = 1; S <= t; ++S) {
        const I = new Wb({
          container: P,
          eventBus: r,
          id: S,
          scale: T,
          defaultViewport: C.clone(),
          optionalContentConfigPromise: i,
          renderingQueue: this.renderingQueue,
          textLayerMode: x,
          annotationMode: w,
          imageResourcesPath: this.imageResourcesPath,
          maxCanvasPixels: this.maxCanvasPixels,
          pageColors: a,
          l10n: this.l10n,
          layerProperties: this._layerProperties,
          enableHWA: o(this, Pc)
        });
        this._pages.push(I);
      }
      (M = this._pages[0]) == null || M.setPdfPage(b), this._scrollMode === ct.PAGE ? m(this, Y, Rl).call(this) : this._spreadMode !== be.NONE && this._updateSpreadMode(), m(this, Y, Jb).call(this, c).then(async () => {
        var I, _;
        if (e !== this.pdfDocument)
          return;
        if ((I = this.findController) == null || I.setDocument(e), (_ = this._scriptingManager) == null || _.setDocument(e), o(this, Bn) && document.addEventListener("copy", m(this, Y, qb).bind(this, x), {
          signal: c
        }), o(this, Ge) && r.dispatch("annotationeditormodechanged", {
          source: this,
          mode: o(this, Ys)
        }), e.loadingParams.disableAutoFetch || t > Gc.FORCE_LAZY_PAGE_INIT) {
          this._pagesCapability.resolve();
          return;
        }
        let S = t - 1;
        if (S <= 0) {
          this._pagesCapability.resolve();
          return;
        }
        for (let D = 2; D <= t; ++D) {
          const k = e.getPage(D).then((j) => {
            const H = this._pages[D - 1];
            H.pdfPage || H.setPdfPage(j), --S === 0 && this._pagesCapability.resolve();
          }, (j) => {
            console.error(`Unable to get page ${D} to initialize viewer`, j), --S === 0 && this._pagesCapability.resolve();
          });
          D % Gc.PAUSE_EAGER_PAGE_INIT === 0 && await k;
        }
      }), r.dispatch("pagesinit", {
        source: this
      }), e.getMetadata().then(({
        info: S
      }) => {
        e === this.pdfDocument && S.Language && (h.lang = S.Language);
      }), this.defaultRenderingQueue && this.update();
    }).catch((b) => {
      console.error("Unable to initialize viewer", b), this._pagesCapability.reject(b);
    });
  }
  setPageLabels(e) {
    var t;
    if (this.pdfDocument) {
      e ? Array.isArray(e) && this.pdfDocument.numPages === e.length ? this._pageLabels = e : (this._pageLabels = null, console.error("setPageLabels: Invalid page labels.")) : this._pageLabels = null;
      for (let s = 0, i = this._pages.length; s < i; s++)
        this._pages[s].setPageLabel(((t = this._pageLabels) == null ? void 0 : t[s]) ?? null);
    }
  }
  _resetView() {
    var e, t;
    this._pages = [], this._currentPageNumber = 1, this._currentScale = Lu, this._currentScaleValue = null, this._pageLabels = null, v(this, Fn, new _0(am)), this._location = null, this._pagesRotation = 0, this._optionalContentConfigPromise = null, this._firstPageCapability = Promise.withResolvers(), this._onePageRenderedCapability = Promise.withResolvers(), this._pagesCapability = Promise.withResolvers(), this._scrollMode = ct.VERTICAL, this._previousScrollMode = ct.UNKNOWN, this._spreadMode = be.NONE, v(this, fa, {
      previousPageNumber: 1,
      scrollDown: !0,
      pages: []
    }), (e = o(this, jn)) == null || e.abort(), v(this, jn, null), this.viewer.textContent = "", this._updateScrollMode(), this.viewer.removeAttribute("lang"), (t = o(this, Bn)) == null || t.remove(), v(this, Bn, null), m(this, Y, Dd).call(this);
  }
  _scrollUpdate() {
    this.pagesCount !== 0 && this.update();
  }
  pageLabelToPageNumber(e) {
    if (!this._pageLabels)
      return null;
    const t = this._pageLabels.indexOf(e);
    return t < 0 ? null : t + 1;
  }
  scrollPageIntoView({
    pageNumber: e,
    destArray: t = null,
    allowNegativeOffset: s = !1,
    ignoreDestinationZoom: i = !1
  }) {
    if (!this.pdfDocument)
      return;
    const n = Number.isInteger(e) && this._pages[e - 1];
    if (!n) {
      console.error(`scrollPageIntoView: "${e}" is not a valid pageNumber parameter.`);
      return;
    }
    if (this.isInPresentationMode || !t) {
      this._setCurrentPageNumber(e, !0);
      return;
    }
    let r = 0, a = 0, h = 0, c = 0, d, u;
    const f = n.rotation % 180 !== 0, p = (f ? n.height : n.width) / n.scale / li.PDF_TO_CSS_UNITS, g = (f ? n.width : n.height) / n.scale / li.PDF_TO_CSS_UNITS;
    let b = 0;
    switch (t[1].name) {
      case "XYZ":
        r = t[2], a = t[3], b = t[4], r = r !== null ? r : 0, a = a !== null ? a : g;
        break;
      case "Fit":
      case "FitB":
        b = "page-fit";
        break;
      case "FitH":
      case "FitBH":
        a = t[2], b = "page-width", a === null && this._location ? (r = this._location.left, a = this._location.top) : (typeof a != "number" || a < 0) && (a = g);
        break;
      case "FitV":
      case "FitBV":
        r = t[2], h = p, c = g, b = "page-height";
        break;
      case "FitR":
        r = t[2], a = t[3], h = t[4] - r, c = t[5] - a;
        let x = Lg, P = Mg;
        this.removePageBorders && (x = P = 0), d = (this.container.clientWidth - x) / h / li.PDF_TO_CSS_UNITS, u = (this.container.clientHeight - P) / c / li.PDF_TO_CSS_UNITS, b = Math.min(Math.abs(d), Math.abs(u));
        break;
      default:
        console.error(`scrollPageIntoView: "${t[1].name}" is not a valid destination type.`);
        return;
    }
    if (i || (b && b !== this._currentScale ? this.currentScaleValue = b : this._currentScale === Lu && (this.currentScaleValue = PE)), b === "page-fit" && !t[4]) {
      m(this, Y, Nd).call(this, n);
      return;
    }
    const E = [n.viewport.convertToViewportPoint(r, a), n.viewport.convertToViewportPoint(r + h, a + c)];
    let A = Math.min(E[0][0], E[1][0]), w = Math.min(E[0][1], E[1][1]);
    s || (A = Math.max(A, 0), w = Math.max(w, 0)), m(this, Y, Nd).call(this, n, {
      left: A,
      top: w
    });
  }
  _updateLocation(e) {
    const t = this._currentScale, s = this._currentScaleValue, i = parseFloat(s) === t ? Math.round(t * 1e4) / 100 : s, n = e.id, r = this._pages[n - 1], a = this.container, h = r.getPagePoint(a.scrollLeft - e.x, a.scrollTop - e.y), c = Math.round(h[0]), d = Math.round(h[1]);
    let u = `#page=${n}`;
    this.isInPresentationMode || (u += `&zoom=${i},${c},${d}`), this._location = {
      pageNumber: n,
      scale: i,
      top: d,
      left: c,
      rotation: this._pagesRotation,
      pdfOpenParams: u
    };
  }
  update() {
    const e = this._getVisiblePages(), t = e.views, s = t.length;
    if (s === 0)
      return;
    const i = Math.max(am, 2 * s + 1);
    o(this, Fn).resize(i, e.ids), this.renderingQueue.renderHighestPriority(e);
    const n = this._spreadMode === be.NONE && (this._scrollMode === ct.PAGE || this._scrollMode === ct.VERTICAL), r = this._currentPageNumber;
    let a = !1;
    for (const h of t) {
      if (h.percent < 100)
        break;
      if (h.id === r && n) {
        a = !0;
        break;
      }
    }
    this._setCurrentPageNumber(a ? r : t[0].id), this._updateLocation(e.first), this.eventBus.dispatch("updateviewarea", {
      source: this,
      location: this._location
    });
  }
  containsElement(e) {
    return this.container.contains(e);
  }
  focus() {
    this.container.focus();
  }
  get _isContainerRtl() {
    return getComputedStyle(this.container).direction === "rtl";
  }
  get isInPresentationMode() {
    return this.presentationModeState === Oa.FULLSCREEN;
  }
  get isChangingPresentationMode() {
    return this.presentationModeState === Oa.CHANGING;
  }
  get isHorizontalScrollbarEnabled() {
    return this.isInPresentationMode ? !1 : this.container.scrollWidth > this.container.clientWidth;
  }
  get isVerticalScrollbarEnabled() {
    return this.isInPresentationMode ? !1 : this.container.scrollHeight > this.container.clientHeight;
  }
  _getVisiblePages() {
    const e = this._scrollMode === ct.PAGE ? o(this, fa).pages : this._pages, t = this._scrollMode === ct.HORIZONTAL, s = t && this._isContainerRtl;
    return _E({
      scrollEl: this.container,
      views: e,
      sortByVisibility: !0,
      horizontal: t,
      rtl: s
    });
  }
  cleanup() {
    for (const e of this._pages)
      e.renderingState !== Nt.FINISHED && e.reset();
  }
  _cancelRendering() {
    for (const e of this._pages)
      e.cancelRendering();
  }
  forceRendering(e) {
    const t = e || this._getVisiblePages(), s = m(this, Y, ny).call(this, t), i = this._spreadMode !== be.NONE && this._scrollMode !== ct.HORIZONTAL, n = this.renderingQueue.getHighestPriority(t, this._pages, s, i);
    return n ? (m(this, Y, iy).call(this, n).then(() => {
      this.renderingQueue.renderView(n);
    }), !0) : !1;
  }
  get hasEqualPageSizes() {
    const e = this._pages[0];
    for (let t = 1, s = this._pages.length; t < s; ++t) {
      const i = this._pages[t];
      if (i.width !== e.width || i.height !== e.height)
        return !1;
    }
    return !0;
  }
  getPagesOverview() {
    let e;
    return this._pages.map((t) => {
      const s = t.pdfPage.getViewport({
        scale: 1
      }), i = Ng(s);
      if (e === void 0)
        e = i;
      else if (this.enablePrintAutoRotate && i !== e)
        return {
          width: s.height,
          height: s.width,
          rotation: (s.rotation - 90) % 360
        };
      return {
        width: s.width,
        height: s.height,
        rotation: s.rotation
      };
    });
  }
  get optionalContentConfigPromise() {
    return this.pdfDocument ? this._optionalContentConfigPromise ? this._optionalContentConfigPromise : (console.error("optionalContentConfigPromise: Not initialized yet."), this.pdfDocument.getOptionalContentConfig({
      intent: "display"
    })) : Promise.resolve(null);
  }
  set optionalContentConfigPromise(e) {
    if (!(e instanceof Promise))
      throw new Error(`Invalid optionalContentConfigPromise: ${e}`);
    this.pdfDocument && this._optionalContentConfigPromise && (this._optionalContentConfigPromise = e, this.refresh(!1, {
      optionalContentConfigPromise: e
    }), this.eventBus.dispatch("optionalcontentconfigchanged", {
      source: this,
      promise: e
    }));
  }
  get scrollMode() {
    return this._scrollMode;
  }
  set scrollMode(e) {
    if (this._scrollMode !== e) {
      if (!OE(e))
        throw new Error(`Invalid scroll mode: ${e}`);
      this.pagesCount > Gc.FORCE_SCROLL_MODE_PAGE || (this._previousScrollMode = this._scrollMode, this._scrollMode = e, this.eventBus.dispatch("scrollmodechanged", {
        source: this,
        mode: e
      }), this._updateScrollMode(this._currentPageNumber));
    }
  }
  _updateScrollMode(e = null) {
    const t = this._scrollMode, s = this.viewer;
    s.classList.toggle("scrollHorizontal", t === ct.HORIZONTAL), s.classList.toggle("scrollWrapped", t === ct.WRAPPED), !(!this.pdfDocument || !e) && (t === ct.PAGE ? m(this, Y, Rl).call(this) : this._previousScrollMode === ct.PAGE && this._updateSpreadMode(), this._currentScaleValue && isNaN(this._currentScaleValue) && m(this, Y, Yi).call(this, this._currentScaleValue, {
      noScroll: !0
    }), this._setCurrentPageNumber(e, !0), this.update());
  }
  get spreadMode() {
    return this._spreadMode;
  }
  set spreadMode(e) {
    if (this._spreadMode !== e) {
      if (!NE(e))
        throw new Error(`Invalid spread mode: ${e}`);
      this._spreadMode = e, this.eventBus.dispatch("spreadmodechanged", {
        source: this,
        mode: e
      }), this._updateSpreadMode(this._currentPageNumber);
    }
  }
  _updateSpreadMode(e = null) {
    if (!this.pdfDocument)
      return;
    const t = this.viewer, s = this._pages;
    if (this._scrollMode === ct.PAGE)
      m(this, Y, Rl).call(this);
    else if (t.textContent = "", this._spreadMode === be.NONE)
      for (const i of this._pages)
        t.append(i.div);
    else {
      const i = this._spreadMode - 1;
      let n = null;
      for (let r = 0, a = s.length; r < a; ++r)
        n === null ? (n = document.createElement("div"), n.className = "spread", t.append(n)) : r % 2 === i && (n = n.cloneNode(!1), t.append(n)), n.append(s[r].div);
    }
    e && (this._currentScaleValue && isNaN(this._currentScaleValue) && m(this, Y, Yi).call(this, this._currentScaleValue, {
      noScroll: !0
    }), this._setCurrentPageNumber(e, !0), this.update());
  }
  _getPageAdvance(e, t = !1) {
    switch (this._scrollMode) {
      case ct.WRAPPED: {
        const {
          views: s
        } = this._getVisiblePages(), i = /* @__PURE__ */ new Map();
        for (const {
          id: n,
          y: r,
          percent: a,
          widthPercent: h
        } of s) {
          if (a === 0 || h < 100)
            continue;
          let c = i.get(r);
          c || i.set(r, c || (c = [])), c.push(n);
        }
        for (const n of i.values()) {
          const r = n.indexOf(e);
          if (r === -1)
            continue;
          const a = n.length;
          if (a === 1)
            break;
          if (t)
            for (let h = r - 1, c = 0; h >= c; h--) {
              const d = n[h], u = n[h + 1] - 1;
              if (d < u)
                return e - u;
            }
          else
            for (let h = r + 1, c = a; h < c; h++) {
              const d = n[h], u = n[h - 1] + 1;
              if (d > u)
                return u - e;
            }
          if (t) {
            const h = n[0];
            if (h < e)
              return e - h + 1;
          } else {
            const h = n[a - 1];
            if (h > e)
              return h - e + 1;
          }
          break;
        }
        break;
      }
      case ct.HORIZONTAL:
        break;
      case ct.PAGE:
      case ct.VERTICAL: {
        if (this._spreadMode === be.NONE)
          break;
        const s = this._spreadMode - 1;
        if (t && e % 2 !== s)
          break;
        if (!t && e % 2 === s)
          break;
        const {
          views: i
        } = this._getVisiblePages(), n = t ? e - 1 : e + 1;
        for (const {
          id: r,
          percent: a,
          widthPercent: h
        } of i)
          if (r === n) {
            if (a > 0 && h === 100)
              return 2;
            break;
          }
        break;
      }
    }
    return 1;
  }
  nextPage() {
    const e = this._currentPageNumber, t = this.pagesCount;
    if (e >= t)
      return !1;
    const s = this._getPageAdvance(e, !1) || 1;
    return this.currentPageNumber = Math.min(e + s, t), !0;
  }
  previousPage() {
    const e = this._currentPageNumber;
    if (e <= 1)
      return !1;
    const t = this._getPageAdvance(e, !0) || 1;
    return this.currentPageNumber = Math.max(e - t, 1), !0;
  }
  updateScale({
    drawingDelay: e,
    scaleFactor: t = null,
    steps: s = null,
    origin: i
  }) {
    if (s === null && t === null)
      throw new Error("Invalid updateScale options: either `steps` or `scaleFactor` must be provided.");
    if (!this.pdfDocument)
      return;
    let n = this._currentScale;
    if (t > 0 && t !== 1)
      n = Math.round(n * t * 100) / 100;
    else if (s) {
      const r = s > 0 ? Ig : 1 / Ig, a = s > 0 ? Math.ceil : Math.floor;
      s = Math.abs(s);
      do
        n = a((n * r).toFixed(2) * 10) / 10;
      while (--s > 0);
    }
    n = Math.max(CE, Math.min(RE, n)), m(this, Y, Yi).call(this, n, {
      noScroll: !1,
      drawingDelay: e,
      origin: i
    });
  }
  increaseScale(e = {}) {
    this.updateScale({
      ...e,
      steps: e.steps ?? 1
    });
  }
  decreaseScale(e = {}) {
    this.updateScale({
      ...e,
      steps: -(e.steps ?? 1)
    });
  }
  get containerTopLeft() {
    return o(this, Tc) || v(this, Tc, [this.container.offsetTop, this.container.offsetLeft]);
  }
  get annotationEditorMode() {
    return o(this, Ge) ? o(this, Ys) : je.DISABLE;
  }
  set annotationEditorMode({
    mode: e,
    editId: t = null,
    isFromKeyboard: s = !1
  }) {
    var r;
    if (!o(this, Ge))
      throw new Error("The AnnotationEditor is not enabled.");
    if (o(this, Ys) === e)
      return;
    if (!om(e))
      throw new Error(`Invalid AnnotationEditor mode: ${e}`);
    if (!this.pdfDocument)
      return;
    e === je.STAMP && ((r = o(this, ca)) == null || r.loadModel("altText"));
    const {
      eventBus: i
    } = this, n = () => {
      m(this, Y, Dd).call(this), v(this, Ys, e), o(this, Ge).updateMode(e, t, s), i.dispatch("annotationeditormodechanged", {
        source: this,
        mode: e
      });
    };
    if (e === je.NONE || o(this, Ys) === je.NONE) {
      const a = e !== je.NONE;
      a || this.pdfDocument.annotationStorage.resetModifiedIds();
      for (const c of this._pages)
        c.toggleEditingMode(a);
      const h = m(this, Y, sy).call(this);
      if (a && h) {
        m(this, Y, Dd).call(this), v(this, da, new AbortController());
        const c = AbortSignal.any([o(this, jn).signal, o(this, da).signal]);
        i._on("pagerendered", ({
          pageNumber: d
        }) => {
          h.delete(d), h.size === 0 && v(this, ua, setTimeout(n, 0));
        }, {
          signal: c
        });
        return;
      }
    }
    n();
  }
  refresh(e = !1, t = /* @__PURE__ */ Object.create(null)) {
    if (this.pdfDocument) {
      for (const s of this._pages)
        s.update(t);
      o(this, Hn) !== null && (clearTimeout(o(this, Hn)), v(this, Hn, null)), e || this.update();
    }
  }
}
Fn = new WeakMap(), xc = new WeakMap(), Sc = new WeakMap(), Ys = new WeakMap(), Ge = new WeakMap(), ha = new WeakMap(), Tc = new WeakMap(), Pc = new WeakMap(), Cc = new WeakMap(), Rc = new WeakMap(), Ic = new WeakMap(), Lc = new WeakMap(), jn = new WeakMap(), ca = new WeakMap(), da = new WeakMap(), ua = new WeakMap(), Go = new WeakMap(), Bn = new WeakMap(), Xo = new WeakMap(), Mc = new WeakMap(), Ko = new WeakMap(), fa = new WeakMap(), Hn = new WeakMap(), Yo = new WeakMap(), Y = new WeakSet(), Zb = function(e) {
  const t = {
    annotationEditorMode: o(this, Ys),
    annotationMode: o(this, ha),
    textLayerMode: o(this, Yo)
  };
  return e && (!e.includes(zc.COPY) && o(this, Yo) === Qs.ENABLE && (t.textLayerMode = Qs.ENABLE_PERMISSIONS), e.includes(zc.MODIFY_CONTENTS) || (t.annotationEditorMode = je.DISABLE), !e.includes(zc.MODIFY_ANNOTATIONS) && !e.includes(zc.FILL_INTERACTIVE_FORMS) && o(this, ha) === Fi.ENABLE_FORMS && (t.annotationMode = Fi.ENABLE)), t;
}, Jb = async function(e) {
  if (document.visibilityState === "hidden" || !this.container.offsetParent || this._getVisiblePages().views.length === 0)
    return;
  const t = Promise.withResolvers();
  function s() {
    document.visibilityState === "hidden" && t.resolve();
  }
  document.addEventListener("visibilitychange", s, {
    signal: e
  }), await Promise.race([this._onePageRenderedCapability.promise, t.promise]), document.removeEventListener("visibilitychange", s);
}, qb = function(e, t) {
  const s = document.getSelection(), {
    focusNode: i,
    anchorNode: n
  } = s;
  if (n && i && s.containsNode(o(this, Bn))) {
    if (o(this, Go) || e === Qs.ENABLE_PERMISSIONS) {
      t.preventDefault(), t.stopPropagation();
      return;
    }
    v(this, Go, !0);
    const {
      classList: r
    } = this.viewer;
    r.add("copyAll");
    const a = new AbortController();
    window.addEventListener("keydown", (h) => v(this, Xo, h.key === "Escape"), {
      signal: a.signal
    }), this.getAllText().then(async (h) => {
      h !== null && await navigator.clipboard.writeText(h);
    }).catch((h) => {
      console.warn(`Something goes wrong when extracting the text: ${h.message}`);
    }).finally(() => {
      v(this, Go, !1), v(this, Xo, !1), a.abort(), r.remove("copyAll");
    }), t.preventDefault(), t.stopPropagation();
  }
}, Rl = function() {
  if (this._scrollMode !== ct.PAGE)
    throw new Error("#ensurePageViewVisible: Invalid scrollMode value.");
  const e = this._currentPageNumber, t = o(this, fa), s = this.viewer;
  if (s.textContent = "", t.pages.length = 0, this._spreadMode === be.NONE && !this.isInPresentationMode) {
    const i = this._pages[e - 1];
    s.append(i.div), t.pages.push(i);
  } else {
    const i = /* @__PURE__ */ new Set(), n = this._spreadMode - 1;
    n === -1 ? i.add(e - 1) : e % 2 !== n ? (i.add(e - 1), i.add(e)) : (i.add(e - 2), i.add(e - 1));
    const r = document.createElement("div");
    if (r.className = "spread", this.isInPresentationMode) {
      const a = document.createElement("div");
      a.className = "dummyPage", r.append(a);
    }
    for (const a of i) {
      const h = this._pages[a];
      h && (r.append(h.div), t.pages.push(h));
    }
    s.append(r);
  }
  t.scrollDown = e >= t.previousPageNumber, t.previousPageNumber = e;
}, Nd = function(e, t = null) {
  const {
    div: s,
    id: i
  } = e;
  if (this._currentPageNumber !== i && this._setCurrentPageNumber(i), this._scrollMode === ct.PAGE && (m(this, Y, Rl).call(this), this.update()), !t && !this.isInPresentationMode) {
    const n = s.offsetLeft + s.clientLeft, r = n + s.clientWidth, {
      scrollLeft: a,
      clientWidth: h
    } = this.container;
    (this._scrollMode === ct.HORIZONTAL || n < a || r > a + h) && (t = {
      left: 0,
      top: 0
    });
  }
  pb(s, t), !this._currentScaleValue && this._location && (this._location = null);
}, ty = function(e) {
  return e === this._currentScale || Math.abs(e - this._currentScale) < 1e-15;
}, Np = function(e, t, {
  noScroll: s = !1,
  preset: i = !1,
  drawingDelay: n = -1,
  origin: r = null
}) {
  if (this._currentScaleValue = t.toString(), m(this, Y, ty).call(this, e)) {
    i && this.eventBus.dispatch("scalechanging", {
      source: this,
      scale: e,
      presetValue: t
    });
    return;
  }
  this.viewer.style.setProperty("--scale-factor", e * li.PDF_TO_CSS_UNITS);
  const a = n >= 0 && n < 1e3;
  this.refresh(!0, {
    scale: e,
    drawingDelay: a ? n : -1
  }), a && v(this, Hn, setTimeout(() => {
    v(this, Hn, null), this.refresh();
  }, n));
  const h = this._currentScale;
  if (this._currentScale = e, !s) {
    let c = this._currentPageNumber, d;
    if (this._location && !(this.isInPresentationMode || this.isChangingPresentationMode) && (c = this._location.pageNumber, d = [null, {
      name: "XYZ"
    }, this._location.left, this._location.top, null]), this.scrollPageIntoView({
      pageNumber: c,
      destArray: d,
      allowNegativeOffset: !0
    }), Array.isArray(r)) {
      const u = e / h - 1, [f, p] = this.containerTopLeft;
      this.container.scrollLeft += (r[0] - p) * u, this.container.scrollTop += (r[1] - f) * u;
    }
  }
  this.eventBus.dispatch("scalechanging", {
    source: this,
    scale: e,
    presetValue: i ? t : void 0
  }), this.defaultRenderingQueue && this.update();
}, ey = function() {
  return this._spreadMode !== be.NONE && this._scrollMode !== ct.HORIZONTAL ? 2 : 1;
}, Yi = function(e, t) {
  let s = parseFloat(e);
  if (s > 0)
    t.preset = !1, m(this, Y, Np).call(this, s, e, t);
  else {
    const i = this._pages[this._currentPageNumber - 1];
    if (!i)
      return;
    let n = Lg, r = Mg;
    this.isInPresentationMode ? (n = r = 4, this._spreadMode !== be.NONE && (n *= 2)) : this.removePageBorders ? n = r = 0 : this._scrollMode === ct.HORIZONTAL && ([n, r] = [r, n]);
    const a = (this.container.clientWidth - n) / i.width * i.scale / o(this, Y, ey), h = (this.container.clientHeight - r) / i.height * i.scale;
    switch (e) {
      case "page-actual":
        s = 1;
        break;
      case "page-width":
        s = a;
        break;
      case "page-height":
        s = h;
        break;
      case "page-fit":
        s = Math.min(a, h);
        break;
      case "auto":
        const c = Ng(i) ? a : Math.min(h, a);
        s = Math.min(IE, c);
        break;
      default:
        console.error(`#setScale: "${e}" is an unknown zoom value.`);
        return;
    }
    t.preset = !0, m(this, Y, Np).call(this, s, e, t);
  }
}, Dp = function() {
  const e = this._pages[this._currentPageNumber - 1];
  this.isInPresentationMode && m(this, Y, Yi).call(this, this._currentScaleValue, {
    noScroll: !0
  }), m(this, Y, Nd).call(this, e);
}, sy = function() {
  const e = this._getVisiblePages(), t = [], {
    ids: s,
    views: i
  } = e;
  for (const n of i) {
    const {
      view: r
    } = n;
    if (!r.hasEditableAnnotations()) {
      s.delete(r.id);
      continue;
    }
    t.push(n);
  }
  return t.length === 0 ? null : (this.renderingQueue.renderHighestPriority({
    first: t[0],
    last: t.at(-1),
    views: t,
    ids: s
  }), s);
}, iy = async function(e) {
  if (e.pdfPage)
    return e.pdfPage;
  try {
    const t = await this.pdfDocument.getPage(e.id);
    return e.pdfPage || e.setPdfPage(t), t;
  } catch (t) {
    return console.error("Unable to get page for page view", t), null;
  }
}, ny = function(e) {
  var t, s;
  if (((t = e.first) == null ? void 0 : t.id) === 1)
    return !0;
  if (((s = e.last) == null ? void 0 : s.id) === this.pagesCount)
    return !1;
  switch (this._scrollMode) {
    case ct.PAGE:
      return o(this, fa).scrollDown;
    case ct.HORIZONTAL:
      return this.scroll.right;
  }
  return this.scroll.down;
}, kp = function(e = this.container.clientHeight) {
  e !== o(this, Mc) && (v(this, Mc, e), DE.setProperty("--viewer-container-height", `${e}px`));
}, ry = function(e) {
  for (const t of e)
    if (t.target === this.container) {
      m(this, Y, kp).call(this, Math.floor(t.borderBoxSize[0].blockSize)), v(this, Tc, null);
      break;
    }
}, Dd = function() {
  var e;
  (e = o(this, da)) == null || e.abort(), v(this, da, null), o(this, ua) !== null && (clearTimeout(o(this, ua)), v(this, ua, null));
};
class O0 extends Qb {
  _resetView() {
    super._resetView(), this._scrollMode = ct.PAGE, this._spreadMode = be.NONE;
  }
  set scrollMode(e) {
  }
  _updateScrollMode() {
  }
  set spreadMode(e) {
  }
  _updateSpreadMode() {
  }
}
Lt.AnnotationLayerBuilder;
Lt.DownloadManager;
Lt.EventBus;
Lt.FindState;
Lt.GenericL10n;
Lt.LinkTarget;
Lt.PDFFindController;
Lt.PDFHistory;
var N0 = Lt.PDFLinkService;
Lt.PDFPageView;
Lt.PDFScriptingManager;
Lt.PDFSinglePageViewer;
Lt.PDFViewer;
Lt.ProgressBar;
Lt.RenderingStates;
Lt.ScrollMode;
Lt.SimpleLinkService;
Lt.SpreadMode;
Lt.StructTreeLayerBuilder;
Lt.TextLayerBuilder;
Lt.XfaLayerBuilder;
Lt.parseQueryString;
const D0 = ["id"], k0 = ["id"], F0 = /* @__PURE__ */ fm("canvas", null, null, -1), j0 = {
  key: 0,
  class: "textLayer"
}, B0 = {
  key: 1,
  class: "annotationLayer"
}, Nx = /* @__PURE__ */ cy({
  __name: "VuePdfEmbed",
  props: {
    annotationLayer: { type: Boolean },
    height: {},
    id: {},
    imageResourcesPath: {},
    page: {},
    rotation: { default: 0 },
    scale: { default: 1 },
    source: {},
    textLayer: { type: Boolean },
    width: {}
  },
  emits: ["internal-link-clicked", "loaded", "loading-failed", "password-requested", "progress", "rendered", "rendering-failed"],
  setup(l, { expose: e, emit: t }) {
    const s = l, i = Fd([]), n = dy([]), r = Fd(null);
    let a = null;
    const { doc: h } = TE({
      onError: (A) => {
        i.value = [], t("loading-failed", A);
      },
      onPasswordRequest({ callback: A, isWrongPassword: w }) {
        t("password-requested", { callback: A, isWrongPassword: w });
      },
      onProgress: (A) => {
        t("progress", A);
      },
      source: uy(s, "source")
    }), c = fy(() => {
      if (!h.value || !s.annotationLayer)
        return null;
      const A = new N0();
      return A.setDocument(h.value), A.setViewer({
        scrollPageIntoView: ({ pageNumber: w }) => {
          t("internal-link-clicked", w);
        }
      }), A;
    }), d = async (A) => {
      if (!h.value)
        return;
      const w = await h.value.getData(), x = await h.value.getMetadata(), P = (
        // @ts-expect-error: contentDispositionFilename is not typed
        A ?? x.contentDispositionFilename ?? ""
      );
      SE(w, P);
    }, u = (A) => {
      let w, x;
      return s.height && !s.width ? (x = s.height, w = x / A) : (w = s.width ?? r.value.clientWidth, x = w * A), [w, x];
    }, f = async (A = 300, w = "", x = !1) => {
      var S, I, _;
      if (!h.value)
        return;
      const P = A / 72, T = 96 / 72;
      let C, R, M;
      try {
        C = window.document.createElement("div"), C.style.display = "none", window.document.body.appendChild(C), R = await xE(C);
        const D = s.page && !x ? [s.page] : [...Array(h.value.numPages + 1).keys()].slice(1);
        await Promise.all(
          D.map(async (k, j) => {
            const H = await h.value.getPage(k), L = H.getViewport({
              scale: 1,
              rotation: 0
            });
            if (j === 0) {
              const pt = L.width * P / T, gt = L.height * P / T;
              wE(R, pt, gt);
            }
            const F = window.document.createElement("canvas");
            F.width = L.width * P, F.height = L.height * P, C.appendChild(F);
            const z = F.cloneNode();
            R.contentWindow.document.body.appendChild(z), await H.render({
              canvasContext: F.getContext("2d"),
              intent: "print",
              transform: [P, 0, 0, P, 0, 0],
              viewport: L
            }).promise, z.getContext("2d").drawImage(F, 0, 0);
          })
        ), w && (M = window.document.title, window.document.title = w), (S = R.contentWindow) == null || S.focus(), (I = R.contentWindow) == null || I.print();
      } finally {
        M && (window.document.title = M), Iu(C), (_ = C.parentNode) == null || _.removeChild(C);
      }
    }, p = async () => {
      if (!(!h.value || a != null && a.isAborted))
        try {
          i.value = s.page ? [s.page] : [...Array(h.value.numPages + 1).keys()].slice(1), n.value = Array(i.value.length).fill(1), await Promise.all(
            i.value.map(async (A, w) => {
              const x = await h.value.getPage(A);
              if (a != null && a.isAborted)
                return;
              const P = ((s.rotation % 90 === 0 ? s.rotation : 0) + x.rotate) % 360, [T, C, R] = Array.from(
                r.value.getElementsByClassName("vue-pdf-embed__page")[w].children
              ), M = !!(P / 90 % 2), S = x.view[2] - x.view[0], I = x.view[3] - x.view[1], [_, D] = u(
                M ? S / I : I / S
              ), k = `${Math.floor(_)}px`, j = `${Math.floor(D)}px`, L = _ / (M ? I : S), F = x.getViewport({
                scale: L,
                rotation: P
              });
              n.value[w] = L, T.style.display = "block", T.style.width = k, T.style.height = j;
              const z = [
                g(
                  x,
                  F.clone({
                    scale: F.scale * window.devicePixelRatio * s.scale
                  }),
                  T
                )
              ];
              return s.textLayer && z.push(
                E(
                  x,
                  F.clone({
                    dontFlip: !0
                  }),
                  C
                )
              ), s.annotationLayer && z.push(
                b(
                  x,
                  F.clone({
                    dontFlip: !0
                  }),
                  R || C
                )
              ), Promise.all(z);
            })
          ), a != null && a.isAborted || t("rendered");
        } catch (A) {
          i.value = [], n.value = [], a != null && a.isAborted || t("rendering-failed", A);
        }
    }, g = async (A, w, x) => {
      x.width = w.width, x.height = w.height, await A.render({
        canvasContext: x.getContext("2d"),
        viewport: w
      }).promise;
    }, b = async (A, w, x) => {
      Cg(x), new bE({
        accessibilityManager: null,
        annotationCanvasMap: null,
        annotationEditorUIManager: null,
        div: x,
        page: A,
        structTreeLayer: null,
        viewport: w
      }).render({
        annotations: await A.getAnnotations(),
        div: x,
        imageResourcesPath: s.imageResourcesPath,
        linkService: c.value,
        page: A,
        renderForms: !1,
        viewport: w
      });
    }, E = async (A, w, x) => {
      Cg(x), new AE({
        container: x,
        textContentSource: await A.getTextContent(),
        viewport: w
      }).render();
    };
    return Bu(
      h,
      (A) => {
        A && t("loaded", A);
      },
      { immediate: !0 }
    ), Bu(
      () => [
        h.value,
        s.annotationLayer,
        s.height,
        s.imageResourcesPath,
        s.page,
        s.rotation,
        s.scale,
        s.textLayer,
        s.width
      ],
      async ([A]) => {
        A && (a && (a.isAborted = !0, await a.promise), Iu(r.value), a = {
          isAborted: !1,
          promise: p()
        }, await a.promise, a = null);
      },
      { immediate: !0 }
    ), um(() => {
      Iu(r.value);
    }), e({
      doc: h,
      download: d,
      print: f
    }), (A, w) => (el(), sl("div", {
      id: A.id,
      ref_key: "root",
      ref: r,
      class: "vue-pdf-embed"
    }, [
      (el(!0), sl(py, null, gy(i.value, (x, P) => (el(), sl("div", { key: x }, [
        ng(A.$slots, "before-page", { page: x }),
        fm("div", {
          id: A.id && `${A.id}-${x}`,
          class: "vue-pdf-embed__page",
          style: my({
            "--scale-factor": n.value[P],
            position: "relative"
          })
        }, [
          F0,
          A.textLayer ? (el(), sl("div", j0)) : rg("", !0),
          A.annotationLayer ? (el(), sl("div", B0)) : rg("", !0)
        ], 12, k0),
        ng(A.$slots, "after-page", { page: x })
      ]))), 128))
    ], 8, D0));
  }
}), H0 = {}, ol = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, default: H0 }, Symbol.toStringTag, { value: "Module" }));
var ll = {
  a: 7,
  c: 6,
  h: 1,
  l: 2,
  m: 2,
  q: 4,
  s: 4,
  t: 2,
  v: 1,
  z: 0
}, $0 = /([astvzqmhlc])([^astvzqmhlc]*)/gi, V0 = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/gi;
function U0(l) {
  const e = l.match(V0);
  return e ? e.map(Number) : [];
}
function ay(l) {
  const e = [], t = String(l).trim();
  return t[0] !== "M" && t[0] !== "m" || t.replace($0, (s, i, n) => {
    const r = U0(n);
    let a = i.toLowerCase(), h = i;
    if (a === "m" && r.length > 2 && (e.push([h, ...r.splice(0, 2)]), a = "l", h = h === "m" ? "l" : "L"), r.length < ll[a])
      return "";
    for (e.push([h, ...r.splice(0, ll[a])]); r.length >= ll[a] && r.length && ll[a]; )
      e.push([h, ...r.splice(0, ll[a])]);
    return "";
  }), e;
}
function lm(l, e) {
  const t = l.x * Math.cos(e) - l.y * Math.sin(e), s = l.y * Math.cos(e) + l.x * Math.sin(e);
  l.x = t, l.y = s;
}
function z0(l, e, t) {
  l.x += e, l.y += t;
}
function hm(l, e) {
  l.x *= e, l.y *= e;
}
var kd = class Fp {
  constructor(e) {
    this.commands = [], e && e instanceof Fp ? this.commands.push(...e.commands) : e && (this.commands = ay(e));
  }
  addPath(e) {
    e && e instanceof Fp && this.commands.push(...e.commands);
  }
  moveTo(e, t) {
    this.commands.push(["M", e, t]);
  }
  lineTo(e, t) {
    this.commands.push(["L", e, t]);
  }
  arc(e, t, s, i, n, r) {
    this.commands.push(["AC", e, t, s, i, n, !!r]);
  }
  arcTo(e, t, s, i, n) {
    this.commands.push(["AT", e, t, s, i, n]);
  }
  ellipse(e, t, s, i, n, r, a, h) {
    this.commands.push(["E", e, t, s, i, n, r, a, !!h]);
  }
  closePath() {
    this.commands.push(["Z"]);
  }
  bezierCurveTo(e, t, s, i, n, r) {
    this.commands.push(["C", e, t, s, i, n, r]);
  }
  quadraticCurveTo(e, t, s, i) {
    this.commands.push(["Q", e, t, s, i]);
  }
  rect(e, t, s, i) {
    this.commands.push(["R", e, t, s, i]);
  }
  roundRect(e, t, s, i, n) {
    typeof n > "u" ? this.commands.push(["RR", e, t, s, i, 0]) : this.commands.push(["RR", e, t, s, i, n]);
  }
};
function Il(l, e) {
  let t = 0, s = 0, i, n, r, a, h, c, d, u, f, p, g, b, E, A, w, x, P, T, C, R, M, S = null, I = null, _ = null, D = null, k = null, j = null;
  l.beginPath();
  for (let H = 0; H < e.length; ++H) {
    T = e[H][0], T !== "S" && T !== "s" && T !== "C" && T !== "c" && (S = null, I = null), T !== "T" && T !== "t" && T !== "Q" && T !== "q" && (_ = null, D = null);
    let L;
    switch (T) {
      case "m":
      case "M":
        L = e[H], T === "m" ? (t += L[1], s += L[2]) : (t = L[1], s = L[2]), (T === "M" || !k) && (k = { x: t, y: s }), l.moveTo(t, s);
        break;
      case "l":
        L = e[H], t += L[1], s += L[2], l.lineTo(t, s);
        break;
      case "L":
        L = e[H], t = L[1], s = L[2], l.lineTo(t, s);
        break;
      case "H":
        L = e[H], t = L[1], l.lineTo(t, s);
        break;
      case "h":
        L = e[H], t += L[1], l.lineTo(t, s);
        break;
      case "V":
        L = e[H], s = L[1], l.lineTo(t, s);
        break;
      case "v":
        L = e[H], s += L[1], l.lineTo(t, s);
        break;
      case "a":
      case "A":
        if (L = e[H], j === null)
          throw new Error("This should never happen");
        T === "a" ? (t += L[6], s += L[7]) : (t = L[6], s = L[7]), A = L[1], w = L[2], d = L[3] * Math.PI / 180, r = !!L[4], a = !!L[5], h = { x: t, y: s }, c = {
          x: (j.x - h.x) / 2,
          y: (j.y - h.y) / 2
        }, lm(c, -d), u = c.x * c.x / (A * A) + c.y * c.y / (w * w), u > 1 && (u = Math.sqrt(u), A *= u, w *= u), C = {
          x: A * c.y / w,
          y: -(w * c.x) / A
        }, f = A * A * w * w, p = A * A * c.y * c.y + w * w * c.x * c.x, a !== r ? hm(C, Math.sqrt((f - p) / p) || 0) : hm(C, -Math.sqrt((f - p) / p) || 0), n = Math.atan2((c.y - C.y) / w, (c.x - C.x) / A), i = Math.atan2(-(c.y + C.y) / w, -(c.x + C.x) / A), lm(C, d), z0(C, (h.x + j.x) / 2, (h.y + j.y) / 2), l.save(), l.translate(C.x, C.y), l.rotate(d), l.scale(A, w), l.arc(0, 0, 1, n, i, !a), l.restore();
        break;
      case "C":
        L = e[H], S = L[3], I = L[4], t = L[5], s = L[6], l.bezierCurveTo(L[1], L[2], S, I, t, s);
        break;
      case "c":
        L = e[H], l.bezierCurveTo(L[1] + t, L[2] + s, L[3] + t, L[4] + s, L[5] + t, L[6] + s), S = L[3] + t, I = L[4] + s, t += L[5], s += L[6];
        break;
      case "S":
        L = e[H], (S === null || I === null) && (S = t, I = s), l.bezierCurveTo(2 * t - S, 2 * s - I, L[1], L[2], L[3], L[4]), S = L[1], I = L[2], t = L[3], s = L[4];
        break;
      case "s":
        L = e[H], (S === null || I === null) && (S = t, I = s), l.bezierCurveTo(2 * t - S, 2 * s - I, L[1] + t, L[2] + s, L[3] + t, L[4] + s), S = L[1] + t, I = L[2] + s, t += L[3], s += L[4];
        break;
      case "Q":
        L = e[H], _ = L[1], D = L[2], t = L[3], s = L[4], l.quadraticCurveTo(_, D, t, s);
        break;
      case "q":
        L = e[H], _ = L[1] + t, D = L[2] + s, t += L[3], s += L[4], l.quadraticCurveTo(_, D, t, s);
        break;
      case "T":
        L = e[H], (_ === null || D === null) && (_ = t, D = s), _ = 2 * t - _, D = 2 * s - D, t = L[1], s = L[2], l.quadraticCurveTo(_, D, t, s);
        break;
      case "t":
        L = e[H], (_ === null || D === null) && (_ = t, D = s), _ = 2 * t - _, D = 2 * s - D, t += L[1], s += L[2], l.quadraticCurveTo(_, D, t, s);
        break;
      case "z":
      case "Z":
        k && (t = k.x, s = k.y), k = null, l.closePath();
        break;
      case "AC":
        L = e[H], t = L[1], s = L[2], E = L[3], n = L[4], i = L[5], R = L[6], l.arc(t, s, E, n, i, R);
        break;
      case "AT":
        L = e[H], g = L[1], b = L[2], t = L[3], s = L[4], E = L[5], l.arcTo(g, b, t, s, E);
        break;
      case "E":
        L = e[H], t = L[1], s = L[2], A = L[3], w = L[4], d = L[5], n = L[6], i = L[7], R = L[8], l.save(), l.translate(t, s), l.rotate(d), l.scale(A, w), l.arc(0, 0, 1, n, i, R), l.restore();
        break;
      case "R":
        L = e[H], t = L[1], s = L[2], x = L[3], P = L[4], k = { x: t, y: s }, l.rect(t, s, x, P);
        break;
      case "RR":
        L = e[H], t = L[1], s = L[2], x = L[3], P = L[4], M = L[5], k = { x: t, y: s }, l.roundRect(t, s, x, P, M);
        break;
      default:
        throw new Error(`Invalid path command: ${T}`);
    }
    j ? (j.x = t, j.y = s) : j = { x: t, y: s };
  }
}
function Jp(l, e, t, s, i = 0) {
  if (typeof i == "number" && (i = [i]), Array.isArray(i)) {
    if (i.length === 0 || i.length > 4)
      throw new RangeError(
        `Failed to execute 'roundRect' on '${this.constructor.name}': ${i.length} radii provided. Between one and four radii are necessary.`
      );
    i.forEach((d) => {
      if (d < 0)
        throw new RangeError(
          `Failed to execute 'roundRect' on '${this.constructor.name}': Radius value ${d} is negative.`
        );
    });
  } else
    return;
  if (i.length === 1 && i[0] === 0) {
    this.rect(l, e, t, s);
    return;
  }
  const n = Math.min(t, s) / 2, r = Math.min(n, i[0]);
  let a = r, h = r, c = r;
  i.length === 2 && (a = Math.min(n, i[1]), c = a), i.length === 3 && (a = Math.min(n, i[1]), c = a, h = Math.min(n, i[2])), i.length === 4 && (a = Math.min(n, i[1]), h = Math.min(n, i[2]), c = Math.min(n, i[3])), this.moveTo(l, e + s - c), this.arcTo(l, e, l + r, e, r), this.arcTo(l + t, e, l + t, e + a, a), this.arcTo(l + t, e + s, l + t - h, e + s, h), this.arcTo(l, e + s, l, e + s - c, c), this.moveTo(l, e);
}
function W0(l) {
  if (!l) return;
  const e = l.prototype.clip, t = l.prototype.fill, s = l.prototype.stroke, i = l.prototype.isPointInPath;
  l.prototype.clip = function(...r) {
    if (r[0] instanceof kd) {
      const h = r[0], c = r[1] || "nonzero";
      return Il(this, h.commands), e.apply(this, [c]);
    }
    const a = r[0] || "nonzero";
    return e.apply(this, [a]);
  }, l.prototype.fill = function(...r) {
    if (r[0] instanceof kd) {
      const h = r[0], c = r[1] || "nonzero";
      return Il(this, h.commands), t.apply(this, [c]);
    }
    const a = r[0] || "nonzero";
    return t.apply(this, [a]);
  }, l.prototype.stroke = function(r) {
    r && Il(this, r.commands), s.apply(this);
  }, l.prototype.isPointInPath = function(...r) {
    if (r[0] instanceof kd) {
      const a = r[0], h = r[1], c = r[2], d = r[3] || "nonzero";
      return Il(this, a.commands), i.apply(this, [h, c, d]);
    }
    return i.apply(this, r);
  };
}
function G0(l) {
  l && !l.prototype.roundRect && (l.prototype.roundRect = Jp);
}
function X0(l) {
  l && !l.prototype.roundRect && (l.prototype.roundRect = Jp);
}
const K0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, Path2D: kd, applyPath2DToCanvasRenderingContext: W0, applyRoundRectToCanvasRenderingContext2D: G0, applyRoundRectToPath2D: X0, buildPath: Il, parsePath: ay, roundRect: Jp }, Symbol.toStringTag, { value: "Module" }));
export {
  cx as GlobalWorkerOptions,
  Nx as default,
  TE as useVuePdfEmbed
};

function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
import PopupManager from "@opentiny/vue-renderless/common/deps/popup-manager";
import { addClass, getStyle, removeClass } from "@opentiny/vue-renderless/common/deps/dom";
import { defineComponent, $prefix, $setup, $props, createComponent, appProperties, hooks, directive as directive$1, setupComponent } from "@opentiny/vue-common";
import PcTemplate from "./pc.js";
import MobileTemplate from "./mobile.js";
import MobileFirstTemplate from "./mobile-first.js";
import afterLeave from "@opentiny/vue-renderless/common/deps/after-leave";
var template = function template2(mode) {
  var _process$env;
  var tinyMode = typeof process === "object" ? (_process$env = process.env) == null ? void 0 : _process$env.TINY_MODE : null;
  if ("pc" === (tinyMode || mode)) {
    return PcTemplate;
  }
  if ("mobile" === (tinyMode || mode)) {
    return MobileTemplate;
  }
  if ("mobile-first" === (tinyMode || mode)) {
    return MobileFirstTemplate;
  }
  return PcTemplate;
};
var loadingProps = _extends({}, $props, {
  type: {
    type: String,
    validator: function validator(value) {
      return Boolean(~["primary", "simple"].indexOf(value));
    }
  },
  loadtext: {
    type: String,
    default: function _default() {
      return constants.LOAD_ICON_TEXT;
    }
  },
  _constants: {
    type: Object,
    default: function _default2() {
      return constants;
    }
  },
  loadingImg: {
    type: String
  },
  size: {
    type: String,
    default: "small"
  }
});
var Loading = defineComponent({
  name: $prefix + "Loading",
  emits: [],
  props: loadingProps,
  setup: function setup(props, context) {
    return $setup({
      props,
      context,
      template
    });
  }
});
var defaults = {
  text: null,
  body: false,
  lock: false,
  customClass: "",
  fullscreen: true,
  iconSize: ""
};
var fullscreenLoading = null;
var constants = {
  TEXT_ATTR: "tiny-loading__text",
  IS_FULLSCREEN_CLS: "is-fullscreen",
  TEXT_SPINNER: "tiny-loading__spinner",
  TEXT_BACKGROUND: "tiny-loading__background",
  TEXT_CUSTOM_CLS: "tiny-loading__custom-class",
  PARENT_HIDDEN_CLS: "tiny-loading__parent-hidden",
  PARENT_RELATIVE_CLS: "tiny-loading__parent-relative",
  LOAD_ICON_TEXT: "ui.load.dot"
};
var addStyle = function addStyle2(options, parent, instance) {
  var maskStyle = {};
  if (options.fullscreen) {
    instance.originalPosition = getStyle(document.body, "position");
    instance.originalOverflow = getStyle(document.body, "overflow");
    maskStyle.zIndex = PopupManager.nextZIndex();
  } else if (options.body) {
    var clientRect = options.target.getBoundingClientRect();
    instance.originalPosition = getStyle(document.body, "position");
    var direction = ["top", "left"];
    direction.forEach(function(property) {
      var scroll = property === "top" ? "scrollTop" : "scrollLeft";
      maskStyle[property] = clientRect[property] + document.body[scroll] + document.documentElement[scroll] + "px";
    });
    var size = ["height", "width"];
    size.forEach(function(property) {
      maskStyle[property] = clientRect[property] + "px";
    });
  } else {
    instance.originalPosition = getStyle(parent, "position");
  }
  Object.keys(maskStyle).forEach(function(property) {
    instance.$el.style[property] = maskStyle[property];
  });
};
var service = function service2(configs) {
  var _appProperties$tiny_m;
  if (configs === void 0) {
    configs = {};
  }
  configs = _extends({}, defaults, configs);
  if (typeof configs.target === "string") {
    configs.target = document.querySelector(configs.target);
  }
  configs.target = configs.target || document.body;
  if (configs.target !== document.body) {
    configs.fullscreen = false;
  } else {
    configs.body = true;
  }
  if (configs.fullscreen && fullscreenLoading && !fullscreenLoading.state.closed) {
    return fullscreenLoading;
  }
  var parent = configs.body ? document.body : configs.target;
  var loadingEl = parent.querySelector(':scope > [data-tag="tiny-loading"]');
  loadingEl && parent.removeChild(loadingEl);
  var instance = createComponent({
    component: Loading,
    propsData: {
      _constants: constants,
      size: configs.size,
      loadingImg: configs.loadingImg,
      tiny_mode: configs.tiny_mode || ((_appProperties$tiny_m = appProperties().tiny_mode) == null ? void 0 : _appProperties$tiny_m.value)
    },
    el: document.createElement("div")
  });
  for (var key in configs) {
    if (Object.prototype.hasOwnProperty.call(configs, key)) {
      instance.state[key] = configs[key];
    }
  }
  addStyle(configs, parent, instance);
  if (instance.originalPosition !== "absolute" && instance.originalPosition !== "fixed") {
    addClass(parent, constants.PARENT_RELATIVE_CLS);
  }
  if (configs.fullscreen && configs.lock) {
    addClass(parent, constants.PARENT_HIDDEN_CLS);
  }
  parent.appendChild(instance.$el);
  hooks.nextTick(function() {
    instance.state.visible = true;
  });
  if (configs.fullscreen) {
    fullscreenLoading = instance;
  }
  return instance;
};
var insertDom = function insertDom2(parent, el, binding) {
  if (!el.domVisible && getStyle(el, "display") !== "none" && getStyle(el, "visibility") !== "hidden") {
    Object.keys(el.maskStyle).forEach(function(property) {
      el.mask.style[property] = el.maskStyle[property];
    });
    if (el.originalPosition !== "absolute" && el.originalPosition !== "fixed") {
      addClass(parent, constants.PARENT_RELATIVE_CLS);
    }
    if (binding.modifiers.fullscreen && binding.modifiers.lock) {
      addClass(parent, constants.PARENT_HIDDEN_CLS);
    }
    el.domVisible = true;
    parent.appendChild(el.mask);
    hooks.nextTick(function() {
      if (el.instance.hiding) {
        el.instance.$emit("after-leave");
      } else {
        el.instance.state.visible = true;
      }
    });
    el.domInserted = true;
  } else if (el.domVisible && el.instance.hiding === true) {
    el.instance.state.visible = true;
    el.instance.hiding = false;
  }
};
var appendLoadingToBody = function appendLoadingToBody2(el, binding) {
  var clientRect = el.getBoundingClientRect();
  el.originalPosition = getStyle(document.body, "position");
  var direction = ["top", "left"];
  direction.forEach(function(property) {
    var scroll = property === "top" ? "scrollTop" : "scrollLeft";
    el.maskStyle[property] = clientRect[property] + document.body[scroll] + document.documentElement[scroll] - parseInt(getStyle(document.body, "margin-" + property), 10) + "px";
  });
  var size = ["height", "width"];
  size.forEach(function(property) {
    el.maskStyle[property] = clientRect[property] + "px";
  });
  insertDom(document.body, el, binding);
};
var toggleLoading = function toggleLoading2(el, binding, maskInstance) {
  if (binding.value) {
    hooks.nextTick(function() {
      if (binding.modifiers.fullscreen) {
        el.originalPosition = getStyle(document.body, "position");
        el.originalOverflow = getStyle(document.body, "overflow");
        el.maskStyle.zIndex = PopupManager.nextZIndex();
        addClass(el.mask, constants.IS_FULLSCREEN_CLS);
        insertDom(document.body, el, binding);
      } else {
        removeClass(el.mask, constants.IS_FULLSCREEN_CLS);
        if (binding.modifiers.body) {
          appendLoadingToBody(el, binding);
        } else {
          el.originalPosition = getStyle(el, "position");
          insertDom(el, el, binding);
        }
      }
    });
  } else {
    afterLeave(maskInstance, function() {
      if (!maskInstance.hiding) {
        return;
      }
      var target = binding.modifiers.fullscreen || binding.modifiers.body ? document.body : el;
      el.domVisible = false;
      removeClass(target, constants.PARENT_RELATIVE_CLS);
      removeClass(target, constants.PARENT_HIDDEN_CLS);
      maskInstance.hiding = false;
    }, 300, true);
    maskInstance.state.visible = false;
    maskInstance.hiding = true;
  }
};
var vLoading = {
  bind: function bind(el, binding, vnode) {
    var _vm$tiny_mode, _appProperties$tiny_m2;
    var vm = vnode.context;
    var textExr = el.getAttribute(constants.TEXT_ATTR);
    var spinnerExr = el.getAttribute(constants.TEXT_SPINNER);
    var backgroundExr = el.getAttribute(constants.TEXT_BACKGROUND);
    var customClassExr = el.getAttribute(constants.TEXT_CUSTOM_CLS);
    var mask = createComponent({
      component: Loading,
      propsData: {
        _constants: constants,
        tiny_mode: ((_vm$tiny_mode = vm.tiny_mode) == null ? void 0 : _vm$tiny_mode.value) || ((_appProperties$tiny_m2 = appProperties().tiny_mode) == null ? void 0 : _appProperties$tiny_m2.value)
      },
      el: document.createElement("div")
    });
    var config = _extends({}, defaults, {
      text: vm && vm[textExr] || textExr,
      spinner: vm && vm[spinnerExr] || spinnerExr,
      background: vm && vm[backgroundExr] || backgroundExr,
      customClass: vm && vm[customClassExr] || customClassExr,
      fullscreen: !!binding.modifiers.fullscreen
    });
    for (var key in config) {
      if (Object.prototype.hasOwnProperty.call(config, key)) {
        mask.state[key] = config[key];
      }
    }
    el.instance = mask;
    el.mask = mask.$el;
    el.maskStyle = {};
    binding.value && toggleLoading(el, binding, mask);
  },
  update: function update(el, binding) {
    el.instance.setText(el.getAttribute(constants.TEXT_ATTR));
    if (binding.oldValue !== binding.value) {
      toggleLoading(el, binding, el.instance);
    }
  },
  unbind: function unbind(el, binding) {
    if (el.domInserted) {
      el.mask && el.mask.parentNode && el.mask.parentNode.removeChild(el.mask);
      toggleLoading(el, {
        value: false,
        modifiers: binding.modifiers
      }, el.instance);
    }
    if (el.instance) {
      typeof el.instance.$destroy === "function" && el.instance.$destroy();
      el.instance = null;
      el.mask = null;
    }
  }
};
var directive = directive$1({
  vLoading
}).vLoading;
var version = "3.20.0";
var Loadings = {
  install: function install(app) {
    app.directive("loading", directive);
  },
  service,
  directive,
  version
};
setupComponent.TINYLoading = {
  init: function init(root) {
    var prefix = root.$apiPrefix || "$";
    root[prefix + "loading"] = service;
  }
};
export {
  Loadings as default
};

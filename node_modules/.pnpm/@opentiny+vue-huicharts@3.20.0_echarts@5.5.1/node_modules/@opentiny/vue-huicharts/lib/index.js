import Core, { deepCopy, isDefined, getFormatted, itemPoint, itemLabel, itemContent, cloneDeep, getRows, getTooltip as getTooltip$d, getStackMap as getStackMap$1, isNull as isNull$1, get, set, getYAxis as getYAxis$2, htmlHandler, isObject, getMapJSON, HEAT_MAP_COLOR } from '@opentiny/vue-huicharts-core';
import { t } from '@opentiny/vue-locale';
import { $prefix, defineComponent, h } from '@opentiny/vue-common';
import { openBlock, createElementBlock, createElementVNode, normalizeStyle, renderSlot } from 'vue';
import * as echarts from 'echarts';
import 'echarts/extension/bmap/bmap';
import { prepareBoxplotData } from 'echarts/extension/dataTool';
import 'echarts-liquidfill';
import 'echarts-wordcloud';

function _createForOfIteratorHelperLoose(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (t)
    return (t = t.call(r)).next.bind(t);
  if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
    t && (r = t);
    var o = 0;
    return function() {
      return o >= r.length ? { done: true } : { done: false, value: r[o++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r)
      return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++)
    n[e] = r[e];
  return n;
}
var _export_sfc = function _export_sfc2(sfc, props) {
  var target = sfc.__vccOpts || sfc;
  for (var _iterator = _createForOfIteratorHelperLoose(props), _step; !(_step = _iterator()).done; ) {
    var _step$value = _step.value, key = _step$value[0], val = _step$value[1];
    target[key] = val;
  }
  return target;
};

function _extends$i() {
  return _extends$i = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t2 = arguments[e];
      for (var r in t2)
        ({}).hasOwnProperty.call(t2, r) && (n[r] = t2[r]);
    }
    return n;
  }, _extends$i.apply(null, arguments);
}
var PIE_RADIUS$1 = 100;
var RING_RADIUS$1 = [90, 100];
var ROSE_RING_RADIUS$1 = [20, 100];
var PIE_OFFSET$1 = "50%";
var getTooltip$c = function getTooltip2(args) {
  var dataType = args.dataType, digit = args.digit, dimension = args.dimension, innerRows = args.innerRows, limitShowNum = args.limitShowNum, metrics = args.metrics, t2 = args.t;
  var _ref = {}, _ref$localeOther = _ref.localeOther, localeOther = _ref$localeOther === void 0 ? t2("ui.chart.other") : _ref$localeOther, remainArr = _ref.remainArr, _ref$sum = _ref.sum, sum = _ref$sum === void 0 ? 0 : _ref$sum;
  var mapHandler = function mapHandler2(row) {
    sum += row[metrics];
    return {
      name: row[dimension],
      value: row[metrics]
    };
  };
  remainArr = innerRows.map(mapHandler).slice(limitShowNum, innerRows.length);
  var formatter = function formatter2(item) {
    var tplt = [itemPoint(item.color)];
    var percent;
    if (!limitShowNum || item.name !== localeOther) {
      tplt.push(itemLabel(item.name));
      tplt.push(itemContent(getFormatted(item.value, dataType, digit)));
      tplt.push(itemContent("(" + item.percent + "%)"));
    } else {
      tplt.push(localeOther + ":");
      remainArr.forEach(function(_ref2) {
        var name = _ref2.name, value = _ref2.value;
        percent = "(" + getFormatted(value / sum, "percent") + ")";
        tplt.push("<br>" + itemLabel(name));
        tplt.push(itemContent(getFormatted(value, dataType, digit)));
        tplt.push(itemContent(percent));
      });
    }
    return tplt.join("");
  };
  return formatter;
};
var getLabel$1 = function getLabel2(args) {
  var label = args.label, labelLine = args.labelLine, percentShow = args.percentShow, dataType = args.dataType, digit = args.digit;
  var labelObj = {};
  if (label) {
    if (isDefined(label.show)) {
      labelObj.show = label.show;
    }
    if (isDefined(label.formatter)) {
      labelObj.labelHtml = label.formatter;
    }
  }
  if (percentShow) {
    labelObj.labelHtml = function(params) {
      var tplt = [];
      tplt.push(params.name + ":");
      tplt.push(getFormatted(params.value, dataType, digit));
      tplt.push("(" + params.percent + "%)");
      return tplt.join("");
    };
  }
  if (labelLine) {
    if (isDefined(labelLine.show)) {
      labelObj.line = labelLine.show;
    }
    var color;
    if (labelLine && labelLine.lineStyle) {
      color = labelLine.lineStyle.color;
    }
    if (isDefined(color)) {
      labelObj.lineColor = color;
    }
    if (isDefined(labelLine.length)) {
      labelObj.distance = labelLine.length;
    }
  }
  return labelObj;
};
var getPosition$1 = function getPosition2(args) {
  var radius = args.radius, offsetY = args.offsetY, level = args.level;
  var position = {};
  if (isDefined(offsetY)) {
    position.center = [PIE_OFFSET$1, offsetY];
  }
  if (Array.isArray(radius)) {
    position.radius = radius;
  } else if (!level || level.length === 0) {
    position.radius = [0, radius];
  }
  return position;
};
var getInnerData$1 = function getInnerData2(args) {
  var dimension = args.dimension, metrics = args.metrics, innerRows = args.innerRows;
  return innerRows.map(function(row) {
    return {
      name: row[dimension],
      value: row[metrics]
    };
  });
};
var getDataOrSeries$1 = function getDataOrSeries2(args) {
  var innerData = args.innerData, isRing = args.isRing, radius = args.radius, level = args.level, limitShowNum = args.limitShowNum, t2 = args.t;
  var series;
  var getLimitData = function getLimitData2(data2) {
    var tempData = data2;
    if (limitShowNum && limitShowNum < tempData.length) {
      var remainArr = tempData.slice(limitShowNum, innerData.length);
      var sum = remainArr.reduce(function(a, c) {
        return a + c.value;
      }, 0);
      tempData.splice(limitShowNum, Infinity, {
        name: t2("ui.chart.other"),
        value: sum
      });
    }
    return tempData;
  };
  var levelFlag = level && level.length;
  if (levelFlag) {
    var levelObj = {};
    var maxLevel = 0;
    var levelData = [];
    level.forEach(function(levelItems, index) {
      levelItems.forEach(function(item) {
        if (levelObj[item] === void 0) {
          levelObj[item] = [index];
        } else {
          levelObj[item].push(index);
        }
        if (maxLevel < index + 1) {
          maxLevel = index + 1;
        }
      });
    });
    levelData = Array.from({
      length: maxLevel
    }, function() {
      return [];
    });
    innerData.forEach(function(data2) {
      Array.isArray(levelObj[data2.name]) && levelObj[data2.name].forEach(function(levelIdx) {
        levelData[levelIdx].push(_extends$i({}, data2));
      });
    });
    var rowsCount = levelData.length;
    var centerWidth = radius / rowsCount;
    series = levelData.map(function(data2, index) {
      var itemRadius;
      if (index === 0) {
        itemRadius = isRing ? radius : centerWidth;
      } else {
        var outerWidth = centerWidth + radius / (2 * rowsCount) * (2 * index - 1);
        var innerWidth = outerWidth + radius / (2 * rowsCount);
        itemRadius = [outerWidth, innerWidth];
      }
      return {
        name: "PIE-" + index,
        type: "pie",
        radius: itemRadius,
        data: getLimitData(data2)
      };
    });
  }
  return levelFlag ? {
    series
  } : {
    data: getLimitData(innerData)
  };
};
var getLegend$6 = function getLegend2(args) {
  var dimension = args.dimension, innerRows = args.innerRows, legendVisible = args.legendVisible, legendLimit = args.legendLimit, level = args.level, limitShowNum = args.limitShowNum, innerData = args.innerData;
  if (!legendVisible) {
    return {
      show: false
    };
  }
  var _ref3 = {}, _ref3$legend = _ref3.legend, legend = _ref3$legend === void 0 ? [] : _ref3$legend, _ref3$levelTemp = _ref3.levelTemp, levelTemp = _ref3$levelTemp === void 0 ? [] : _ref3$levelTemp;
  if (level) {
    level.forEach(function(levelItem) {
      return levelItem.forEach(function(item) {
        return levelTemp.push(item);
      });
    });
    legend = levelTemp;
  } else if (limitShowNum && limitShowNum < innerRows.length) {
    for (var i = limitShowNum - 1; i >= 0; i--) {
      legend.unshift(innerRows[i][dimension]);
    }
  } else {
    legend = innerRows.map(function(row) {
      return row[dimension];
    });
  }
  var show = false;
  if (legend.length) {
    show = legend.length < legendLimit;
  }
  if (level && level.length) {
    return {
      show,
      data: innerData
    };
  }
  return {
    show
  };
};
var pie$1 = function pie2(columns, rows, settings, extra, isRing) {
  var innerRows = deepCopy(rows);
  var _settings$dataType = settings.dataType, dataType = _settings$dataType === void 0 ? "normal" : _settings$dataType, _settings$digit = settings.digit, digit = _settings$digit === void 0 ? 2 : _settings$digit, _settings$dimension = settings.dimension, dimension = _settings$dimension === void 0 ? columns[0] : _settings$dimension, emphasis = settings.emphasis;
  var itemStyle = settings.itemStyle, _settings$label = settings.label, label = _settings$label === void 0 ? false : _settings$label, labelLine = settings.labelLine, _settings$legendLimit = settings.legendLimit, legendLimit = _settings$legendLimit === void 0 ? 30 : _settings$legendLimit; settings.legendName; var _settings$level = settings.level, level = _settings$level === void 0 ? false : _settings$level;
  var _settings$limitShowNu = settings.limitShowNum, limitShowNum = _settings$limitShowNu === void 0 ? 0 : _settings$limitShowNu, _settings$metrics = settings.metrics, metrics = _settings$metrics === void 0 ? columns[1] : _settings$metrics, _settings$offsetY = settings.offsetY, offsetY = _settings$offsetY === void 0 ? PIE_OFFSET$1 : _settings$offsetY, percentShow = settings.percentShow;
  var _settings$roseType = settings.roseType, roseType = _settings$roseType === void 0 ? false : _settings$roseType, _settings$selectedMod = settings.selectedMode, selectedMode = _settings$selectedMod === void 0 ? false : _settings$selectedMod, hoverAnimation = settings.hoverAnimation;
  var _settings$radius = settings.radius, radius = _settings$radius === void 0 ? isRing ? roseType ? ROSE_RING_RADIUS$1 : RING_RADIUS$1 : PIE_RADIUS$1 : _settings$radius;
  var legendVisible = extra.legendVisible, tooltipVisible = extra.tooltipVisible, t2 = extra.t;
  limitShowNum && innerRows.sort(function(a, b) {
    return b[metrics] - a[metrics];
  });
  var innerData = getInnerData$1({
    dimension,
    metrics,
    innerRows
  });
  var type = isRing ? "circle" : "pie";
  var position = getPosition$1({
    radius,
    offsetY,
    level
  });
  var ichartLabel = getLabel$1({
    label,
    labelLine,
    percentShow,
    dataType,
    digit
  });
  var ichartLegend = getLegend$6({
    legendVisible,
    dimension,
    innerRows,
    legendLimit,
    level,
    limitShowNum
  });
  var dataOrSeries = getDataOrSeries$1({
    innerData,
    isRing,
    radius,
    level,
    limitShowNum,
    t: t2
  });
  var ichartOption = _extends$i({
    legend: ichartLegend,
    type,
    position,
    label: ichartLabel,
    itemStyle,
    emphasis: emphasis || {
      scale: hoverAnimation === void 0 ? true : hoverAnimation
    },
    roseType,
    selectedMode
  }, dataOrSeries);
  if (tooltipVisible) {
    var tipHtml = getTooltip$c({
      dataType,
      innerRows,
      limitShowNum,
      digit,
      metrics,
      dimension,
      t: t2
    });
    ichartOption.tipHtml = tipHtml;
  } else {
    ichartOption.tooltip = {
      show: false
    };
  }
  var ichartExtend = {};
  if (label) {
    ichartExtend.label = label;
  }
  if (labelLine) {
    ichartExtend.labelLine = labelLine;
  }
  ichartOption.extend = _extends$i({}, ichartExtend);
  return ichartOption;
};
var _sfc_main$l = {
  name: $prefix + "ChartPie",
  mixins: [Core],
  data: function data() {
    return {
      iChartName: "PieChart"
    };
  },
  methods: {
    updateChart: function updateChart() {
      var _this$data = this.data, _this$data$columns = _this$data.columns, columns = _this$data$columns === void 0 ? [] : _this$data$columns, _this$data$rows = _this$data.rows, rows = _this$data$rows === void 0 ? [] : _this$data$rows;
      var extra = {
        legendVisible: this.legendVisible,
        tooltipVisible: this.tooltipVisible,
        t
      };
      this.huiChartOption = pie$1(columns, rows, this.settings, extra);
    }
  }
};
var _hoisted_1$k = {
  class: "hui-chart chart-box"
};
function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$k, [createElementVNode(
    "div",
    {
      ref: "chartRef",
      style: normalizeStyle({
        width: _ctx.width,
        height: _ctx.height
      })
    },
    null,
    4
    /* STYLE */
  ), renderSlot(_ctx.$slots, "default")]);
}
var HuiChartsPie = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", _sfc_render$l]]);
HuiChartsPie.install = function(Vue) {
  Vue.component(HuiChartsPie.name, HuiChartsPie);
};

function _extends$h() {
  return _extends$h = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t2 = arguments[e];
      for (var r in t2)
        ({}).hasOwnProperty.call(t2, r) && (n[r] = t2[r]);
    }
    return n;
  }, _extends$h.apply(null, arguments);
}
var PIE_RADIUS = 100;
var RING_RADIUS = [90, 100];
var ROSE_RING_RADIUS = [20, 100];
var PIE_OFFSET = "50%";
var getTooltip$b = function getTooltip2(args) {
  var dataType = args.dataType, digit = args.digit, dimension = args.dimension, innerRows = args.innerRows, limitShowNum = args.limitShowNum, metrics = args.metrics, t2 = args.t;
  var _ref = {}, _ref$localeOther = _ref.localeOther, localeOther = _ref$localeOther === void 0 ? t2("ui.chart.other") : _ref$localeOther, remainArr = _ref.remainArr, _ref$sum = _ref.sum, sum = _ref$sum === void 0 ? 0 : _ref$sum;
  var mapHandler = function mapHandler2(row) {
    sum += row[metrics];
    return {
      name: row[dimension],
      value: row[metrics]
    };
  };
  remainArr = innerRows.map(mapHandler).slice(limitShowNum, innerRows.length);
  var formatter = function formatter2(item) {
    var tplt = [itemPoint(item.color)];
    var percent;
    if (!limitShowNum || item.name !== localeOther) {
      tplt.push(itemLabel(item.name));
      tplt.push(itemContent(getFormatted(item.value, dataType, digit)));
      tplt.push(itemContent("(" + item.percent + "%)"));
    } else {
      tplt.push(localeOther + ":");
      remainArr.forEach(function(_ref2) {
        var name = _ref2.name, value = _ref2.value;
        percent = "(" + getFormatted(value / sum, "percent") + ")";
        tplt.push("<br>" + itemLabel(name));
        tplt.push(itemContent(getFormatted(value, dataType, digit)));
        tplt.push(itemContent(percent));
      });
    }
    return tplt.join("");
  };
  return formatter;
};
var getLabel = function getLabel2(args) {
  var label = args.label, labelLine = args.labelLine, percentShow = args.percentShow, dataType = args.dataType, digit = args.digit;
  var labelObj = {};
  if (label) {
    if (isDefined(label.show)) {
      labelObj.show = label.show;
    }
    if (isDefined(label.formatter)) {
      labelObj.labelHtml = label.formatter;
    }
  }
  if (percentShow) {
    labelObj.labelHtml = function(params) {
      var tplt = [];
      tplt.push(params.name + ":");
      tplt.push(getFormatted(params.value, dataType, digit));
      tplt.push("(" + params.percent + "%)");
      return tplt.join("");
    };
  }
  if (labelLine) {
    if (isDefined(labelLine.show)) {
      labelObj.line = labelLine.show;
    }
    var color;
    if (labelLine && labelLine.lineStyle) {
      color = labelLine.lineStyle.color;
    }
    if (isDefined(color)) {
      labelObj.lineColor = color;
    }
    if (isDefined(labelLine.length)) {
      labelObj.distance = labelLine.length;
    }
  }
  return labelObj;
};
var getPosition = function getPosition2(args) {
  var radius = args.radius, offsetY = args.offsetY, level = args.level;
  var position = {};
  if (isDefined(offsetY)) {
    position.center = [PIE_OFFSET, offsetY];
  }
  if (Array.isArray(radius)) {
    position.radius = radius;
  } else if (!level || level.length === 0) {
    position.radius = [0, radius];
  }
  return position;
};
var getInnerData = function getInnerData2(args) {
  var dimension = args.dimension, metrics = args.metrics, innerRows = args.innerRows;
  return innerRows.map(function(row) {
    return {
      name: row[dimension],
      value: row[metrics]
    };
  });
};
var getDataOrSeries = function getDataOrSeries2(args) {
  var innerData = args.innerData, isRing = args.isRing, radius = args.radius, level = args.level, limitShowNum = args.limitShowNum, t2 = args.t;
  var series;
  var getLimitData = function getLimitData2(data2) {
    var tempData = data2;
    if (limitShowNum && limitShowNum < tempData.length) {
      var remainArr = tempData.slice(limitShowNum, innerData.length);
      var sum = remainArr.reduce(function(a, c) {
        return a + c.value;
      }, 0);
      tempData.splice(limitShowNum, Infinity, {
        name: t2("ui.chart.other"),
        value: sum
      });
    }
    return tempData;
  };
  var levelFlag = level && level.length;
  if (levelFlag) {
    var levelObj = {};
    var maxLevel = 0;
    var levelData = [];
    level.forEach(function(levelItems, index) {
      levelItems.forEach(function(item) {
        if (levelObj[item] === void 0) {
          levelObj[item] = [index];
        } else {
          levelObj[item].push(index);
        }
        if (maxLevel < index + 1) {
          maxLevel = index + 1;
        }
      });
    });
    levelData = Array.from({
      length: maxLevel
    }, function() {
      return [];
    });
    innerData.forEach(function(data2) {
      Array.isArray(levelObj[data2.name]) && levelObj[data2.name].forEach(function(levelIdx) {
        levelData[levelIdx].push(_extends$h({}, data2));
      });
    });
    var rowsCount = levelData.length;
    var centerWidth = radius / rowsCount;
    series = levelData.map(function(data2, index) {
      var itemRadius;
      if (index === 0) {
        itemRadius = isRing ? radius : centerWidth;
      } else {
        var outerWidth = centerWidth + radius / (2 * rowsCount) * (2 * index - 1);
        var innerWidth = outerWidth + radius / (2 * rowsCount);
        itemRadius = [outerWidth, innerWidth];
      }
      return {
        name: "PIE-" + index,
        type: "pie",
        radius: itemRadius,
        data: getLimitData(data2)
      };
    });
  }
  return levelFlag ? {
    series
  } : {
    data: getLimitData(innerData)
  };
};
var getLegend$5 = function getLegend2(args) {
  var dimension = args.dimension, innerRows = args.innerRows, legendVisible = args.legendVisible, legendLimit = args.legendLimit, level = args.level, limitShowNum = args.limitShowNum, innerData = args.innerData;
  if (!legendVisible) {
    return {
      show: false
    };
  }
  var _ref3 = {}, _ref3$legend = _ref3.legend, legend = _ref3$legend === void 0 ? [] : _ref3$legend, _ref3$levelTemp = _ref3.levelTemp, levelTemp = _ref3$levelTemp === void 0 ? [] : _ref3$levelTemp;
  if (level) {
    level.forEach(function(levelItem) {
      return levelItem.forEach(function(item) {
        return levelTemp.push(item);
      });
    });
    legend = levelTemp;
  } else if (limitShowNum && limitShowNum < innerRows.length) {
    for (var i = limitShowNum - 1; i >= 0; i--) {
      legend.unshift(innerRows[i][dimension]);
    }
  } else {
    legend = innerRows.map(function(row) {
      return row[dimension];
    });
  }
  var show = false;
  if (legend.length) {
    show = legend.length < legendLimit;
  }
  if (level && level.length) {
    return {
      show,
      data: innerData
    };
  }
  return {
    show
  };
};
var pie = function pie2(columns, rows, settings, extra, isRing) {
  var innerRows = deepCopy(rows);
  var _settings$dataType = settings.dataType, dataType = _settings$dataType === void 0 ? "normal" : _settings$dataType, _settings$digit = settings.digit, digit = _settings$digit === void 0 ? 2 : _settings$digit, _settings$dimension = settings.dimension, dimension = _settings$dimension === void 0 ? columns[0] : _settings$dimension, emphasis = settings.emphasis;
  var itemStyle = settings.itemStyle, _settings$label = settings.label, label = _settings$label === void 0 ? false : _settings$label, labelLine = settings.labelLine, _settings$legendLimit = settings.legendLimit, legendLimit = _settings$legendLimit === void 0 ? 30 : _settings$legendLimit; settings.legendName; var _settings$level = settings.level, level = _settings$level === void 0 ? false : _settings$level;
  var _settings$limitShowNu = settings.limitShowNum, limitShowNum = _settings$limitShowNu === void 0 ? 0 : _settings$limitShowNu, _settings$metrics = settings.metrics, metrics = _settings$metrics === void 0 ? columns[1] : _settings$metrics, _settings$offsetY = settings.offsetY, offsetY = _settings$offsetY === void 0 ? PIE_OFFSET : _settings$offsetY, percentShow = settings.percentShow;
  var _settings$roseType = settings.roseType, roseType = _settings$roseType === void 0 ? false : _settings$roseType, _settings$selectedMod = settings.selectedMode, selectedMode = _settings$selectedMod === void 0 ? false : _settings$selectedMod, hoverAnimation = settings.hoverAnimation;
  var _settings$radius = settings.radius, radius = _settings$radius === void 0 ? isRing ? roseType ? ROSE_RING_RADIUS : RING_RADIUS : PIE_RADIUS : _settings$radius;
  var legendVisible = extra.legendVisible, tooltipVisible = extra.tooltipVisible, t2 = extra.t;
  limitShowNum && innerRows.sort(function(a, b) {
    return b[metrics] - a[metrics];
  });
  var innerData = getInnerData({
    dimension,
    metrics,
    innerRows
  });
  var type = isRing ? "circle" : "pie";
  var position = getPosition({
    radius,
    offsetY,
    level
  });
  var ichartLabel = getLabel({
    label,
    labelLine,
    percentShow,
    dataType,
    digit
  });
  var ichartLegend = getLegend$5({
    legendVisible,
    dimension,
    innerRows,
    legendLimit,
    level,
    limitShowNum
  });
  var dataOrSeries = getDataOrSeries({
    innerData,
    isRing,
    radius,
    level,
    limitShowNum,
    t: t2
  });
  var ichartOption = _extends$h({
    legend: ichartLegend,
    type,
    position,
    label: ichartLabel,
    itemStyle,
    emphasis: emphasis || {
      scale: hoverAnimation === void 0 ? true : hoverAnimation
    },
    roseType,
    selectedMode
  }, dataOrSeries);
  if (tooltipVisible) {
    var tipHtml = getTooltip$b({
      dataType,
      innerRows,
      limitShowNum,
      digit,
      metrics,
      dimension,
      t: t2
    });
    ichartOption.tipHtml = tipHtml;
  } else {
    ichartOption.tooltip = {
      show: false
    };
  }
  var ichartExtend = {};
  if (label) {
    ichartExtend.label = label;
  }
  if (labelLine) {
    ichartExtend.labelLine = labelLine;
  }
  ichartOption.extend = _extends$h({}, ichartExtend);
  return ichartOption;
};
var _sfc_main$k = {
  name: $prefix + "ChartRing",
  mixins: [Core],
  data: function data() {
    return {
      iChartName: "PieChart"
    };
  },
  methods: {
    updateChart: function updateChart() {
      var _this$data = this.data, _this$data$columns = _this$data.columns, columns = _this$data$columns === void 0 ? [] : _this$data$columns, _this$data$rows = _this$data.rows, rows = _this$data$rows === void 0 ? [] : _this$data$rows;
      var extra = {
        legendVisible: this.legendVisible,
        tooltipVisible: this.tooltipVisible,
        t
      };
      this.huiChartOption = pie(columns, rows, this.settings, extra, true);
    }
  }
};
var _hoisted_1$j = {
  class: "hui-chart chart-box"
};
function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$j, [createElementVNode(
    "div",
    {
      ref: "chartRef",
      style: normalizeStyle({
        width: _ctx.width,
        height: _ctx.height
      })
    },
    null,
    4
    /* STYLE */
  ), renderSlot(_ctx.$slots, "default")]);
}
var HuiChartsRing = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$k]]);
HuiChartsRing.install = function(Vue) {
  Vue.component(HuiChartsRing.name, HuiChartsRing);
};

function _extends$g() {
  return _extends$g = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends$g.apply(null, arguments);
}
var VALUE_AXIS_OPACITY$1 = 0.5;
var getBarDimAxis$1 = function getBarDimAxis2(args) {
  var innerRows = args.innerRows, dimAxisName = args.dimAxisName, dimension = args.dimension, axisVisible = args.axisVisible, dimAxisType = args.dimAxisType, dims = args.dims;
  return dimension.map(function(item) {
    return {
      type: "category",
      name: dimAxisName,
      nameLocation: "middle",
      nameGap: 22,
      data: dimAxisType === "value" ? getValueAxisData$1(dims) : innerRows.map(function(row) {
        return row[item];
      }),
      axisLabel: {
        formatter: function formatter(value) {
          return String(value);
        }
      },
      show: axisVisible
    };
  });
};
var getBarMeaAxis$1 = function getBarMeaAxis2(args) {
  var axisVisible = args.axisVisible, digit = args.digit, max = args.max, _args$meaAxisName = args.meaAxisName, meaAxisName = _args$meaAxisName === void 0 ? [] : _args$meaAxisName, meaAxisType = args.meaAxisType, min = args.min, scale = args.scale;
  var meaAxisBase = {
    type: "value",
    axisTick: {
      show: false
    },
    show: axisVisible
  };
  var _ref = {}, _ref$meaAxis = _ref.meaAxis, meaAxis = _ref$meaAxis === void 0 ? [] : _ref$meaAxis, _ref$i = _ref.i, i = _ref$i === void 0 ? 0 : _ref$i, formatter = _ref.formatter;
  for (; i < 2; i++) {
    if (meaAxisType[i]) {
      formatter = factoryFmt$2({
        meaAxisType,
        i,
        digit
      });
      meaAxis[i] = _extends$g({}, meaAxisBase, {
        axisLabel: {
          formatter
        }
      });
    } else {
      meaAxis[i] = _extends$g({}, meaAxisBase);
    }
    Object.assign(meaAxis[i], {
      max: max[i] || null,
      min: min[i] || null,
      name: meaAxisName[i] || "",
      scale: scale[i] || false
    });
  }
  return meaAxis;
};
var factoryFmt$2 = function factoryFmt2(_ref2) {
  var meaAxisType = _ref2.meaAxisType, i = _ref2.i, digit = _ref2.digit;
  return function(val) {
    return getFormatted(val, meaAxisType[i], digit);
  };
};
var getLegend$4 = function getLegend2(args) {
  var legendName = args.legendName;
  var legendBase = {
    show: true
  };
  var formatter = function formatter2(name) {
    return !legendName[name] ? name : legendName[name];
  };
  return _extends$g({}, legendBase, {
    formatter
  });
};
var getDims$1 = function getDims2(rows, dimension) {
  return rows.map(function(row) {
    return row[dimension[0]];
  });
};
var getValueAxisData$1 = function getValueAxisData2(dims) {
  var max = Math.max.apply(Math, dims);
  var min = Math.min.apply(Math, dims);
  var _ref3 = {}, _ref3$result = _ref3.result, result = _ref3$result === void 0 ? [] : _ref3$result, _ref3$i = _ref3.i, i = _ref3$i === void 0 ? min : _ref3$i;
  for (; i <= max; i++) {
    result.push(i);
  }
  return result;
};
var getBarSeries$1 = function getBarSeries2(args) {
  var axisSite = args.axisSite, barGap = args.barGap, dimAxisType = args.dimAxisType; args.dims; var innerRows = args.innerRows, isHistogram = args.isHistogram, itemStyle = args.itemStyle;
  if (!itemStyle.barWidth) {
    itemStyle.barWidth = "auto";
  }
  args.label; var labelMap = args.labelMap, metrics = args.metrics, opacity = args.opacity, _args$showLine = args.showLine, showLine = _args$showLine === void 0 ? [] : _args$showLine, stack = args.stack;
  var _ref4 = {}, secondAxis = _ref4.secondAxis, secondDimAxisIndex = _ref4.secondDimAxisIndex, _ref4$series = _ref4.series, series = _ref4$series === void 0 ? [] : _ref4$series, _ref4$seriesTemp = _ref4.seriesTemp, seriesTemp = _ref4$seriesTemp === void 0 ? {} : _ref4$seriesTemp, stackMap = _ref4.stackMap, _ref4$stackNum = _ref4.stackNum, stackNum = _ref4$stackNum === void 0 ? 0 : _ref4$stackNum;
  secondAxis = (isHistogram ? axisSite == null ? void 0 : axisSite.right : axisSite == null ? void 0 : axisSite.top) || [];
  secondDimAxisIndex = isHistogram ? "yAxisIndex" : "xAxisIndex";
  stackMap = stack && getStackMap$1(stack);
  metrics.forEach(function(item) {
    return seriesTemp[item] = [];
  });
  innerRows.forEach(function(row) {
    return metrics.forEach(function(item) {
      return seriesTemp[item].push(row[item]);
    });
  });
  series = Object.keys(seriesTemp).map(function(item) {
    var _seriesItem;
    var name = !isNull$1(labelMap[item]) ? labelMap[item] : item;
    var type = ~showLine.indexOf(item) ? "line" : "bar";
    var axisIndex = ~secondAxis.indexOf(item) ? "1" : "0";
    var seriesItem = (_seriesItem = {
      name,
      type
    }, _seriesItem[secondDimAxisIndex] = axisIndex, _seriesItem);
    var defaultItemStyle = {};
    stack && stackMap[item] && (seriesItem.stack = stackMap[item]);
    if (Object.keys(stack).length) {
      if (stackNum === Object.keys(stackMap).length - 1 || isNull$1(seriesItem.stack)) {
        seriesItem.itemStyle = Object.assign(defaultItemStyle, seriesItem.itemStyle);
      }
      if (!isNull$1(seriesItem.stack)) {
        stackNum++;
      }
      seriesItem.itemStyle = _extends$g({
        borderWidth: 2,
        borderColor: "transparent"
      }, seriesItem.itemStyle);
    }
    itemStyle && (seriesItem.itemStyle = itemStyle);
    var itemOpacity = opacity || get(seriesItem, "itemStyle.opacity");
    dimAxisType === "value" && Object.assign(seriesItem, {
      barGap,
      barCategoryGap: "1%"
    });
    dimAxisType === "value" && isNull$1(itemOpacity) && (itemOpacity = VALUE_AXIS_OPACITY$1);
    !isNull$1(itemOpacity) && set(seriesItem, "itemStyle.opacity", itemOpacity);
    return seriesItem;
  });
  return series.length ? series : false;
};
var getDataValue$1 = function getDataValue2(data2, dimension, metrics, innerRows, dims) {
  var dimensionData = dimension[0];
  var dataTemp = {};
  data2.forEach(function(item, index2) {
    dataTemp[item[dimensionData]] = item;
  });
  var dataItemTemp = {};
  metrics.forEach(function(item, index2) {
    dataItemTemp[item] = null;
  });
  var max = Math.max.apply(Math, dims);
  var min = Math.min.apply(Math, dims);
  var _ref5 = {}, _ref5$result = _ref5.result, result = _ref5$result === void 0 ? [] : _ref5$result, _ref5$i = _ref5.i, i = _ref5$i === void 0 ? min : _ref5$i, index = _ref5.index;
  for (; i <= max; i++) {
    var _extends2;
    index = dims.indexOf(i);
    result.push(~index ? dataTemp[i] : _extends$g((_extends2 = {}, _extends2[dimensionData] = i, _extends2), dataItemTemp));
  }
  return result;
};
var histogram$1 = function histogram2(columns, rows, settings, extra, isHistogram) {
  if (isHistogram === void 0) {
    isHistogram = true;
  }
  var innerRows = cloneDeep(rows);
  var _settings$axisSite = settings.axisSite, axisSite = _settings$axisSite === void 0 ? {} : _settings$axisSite, _settings$dimension = settings.dimension, dimension = _settings$dimension === void 0 ? [columns[0]] : _settings$dimension; settings.axisLabel; var _settings$axisVisible = settings.axisVisible, axisVisible = _settings$axisVisible === void 0 ? true : _settings$axisVisible;
  var _settings$digit = settings.digit, digit = _settings$digit === void 0 ? 2 : _settings$digit, _settings$dataOrder = settings.dataOrder, dataOrder = _settings$dataOrder === void 0 ? false : _settings$dataOrder, _settings$scale = settings.scale, scale = _settings$scale === void 0 ? [false, false] : _settings$scale, _settings$min = settings.min, min = _settings$min === void 0 ? [null, null] : _settings$min, _settings$max = settings.max, max = _settings$max === void 0 ? [null, null] : _settings$max, _settings$stack = settings.stack, stack = _settings$stack === void 0 ? {} : _settings$stack;
  var tooltipVisible = extra.tooltipVisible, legendVisible = extra.legendVisible;
  var _settings$labelMap = settings.labelMap, labelMap = _settings$labelMap === void 0 ? {} : _settings$labelMap, _settings$legendName = settings.legendName, legendName = _settings$legendName === void 0 ? {} : _settings$legendName, label = settings.label, _settings$itemStyle = settings.itemStyle, itemStyle = _settings$itemStyle === void 0 ? {} : _settings$itemStyle, showLine = settings.showLine, _settings$barGap = settings.barGap, barGap = _settings$barGap === void 0 ? "-100%" : _settings$barGap, opacity = settings.opacity;
  var _ref6 = {}, _ref6$metrics = _ref6.metrics, metrics = _ref6$metrics === void 0 ? columns.slice() : _ref6$metrics, meaAxisType = _ref6.meaAxisType, dimAxisType = _ref6.dimAxisType, meaAxisName = _ref6.meaAxisName, _ref6$dimAxisName = _ref6.dimAxisName, dimAxisName = _ref6$dimAxisName === void 0 ? true : _ref6$dimAxisName, dims = _ref6.dims;
  if (dataOrder) {
    var label2 = dataOrder.label, order = dataOrder.order;
    if (label2 && order) {
      innerRows.sort(function(a, b) {
        return order === "desc" ? a[label2] - b[label2] : b[label2] - a[label2];
      });
    }
  }
  var xAxis = {};
  var yAxis = {};
  dims = getDims$1(innerRows, dimension);
  if (isHistogram) {
    if (axisSite.right && axisSite.left) {
      metrics = axisSite.left.concat(axisSite.right);
    } else if (settings.metrics) {
      metrics = settings.metrics;
    } else if (axisSite.left && !axisSite.right) {
      metrics = axisSite.left;
    } else {
      metrics.splice(columns.indexOf(dimension[0]), 1);
    }
    dimAxisType = settings.xAxisType || "category";
    meaAxisType = settings.yAxisType || ["normal", "normal"];
    dimAxisName = settings.xAxisName || "";
    meaAxisName = settings.yAxisName || [];
    xAxis = getBarDimAxis$1({
      innerRows,
      dimAxisName,
      dimension,
      axisVisible,
      dimAxisType,
      dims
    });
    yAxis = getBarMeaAxis$1({
      meaAxisName,
      meaAxisType,
      axisVisible,
      digit,
      scale,
      min,
      max
    });
  } else {
    if (axisSite.bottom && axisSite.top) {
      metrics = axisSite.top.concat(axisSite.bottom);
    } else if (!axisSite.right && axisSite.bottom) {
      metrics = axisSite.bottom;
    } else if (settings.metrics) {
      metrics = settings.metrics;
    } else {
      metrics.splice(columns.indexOf(dimension[0]), 1);
    }
    dimAxisType = settings.yAxisType || "category";
    meaAxisType = settings.xAxisType || ["normal", "normal"];
    dimAxisName = settings.yAxisName || "";
    xAxis = getBarDimAxis$1({
      innerRows,
      dimAxisName,
      dimension,
      axisVisible,
      dimAxisType,
      dims
    });
    yAxis = getBarMeaAxis$1({
      axisVisible,
      meaAxisType,
      meaAxisName,
      scale,
      digit,
      max,
      min
    });
  }
  if (opacity) {
    var itemStyleBase = {
      opacity
    };
    Object.assign(itemStyle, itemStyleBase);
  }
  var tempRows = innerRows.map(function(row) {
    var temp = _extends$g({}, row);
    for (var _i = 0, _Object$entries = Object.entries(labelMap); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _Object$entries[_i], key = _Object$entries$_i[0], value = _Object$entries$_i[1];
      if (Object.prototype.hasOwnProperty.call(row, key)) {
        temp[value] = temp[key];
      }
    }
    return temp;
  });
  var data2 = getRows({
    columns,
    metrics,
    labelMap,
    rows: tempRows,
    dimension
  });
  if (dimAxisType === "value") {
    data2 = getDataValue$1(data2, dimension, metrics, innerRows, dims);
  }
  var lineDataName = showLine ? [].concat(showLine) : [];
  var legend = legendVisible ? getLegend$4({
    legendName,
    metrics,
    labelMap
  }) : {
    show: false
  };
  var tooltip = tooltipVisible ? getTooltip$d({
    axisSite,
    yAxisType: meaAxisType
  }) : {
    show: false
  };
  var tipHtml = tooltip.formatter;
  var args = {
    innerRows,
    metrics,
    stack,
    axisSite,
    isHistogram,
    labelMap,
    itemStyle,
    label
  };
  Object.assign(args, {
    showLine,
    dimAxisType,
    dimension,
    barGap,
    opacity,
    dims
  });
  var options = {
    data: data2,
    itemStyle,
    tipHtml,
    lineDataName,
    legend,
    tooltip,
    yAxis,
    xAxis,
    label,
    stack,
    series: getBarSeries$1(args)
  };
  if (typeof options.stack === "object" && options.stack !== null && Object.keys(options.stack).length > 0) {
    options.type = "stack";
  }
  return options;
};
var _sfc_main$j = {
  name: $prefix + "ChartBar",
  mixins: [Core],
  data: function data() {
    return {
      iChartName: "BarChart"
    };
  },
  methods: {
    updateChart: function updateChart() {
      var _this$data = this.data, _this$data$columns = _this$data.columns, columns = _this$data$columns === void 0 ? [] : _this$data$columns, _this$data$rows = _this$data.rows, rows = _this$data$rows === void 0 ? [] : _this$data$rows;
      var extra = {
        tooltipVisible: this.tooltipVisible,
        legendVisible: this.legendVisible,
        extend: this.extend
      };
      var option = histogram$1(columns, rows, this.settings, extra, false);
      this.huiChartOption = _extends$g({
        smooth: true
      }, option, {
        direction: "horizontal"
      });
    }
  }
};
var _hoisted_1$i = {
  class: "hui-chart chart-box"
};
function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$i, [createElementVNode(
    "div",
    {
      ref: "chartRef",
      style: normalizeStyle({
        width: _ctx.width,
        height: _ctx.height
      })
    },
    null,
    4
    /* STYLE */
  ), renderSlot(_ctx.$slots, "default")]);
}
var HuiChartsBar = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["render", _sfc_render$j]]);
HuiChartsBar.install = function(Vue) {
  Vue.component(HuiChartsBar.name, HuiChartsBar);
};

function _extends$f() {
  return _extends$f = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends$f.apply(null, arguments);
}
var VALUE_AXIS_OPACITY = 0.5;
var getBarDimAxis = function getBarDimAxis2(args) {
  var innerRows = args.innerRows, dimAxisName = args.dimAxisName, dimension = args.dimension, axisVisible = args.axisVisible, dimAxisType = args.dimAxisType, dims = args.dims;
  return dimension.map(function(item) {
    return {
      type: "category",
      name: dimAxisName,
      nameLocation: "middle",
      nameGap: 22,
      data: dimAxisType === "value" ? getValueAxisData(dims) : innerRows.map(function(row) {
        return row[item];
      }),
      axisLabel: {
        formatter: function formatter(value) {
          return String(value);
        }
      },
      show: axisVisible
    };
  });
};
var getBarMeaAxis = function getBarMeaAxis2(args) {
  var axisVisible = args.axisVisible, digit = args.digit, max = args.max, _args$meaAxisName = args.meaAxisName, meaAxisName = _args$meaAxisName === void 0 ? [] : _args$meaAxisName, meaAxisType = args.meaAxisType, min = args.min, scale = args.scale;
  var meaAxisBase = {
    type: "value",
    axisTick: {
      show: false
    },
    show: axisVisible
  };
  var _ref = {}, _ref$meaAxis = _ref.meaAxis, meaAxis = _ref$meaAxis === void 0 ? [] : _ref$meaAxis, _ref$i = _ref.i, i = _ref$i === void 0 ? 0 : _ref$i, formatter = _ref.formatter;
  for (; i < 2; i++) {
    if (meaAxisType[i]) {
      formatter = factoryFmt$1({
        meaAxisType,
        i,
        digit
      });
      meaAxis[i] = _extends$f({}, meaAxisBase, {
        axisLabel: {
          formatter
        }
      });
    } else {
      meaAxis[i] = _extends$f({}, meaAxisBase);
    }
    Object.assign(meaAxis[i], {
      max: max[i] || null,
      min: min[i] || null,
      name: meaAxisName[i] || "",
      scale: scale[i] || false
    });
  }
  return meaAxis;
};
var factoryFmt$1 = function factoryFmt2(_ref2) {
  var meaAxisType = _ref2.meaAxisType, i = _ref2.i, digit = _ref2.digit;
  return function(val) {
    return getFormatted(val, meaAxisType[i], digit);
  };
};
var getLegend$3 = function getLegend2(args) {
  var legendName = args.legendName;
  var legendBase = {
    show: true
  };
  var formatter = function formatter2(name) {
    return !legendName[name] ? name : legendName[name];
  };
  return _extends$f({}, legendBase, {
    formatter
  });
};
var getDims = function getDims2(rows, dimension) {
  return rows.map(function(row) {
    return row[dimension[0]];
  });
};
var getValueAxisData = function getValueAxisData2(dims) {
  var max = Math.max.apply(Math, dims);
  var min = Math.min.apply(Math, dims);
  var _ref3 = {}, _ref3$result = _ref3.result, result = _ref3$result === void 0 ? [] : _ref3$result, _ref3$i = _ref3.i, i = _ref3$i === void 0 ? min : _ref3$i;
  for (; i <= max; i++) {
    result.push(i);
  }
  return result;
};
var getBarSeries = function getBarSeries2(args) {
  var axisSite = args.axisSite, barGap = args.barGap, dimAxisType = args.dimAxisType; args.dims; var innerRows = args.innerRows, isHistogram = args.isHistogram, itemStyle = args.itemStyle;
  if (!itemStyle.barWidth) {
    itemStyle.barWidth = "auto";
  }
  args.label; var labelMap = args.labelMap, metrics = args.metrics, opacity = args.opacity, _args$showLine = args.showLine, showLine = _args$showLine === void 0 ? [] : _args$showLine, stack = args.stack;
  var _ref4 = {}, secondAxis = _ref4.secondAxis, secondDimAxisIndex = _ref4.secondDimAxisIndex, _ref4$series = _ref4.series, series = _ref4$series === void 0 ? [] : _ref4$series, _ref4$seriesTemp = _ref4.seriesTemp, seriesTemp = _ref4$seriesTemp === void 0 ? {} : _ref4$seriesTemp, stackMap = _ref4.stackMap, _ref4$stackNum = _ref4.stackNum, stackNum = _ref4$stackNum === void 0 ? 0 : _ref4$stackNum;
  secondAxis = (isHistogram ? axisSite == null ? void 0 : axisSite.right : axisSite == null ? void 0 : axisSite.top) || [];
  secondDimAxisIndex = isHistogram ? "yAxisIndex" : "xAxisIndex";
  stackMap = stack && getStackMap$1(stack);
  metrics.forEach(function(item) {
    return seriesTemp[item] = [];
  });
  innerRows.forEach(function(row) {
    return metrics.forEach(function(item) {
      return seriesTemp[item].push(row[item]);
    });
  });
  series = Object.keys(seriesTemp).map(function(item) {
    var _seriesItem;
    var name = !isNull$1(labelMap[item]) ? labelMap[item] : item;
    var type = ~showLine.indexOf(item) ? "line" : "bar";
    var axisIndex = ~secondAxis.indexOf(item) ? "1" : "0";
    var seriesItem = (_seriesItem = {
      name,
      type
    }, _seriesItem[secondDimAxisIndex] = axisIndex, _seriesItem);
    var defaultItemStyle = {};
    stack && stackMap[item] && (seriesItem.stack = stackMap[item]);
    if (Object.keys(stack).length) {
      if (stackNum === Object.keys(stackMap).length - 1 || isNull$1(seriesItem.stack)) {
        seriesItem.itemStyle = Object.assign(defaultItemStyle, seriesItem.itemStyle);
      }
      if (!isNull$1(seriesItem.stack)) {
        stackNum++;
      }
      seriesItem.itemStyle = _extends$f({
        borderWidth: 2,
        borderColor: "transparent"
      }, seriesItem.itemStyle);
    }
    itemStyle && (seriesItem.itemStyle = itemStyle);
    var itemOpacity = opacity || get(seriesItem, "itemStyle.opacity");
    dimAxisType === "value" && Object.assign(seriesItem, {
      barGap,
      barCategoryGap: "1%"
    });
    dimAxisType === "value" && isNull$1(itemOpacity) && (itemOpacity = VALUE_AXIS_OPACITY);
    !isNull$1(itemOpacity) && set(seriesItem, "itemStyle.opacity", itemOpacity);
    return seriesItem;
  });
  return series.length ? series : false;
};
var getDataValue = function getDataValue2(data2, dimension, metrics, innerRows, dims) {
  var dimensionData = dimension[0];
  var dataTemp = {};
  data2.forEach(function(item, index2) {
    dataTemp[item[dimensionData]] = item;
  });
  var dataItemTemp = {};
  metrics.forEach(function(item, index2) {
    dataItemTemp[item] = null;
  });
  var max = Math.max.apply(Math, dims);
  var min = Math.min.apply(Math, dims);
  var _ref5 = {}, _ref5$result = _ref5.result, result = _ref5$result === void 0 ? [] : _ref5$result, _ref5$i = _ref5.i, i = _ref5$i === void 0 ? min : _ref5$i, index = _ref5.index;
  for (; i <= max; i++) {
    var _extends2;
    index = dims.indexOf(i);
    result.push(~index ? dataTemp[i] : _extends$f((_extends2 = {}, _extends2[dimensionData] = i, _extends2), dataItemTemp));
  }
  return result;
};
var histogram = function histogram2(columns, rows, settings, extra, isHistogram) {
  if (isHistogram === void 0) {
    isHistogram = true;
  }
  var innerRows = cloneDeep(rows);
  var _settings$axisSite = settings.axisSite, axisSite = _settings$axisSite === void 0 ? {} : _settings$axisSite, _settings$dimension = settings.dimension, dimension = _settings$dimension === void 0 ? [columns[0]] : _settings$dimension; settings.axisLabel; var _settings$axisVisible = settings.axisVisible, axisVisible = _settings$axisVisible === void 0 ? true : _settings$axisVisible;
  var _settings$digit = settings.digit, digit = _settings$digit === void 0 ? 2 : _settings$digit, _settings$dataOrder = settings.dataOrder, dataOrder = _settings$dataOrder === void 0 ? false : _settings$dataOrder, _settings$scale = settings.scale, scale = _settings$scale === void 0 ? [false, false] : _settings$scale, _settings$min = settings.min, min = _settings$min === void 0 ? [null, null] : _settings$min, _settings$max = settings.max, max = _settings$max === void 0 ? [null, null] : _settings$max, _settings$stack = settings.stack, stack = _settings$stack === void 0 ? {} : _settings$stack;
  var tooltipVisible = extra.tooltipVisible, legendVisible = extra.legendVisible;
  var _settings$labelMap = settings.labelMap, labelMap = _settings$labelMap === void 0 ? {} : _settings$labelMap, _settings$legendName = settings.legendName, legendName = _settings$legendName === void 0 ? {} : _settings$legendName, label = settings.label, _settings$itemStyle = settings.itemStyle, itemStyle = _settings$itemStyle === void 0 ? {} : _settings$itemStyle, showLine = settings.showLine, _settings$barGap = settings.barGap, barGap = _settings$barGap === void 0 ? "-100%" : _settings$barGap, opacity = settings.opacity;
  var _ref6 = {}, _ref6$metrics = _ref6.metrics, metrics = _ref6$metrics === void 0 ? columns.slice() : _ref6$metrics, meaAxisType = _ref6.meaAxisType, dimAxisType = _ref6.dimAxisType, meaAxisName = _ref6.meaAxisName, _ref6$dimAxisName = _ref6.dimAxisName, dimAxisName = _ref6$dimAxisName === void 0 ? true : _ref6$dimAxisName, dims = _ref6.dims;
  if (dataOrder) {
    var label2 = dataOrder.label, order = dataOrder.order;
    if (label2 && order) {
      innerRows.sort(function(a, b) {
        return order === "desc" ? a[label2] - b[label2] : b[label2] - a[label2];
      });
    }
  }
  var xAxis = {};
  var yAxis = {};
  dims = getDims(innerRows, dimension);
  if (isHistogram) {
    if (axisSite.right && axisSite.left) {
      metrics = axisSite.left.concat(axisSite.right);
    } else if (settings.metrics) {
      metrics = settings.metrics;
    } else if (axisSite.left && !axisSite.right) {
      metrics = axisSite.left;
    } else {
      metrics.splice(columns.indexOf(dimension[0]), 1);
    }
    dimAxisType = settings.xAxisType || "category";
    meaAxisType = settings.yAxisType || ["normal", "normal"];
    dimAxisName = settings.xAxisName || "";
    meaAxisName = settings.yAxisName || [];
    xAxis = getBarDimAxis({
      innerRows,
      dimAxisName,
      dimension,
      axisVisible,
      dimAxisType,
      dims
    });
    yAxis = getBarMeaAxis({
      meaAxisName,
      meaAxisType,
      axisVisible,
      digit,
      scale,
      min,
      max
    });
  } else {
    if (axisSite.bottom && axisSite.top) {
      metrics = axisSite.top.concat(axisSite.bottom);
    } else if (!axisSite.right && axisSite.bottom) {
      metrics = axisSite.bottom;
    } else if (settings.metrics) {
      metrics = settings.metrics;
    } else {
      metrics.splice(columns.indexOf(dimension[0]), 1);
    }
    dimAxisType = settings.yAxisType || "category";
    meaAxisType = settings.xAxisType || ["normal", "normal"];
    dimAxisName = settings.yAxisName || "";
    xAxis = getBarDimAxis({
      innerRows,
      dimAxisName,
      dimension,
      axisVisible,
      dimAxisType,
      dims
    });
    yAxis = getBarMeaAxis({
      axisVisible,
      meaAxisType,
      meaAxisName,
      scale,
      digit,
      max,
      min
    });
  }
  if (opacity) {
    var itemStyleBase = {
      opacity
    };
    Object.assign(itemStyle, itemStyleBase);
  }
  var tempRows = innerRows.map(function(row) {
    var temp = _extends$f({}, row);
    for (var _i = 0, _Object$entries = Object.entries(labelMap); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _Object$entries[_i], key = _Object$entries$_i[0], value = _Object$entries$_i[1];
      if (Object.prototype.hasOwnProperty.call(row, key)) {
        temp[value] = temp[key];
      }
    }
    return temp;
  });
  var data2 = getRows({
    columns,
    metrics,
    labelMap,
    rows: tempRows,
    dimension
  });
  if (dimAxisType === "value") {
    data2 = getDataValue(data2, dimension, metrics, innerRows, dims);
  }
  var lineDataName = showLine ? [].concat(showLine) : [];
  var legend = legendVisible ? getLegend$3({
    legendName,
    metrics,
    labelMap
  }) : {
    show: false
  };
  var tooltip = tooltipVisible ? getTooltip$d({
    axisSite,
    yAxisType: meaAxisType
  }) : {
    show: false
  };
  var tipHtml = tooltip.formatter;
  var args = {
    innerRows,
    metrics,
    stack,
    axisSite,
    isHistogram,
    labelMap,
    itemStyle,
    label
  };
  Object.assign(args, {
    showLine,
    dimAxisType,
    dimension,
    barGap,
    opacity,
    dims
  });
  var options = {
    data: data2,
    itemStyle,
    tipHtml,
    lineDataName,
    legend,
    tooltip,
    yAxis,
    xAxis,
    label,
    stack,
    series: getBarSeries(args)
  };
  if (typeof options.stack === "object" && options.stack !== null && Object.keys(options.stack).length > 0) {
    options.type = "stack";
  }
  return options;
};
var _sfc_main$i = {
  name: $prefix + "ChartHistogram",
  mixins: [Core],
  data: function data() {
    return {
      iChartName: "BarChart"
    };
  },
  methods: {
    updateChart: function updateChart(data2) {
      var _data$columns = data2.columns, columns = _data$columns === void 0 ? [] : _data$columns, _data$rows = data2.rows, rows = _data$rows === void 0 ? [] : _data$rows;
      var extra = {
        tooltipVisible: this.tooltipVisible,
        legendVisible: this.legendVisible,
        extend: this.extend
      };
      var option = histogram(columns, rows, this.settings, extra, true);
      this.huiChartOption = _extends$f({
        smooth: true
      }, option);
    }
  }
};
var _hoisted_1$h = {
  class: "hui-chart chart-box"
};
function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$h, [createElementVNode(
    "div",
    {
      ref: "chartRef",
      style: normalizeStyle({
        width: _ctx.width,
        height: _ctx.height
      })
    },
    null,
    4
    /* STYLE */
  ), renderSlot(_ctx.$slots, "default")]);
}
var HuiChartsHistogram = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", _sfc_render$i]]);
HuiChartsHistogram.install = function(Vue) {
  Vue.component(HuiChartsHistogram.name, HuiChartsHistogram);
};

function _extends$e() {
  return _extends$e = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends$e.apply(null, arguments);
}
var getRadarLegend = function getRadarLegend2(rows, dimension, legendName, legendVisible) {
  var legendData = rows.map(function(row) {
    return row[dimension];
  }).filter(function(i) {
    return i;
  });
  function formatter(value) {
    return isNull$1(legendName[value]) ? value : legendName[value];
  }
  return {
    show: legendVisible,
    data: legendData,
    formatter
  };
};
var getRadarTooltip = function getRadarTooltip2(dataType, radar22, digit) {
  var _ref = {}, _ref$typeTemp = _ref.typeTemp, typeTemp = _ref$typeTemp === void 0 ? [] : _ref$typeTemp, _ref$nameTemp = _ref.nameTemp, nameTemp = _ref$nameTemp === void 0 ? [] : _ref$nameTemp;
  radar22.indicator.forEach(function(item, i) {
    typeTemp[i] = dataType[item.name];
    nameTemp[i] = item.name;
  });
  function formatter(item) {
    var tplt = [];
    tplt.push(itemPoint(item.color));
    tplt.push(item.name + "<br />");
    item.data.value.forEach(function(val, i) {
      tplt.push("" + itemLabel(nameTemp[i]));
      tplt.push(itemContent(getFormatted(val, typeTemp[i], digit)) + "<br />");
    });
    return tplt.join("");
  }
  return {
    formatter
  };
};
var getRadarSetting = function getRadarSetting2(rows, metrics, labelMap) {
  var settingBase = {
    indicator: []
  };
  var indicatorTemp = {};
  rows.forEach(function(items) {
    metrics.forEach(function(item) {
      var key = isNull$1(labelMap[item]) ? item : labelMap[item];
      if (indicatorTemp[key]) {
        indicatorTemp[key].push(items[item]);
      } else {
        indicatorTemp[key] = [items[item]];
      }
    });
  });
  settingBase.indicator = Object.keys(indicatorTemp).map(function(key) {
    return {
      name: key,
      max: Math.max.apply(null, indicatorTemp[key])
    };
  });
  settingBase.data = indicatorTemp;
  settingBase.axisLabel = false;
  return settingBase;
};
var getRadarSeries = function getRadarSeries2(args) {
  var areaStyle = args.areaStyle, dimension = args.dimension, itemStyle = args.itemStyle, label = args.label, labelMap = args.labelMap, lineStyle = args.lineStyle, metrics = args.metrics, radar22 = args.radar, rows = args.rows;
  var radarIndexObj = {};
  radar22.indicator.forEach(function(item, i) {
    return radarIndexObj[item.name] = i;
  });
  var seriesData = rows.map(function(row) {
    var serieData = {
      value: [],
      name: row[dimension]
    };
    Object.keys(row).forEach(function(key) {
      if (~metrics.indexOf(key)) {
        var k = isNull$1(labelMap[key]) ? radarIndexObj[key] : radarIndexObj[labelMap[key]];
        serieData.value[k] = row[key];
      }
    });
    return serieData;
  });
  var result = {
    data: seriesData,
    name: "data",
    type: "radar"
  };
  label && (result.label = label);
  itemStyle && (result.itemStyle = itemStyle);
  lineStyle && (result.lineStyle = lineStyle);
  areaStyle && (result.areaStyle = areaStyle);
  return [result];
};
var radar = function radar2(columns, rows, settings, extra) {
  var _settings$dataType = settings.dataType, dataType = _settings$dataType === void 0 ? {} : _settings$dataType, _settings$legendName = settings.legendName, legendName = _settings$legendName === void 0 ? {} : _settings$legendName, _settings$labelMap = settings.labelMap, labelMap = _settings$labelMap === void 0 ? {} : _settings$labelMap, _settings$dimension = settings.dimension, dimension = _settings$dimension === void 0 ? columns[0] : _settings$dimension;
  var _settings$digit = settings.digit, digit = _settings$digit === void 0 ? 2 : _settings$digit, label = settings.label, itemStyle = settings.itemStyle, lineStyle = settings.lineStyle, areaStyle = settings.areaStyle;
  var tooltipVisible = extra.tooltipVisible, legendVisible = extra.legendVisible;
  var metrics = columns.slice();
  if (!settings.metrics) {
    metrics.splice(columns.indexOf(dimension), 1);
  } else {
    metrics = settings.metrics;
  }
  var legend = legendVisible ? getRadarLegend(rows, dimension, legendName, legendVisible) : {
    show: false
  };
  var radar22 = getRadarSetting(rows, metrics, labelMap);
  var tooltip = tooltipVisible ? getRadarTooltip(dataType, radar22, digit) : {
    show: false
  };
  var seriesParams = {
    rows,
    dimension,
    metrics,
    radar: radar22
  };
  Object.assign(seriesParams, {
    label,
    itemStyle,
    lineStyle,
    labelMap,
    areaStyle
  });
  var series = getRadarSeries(seriesParams);
  var dataTemp = {};
  rows.forEach(function(items, index) {
    var tempKey = items[dimension];
    dataTemp[tempKey] = {};
    metrics.forEach(function(item) {
      var key = isNull$1(labelMap[item]) ? item : labelMap[item];
      dataTemp[tempKey][key] = items[item];
    });
  });
  return {
    legend,
    data: dataTemp,
    radar: radar22,
    tipHtml: tooltip.formatter,
    series
  };
};
var _sfc_main$h = {
  name: $prefix + "ChartRadar",
  mixins: [Core],
  props: {
    settings: {
      type: Object
    },
    width: {
      type: String,
      default: "auto"
    },
    height: {
      type: String,
      default: "400px"
    }
  },
  data: function data() {
    return {
      iChartName: "RadarChart"
    };
  },
  methods: {
    updateChart: function updateChart(data2) {
      var _data$columns = data2.columns, columns = _data$columns === void 0 ? [] : _data$columns, _data$rows = data2.rows, rows = _data$rows === void 0 ? [] : _data$rows;
      var extra = {
        tooltipVisible: this.tooltipVisible,
        legendVisible: this.legendVisible,
        extend: this.extend
      };
      var option = radar(columns, rows, this.settings, extra);
      this.huiChartOption = _extends$e({}, option);
    }
  }
};
var _hoisted_1$g = {
  class: "hui-chart chart-box"
};
function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$g, [createElementVNode(
    "div",
    {
      ref: "chartRef",
      style: normalizeStyle({
        width: $props.width,
        height: $props.height
      })
    },
    null,
    4
    /* STYLE */
  ), renderSlot(_ctx.$slots, "default")]);
}
var HuiChartsRadar = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$h]]);
HuiChartsRadar.install = function(Vue) {
  Vue.component(HuiChartsRadar.name, HuiChartsRadar);
};

function _extends$d() {
  return _extends$d = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends$d.apply(null, arguments);
}
var getStackMap = function getStackMap2(stack) {
  var result = {};
  Object.keys(stack).forEach(function(item) {
    stack[item].forEach(function(name) {
      result[name] = item;
    });
  });
  return result;
};
var getLineXAxis = function getLineXAxis2(args) {
  var axisVisible = args.axisVisible, axisLabel = args.axisLabel, xAxisType = args.xAxisType;
  return {
    show: axisVisible,
    axisLabel,
    type: xAxisType
  };
};
var getLegend$2 = function getLegend2(args) {
  var legendName = args.legendName;
  var formatter = function formatter2(name) {
    return !legendName[name] ? name : legendName[name];
  };
  return {
    show: true,
    formatter
  };
};
var line = function line2(columns, rows, settings, extra) {
  rows = Array.isArray(rows) ? rows : [];
  columns = Array.isArray(columns) ? columns : [];
  var _settings$axisSite = settings.axisSite, axisSite = _settings$axisSite === void 0 ? {} : _settings$axisSite, _settings$yAxisType = settings.yAxisType, yAxisType = _settings$yAxisType === void 0 ? ["normal", "normal"] : _settings$yAxisType, _settings$xAxisType = settings.xAxisType, xAxisType = _settings$xAxisType === void 0 ? "category" : _settings$xAxisType, _settings$yAxisName = settings.yAxisName, yAxisName = _settings$yAxisName === void 0 ? [] : _settings$yAxisName, _settings$axisLabel = settings.axisLabel, axisLabel = _settings$axisLabel === void 0 ? {} : _settings$axisLabel;
  var _settings$dimension = settings.dimension, dimension = _settings$dimension === void 0 ? [columns[0]] : _settings$dimension; settings.xAxisName; var _settings$axisVisible = settings.axisVisible, axisVisible = _settings$axisVisible === void 0 ? true : _settings$axisVisible, _settings$area = settings.area, area = _settings$area === void 0 ? false : _settings$area, stack = settings.stack;
  var _settings$min = settings.min, min = _settings$min === void 0 ? [null, null] : _settings$min, _settings$max = settings.max, max = _settings$max === void 0 ? [null, null] : _settings$max, _settings$nullAddZero = settings.nullAddZero, nullAddZero = _settings$nullAddZero === void 0 ? false : _settings$nullAddZero, _settings$digit = settings.digit, digit = _settings$digit === void 0 ? 2 : _settings$digit, _settings$scale = settings.scale, scale = _settings$scale === void 0 ? false : _settings$scale;
  var _settings$legendName = settings.legendName, legendName = _settings$legendName === void 0 ? {} : _settings$legendName, _settings$labelMap = settings.labelMap, labelMap = _settings$labelMap === void 0 ? {} : _settings$labelMap, label = settings.label, itemStyle = settings.itemStyle, lineStyle = settings.lineStyle, areaStyle = settings.areaStyle, smooth = settings.smooth;
  var tooltipVisible = extra.tooltipVisible, legendVisible = extra.legendVisible, extend = extra.extend;
  var metrics = columns.slice();
  if (axisSite.right && axisSite.left) {
    metrics = axisSite.left.concat(axisSite.right);
  } else if (settings.metrics) {
    metrics = settings.metrics;
  } else if (axisSite.left && !axisSite.right) {
    metrics = axisSite.left;
  } else {
    metrics.splice(columns.indexOf(dimension[0]), 1);
  }
  var legend = legendVisible ? getLegend$2({
    legendName,
    metrics,
    labelMap
  }) : {
    show: false
  };
  var tooltip = tooltipVisible ? getTooltip$d({
    axisSite,
    yAxisType,
    digit
  }) : {
    show: false
  };
  var yAxis = getYAxis$2({
    max,
    min,
    yAxisType,
    yAxisName,
    metrics,
    axisSite,
    digit,
    scale
  });
  var xAxis = getLineXAxis({
    axisVisible,
    axisLabel,
    xAxisType
  });
  var seriesParam = {
    areaStyle,
    area,
    axisSite,
    dimension,
    itemStyle,
    lineStyle
  };
  Object.assign(seriesParam, {
    label,
    labelMap,
    metrics,
    nullAddZero,
    rows,
    xAxisType,
    stack,
    smooth,
    extend
  });
  var series = getLineSeries(seriesParam);
  var data2 = getRows({
    columns,
    metrics,
    labelMap,
    rows,
    dimension
  });
  var options = {
    data: data2,
    xAxis,
    yAxis,
    metrics,
    series,
    legend,
    tooltip,
    stack,
    tipHtml: tooltip.formatter,
    itemStyle,
    axisSite,
    area
  };
  return _extends$d({}, options);
};
var getLineSeries = function getLineSeries2(args) {
  var areaStyle = args.areaStyle, axisSite = args.axisSite; args.area; var dimension = args.dimension, itemStyle = args.itemStyle, label = args.label;
  var labelMap = args.labelMap, lineStyle = args.lineStyle, metrics = args.metrics, nullAddZero = args.nullAddZero, rows = args.rows, stack = args.stack; args.color; var smooth = args.smooth;
  var dataTempObj = {};
  var stackMapData = stack && getStackMap(stack);
  var series = [];
  metrics.forEach(function(item) {
    return dataTempObj[item] = [];
  });
  rows.forEach(function(row) {
    metrics.forEach(function(item) {
      var value = null;
      if (!isNull$1(row[item])) {
        value = row[item];
      } else if (nullAddZero) {
        value = 0;
      }
      dataTempObj[item].push([row[dimension[0]], value]);
    });
  });
  metrics.forEach(function(item, i) {
    var name = !isNull$1(labelMap[item]) ? labelMap[item] : item;
    var isSmooth = !(smooth === false);
    var seriesItem = {
      smooth: isSmooth,
      name,
      type: "line",
      data: dataTempObj[item]
    };
    var emphasis = {
      itemStyle: {
        borderColor: "#fff",
        borderWidth: 2
      }
    };
    var defaultSeriesItem = {
      symbol: "circle",
      symbolSize: 8,
      showSymbol: false,
      emphasis
    };
    metrics.length === 1 && !isSmooth && setSingLineSeries({
      defaultSeriesItem,
      seriesItem
    });
    seriesItem = Object.assign(defaultSeriesItem, seriesItem);
    axisSite.right && (seriesItem.yAxisIndex = ~axisSite.right.indexOf(item) ? 1 : 0);
    stack && stackMapData[item] && (seriesItem.stack = stackMapData[item]);
    label && (seriesItem.label = label);
    itemStyle && (seriesItem.itemStyle = itemStyle);
    lineStyle && (seriesItem.lineStyle = lineStyle);
    areaStyle && (seriesItem.areaStyle = areaStyle);
    series.push(seriesItem);
  });
  return series;
};
var _sfc_main$g = {
  name: $prefix + "ChartLine",
  mixins: [Core],
  data: function data() {
    return {
      iChartName: "LineChart"
    };
  },
  methods: {
    updateChart: function updateChart(data2) {
      var _data$columns = data2.columns, columns = _data$columns === void 0 ? [] : _data$columns, _data$rows = data2.rows, rows = _data$rows === void 0 ? [] : _data$rows;
      var extra = {
        tooltipVisible: this.tooltipVisible,
        legendVisible: this.legendVisible,
        extend: this.extend
      };
      var option = line(columns, rows, this.settings, extra);
      this.huiChartOption = _extends$d({}, option);
    }
  }
};
var _hoisted_1$f = {
  class: "hui-chart chart-box"
};
function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$f, [createElementVNode(
    "div",
    {
      ref: "chartRef",
      style: normalizeStyle({
        width: _ctx.width,
        height: _ctx.height
      })
    },
    null,
    4
    /* STYLE */
  ), renderSlot(_ctx.$slots, "default")]);
}
var HuiChartsLine = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$g]]);
HuiChartsLine.install = function(Vue) {
  Vue.component(HuiChartsLine.name, HuiChartsLine);
};

function _extends$c() {
  return _extends$c = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends$c.apply(null, arguments);
}
var AMapCoordSys = /* @__PURE__ */ function() {
  function AMapCoordSys2(amap, api) {
    this._amap = amap;
    this.dimensions = ["lng", "lat"];
    this._mapOffset = [0, 0];
    this._api = api;
  }
  AMapCoordSys2.create = function create(ecModel, api) {
    var tinySys;
    var root = api.getDom();
    ecModel.eachComponent("amap", function(tinyModel) {
      var viewportRoot = api.getZr().painter.getViewportRoot();
      if (typeof window.AMap === "undefined") {
        throw new TypeError("AMap api is not loaded");
      }
      if (tinySys) {
        throw new Error("Only one amap component can exist");
      }
      if (!tinyModel.__amap) {
        var amapRoot = root.querySelector(".ec-extension-amap");
        if (amapRoot) {
          viewportRoot.style.left = "0px";
          viewportRoot.style.top = "0px";
          root.removeChild(amapRoot);
        }
        amapRoot = document.createElement("div");
        amapRoot.style.cssText = "width:100%;height:100%";
        amapRoot.classList.add("ec-extension-amap");
        root.appendChild(amapRoot);
        var options = tinyModel.get() || {};
        options = tinyModel.__options = echarts.util.clone(options);
        var amap = tinyModel.__amap = new window.AMap.Map(amapRoot, options);
        var layer = tinyModel.__layer = new window.AMap.CustomLayer(viewportRoot);
        layer.setMap(amap);
      }
      var tinyApm = tinyModel.getAMap();
      var tinyOut = tinyModel.getLayer();
      tinyOut.hide();
      var tinyZoom = tinyApm.getZoom();
      var tinyCenter = tinyApm.getCenter();
      tinySys = new AMapCoordSys2(tinyApm, api);
      tinySys.setMapOffset(tinyModel.__mapOffset || [0, 0]);
      tinySys.setZoom(tinyZoom);
      tinySys.setCenter([tinyCenter.lng, tinyCenter.lat]);
      tinyModel.coordinateSystem = tinySys;
      tinyOut.show();
    });
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.get("coordinateSystem") === "amap") {
        seriesModel.coordinateSystem = tinySys;
      }
    });
  };
  var _proto = AMapCoordSys2.prototype;
  _proto.setZoom = function setZoom(zoom) {
    this._zoom = zoom;
  };
  _proto.setCenter = function setCenter(center) {
    this._center = this._amap.lnglatToPixel(center);
  };
  _proto.setMapOffset = function setMapOffset(mapOffset) {
    this._mapOffset = mapOffset;
  };
  _proto.getAMap = function getAMap() {
    return this._amap;
  };
  _proto.dataToPoint = function dataToPoint(data2) {
    var point = new window.AMap.LngLat(data2[0], data2[1]);
    var px = this._amap.lngLatToContainer(point);
    var mapOffset = this._mapOffset;
    return [px.x - mapOffset[0], px.y - mapOffset[1]];
  };
  _proto.pointToData = function pointToData(pt) {
    var mapOffset = this._mapOffset;
    pt = this._amap.containerToLngLat({
      x: pt[0] + mapOffset[0],
      y: pt[1] + mapOffset[1]
    });
    return [pt.lng, pt.lat];
  };
  _proto.getViewRect = function getViewRect() {
    var api = this._api;
    return new echarts.graphic.BoundingRect(0, 0, api.getWidth(), api.getHeight());
  };
  _proto.getRoamTransform = function getRoamTransform() {
    return echarts.matrix.create();
  };
  return AMapCoordSys2;
}();
var equal = function equal2(x, y) {
  return x && y && x[0] === y[0] && x[1] === y[1];
};
function extendComponentModel() {
  echarts.extendComponentModel({
    type: "amap",
    getAMap: function getAMap() {
      return this.__amap;
    },
    getLayer: function getLayer() {
      return this.__layer;
    },
    getMapOptions: function getMapOptions() {
      return this.__options;
    },
    setCenterAndZoom: function setCenterAndZoom(center, zoom) {
      this.huiChartOption.center = center;
      this.huiChartOption.zoom = zoom;
    },
    centerOrZoomChanged: function centerOrZoomChanged(center, zoom) {
      var option = this.huiChartOption;
      return !(equal(center, option.center) && zoom === option.zoom);
    },
    defaultOption: {
      center: [116.397475, 39.908695],
      zoom: 4
    }
  });
}
var setLaterFunc = function setLaterFunc2(ctx) {
  ctx.later = function() {
    ctx.lock = false;
    if (ctx.args) {
      ctx.wrapperFn.apply(ctx.context, ctx.args);
      ctx.args = false;
    }
  };
};
var setWrapperFunc = function setWrapperFunc2(ctx) {
  ctx.wrapperFn = function() {
    if (ctx.lock) {
      ctx.args = arguments;
    } else {
      ctx.fn.apply(ctx.context, arguments);
      setTimeout(ctx.later, ctx.time);
      ctx.lock = true;
    }
  };
};
var throttle = function throttle2(fn, time, context) {
  var ctx = {
    fn,
    time,
    context,
    lock: void 0,
    args: void 0,
    wrapperFn: void 0,
    later: void 0
  };
  setLaterFunc(ctx);
  setWrapperFunc(ctx);
  return ctx.wrapperFn;
};
var backupListener = function backupListener2(_ref) {
  var _vm = _ref._vm, throttledResizeHandler = _ref.throttledResizeHandler, zoomEndHandler = _ref.zoomEndHandler;
  _vm._oldZoomEndHandler = zoomEndHandler;
  _vm._oldResizeHandler = throttledResizeHandler;
};
var addListener = function addListener2(_ref2) {
  var aMapModel = _ref2.aMapModel, amap = _ref2.amap, throttledResizeHandler = _ref2.throttledResizeHandler, zoomEndHandler = _ref2.zoomEndHandler;
  amap.on("zoomend", zoomEndHandler);
  amap.on("moveend", zoomEndHandler);
  amap.on("complete", zoomEndHandler);
  aMapModel.get("resizeEnable") && amap.on("resize", throttledResizeHandler);
};
var removeListener = function removeListener2(_ref3) {
  var _vm = _ref3._vm, aMapModel = _ref3.aMapModel, amap = _ref3.amap;
  amap.off("zoomend", _vm._oldZoomEndHandler);
  amap.off("moveend", _vm._oldZoomEndHandler);
  amap.off("complete", _vm._oldZoomEndHandler);
  aMapModel.get("resizeEnable") && amap.off("resize", _vm._oldResizeHandler);
};
var getResizeHandler = function getResizeHandler2(_ref4) {
  var _vm = _ref4._vm, api = _ref4.api, moveHandler = _ref4.moveHandler;
  return function(e) {
    echarts.getInstanceByDom(api.getDom()).resize();
    moveHandler.call(_vm, e);
  };
};
var getZoomEndHandler = function getZoomEndHandler2(_ref5) {
  var api = _ref5.api, rendering = _ref5.rendering;
  return function() {
    if (rendering) {
      return;
    }
    api.dispatchAction({
      type: "amapRoam"
    });
  };
};
var getMoveHandler = function getMoveHandler2(_ref6) {
  var aMapModel = _ref6.aMapModel, api = _ref6.api, coordSys = _ref6.coordSys, rendering = _ref6.rendering, viewportRoot = _ref6.viewportRoot;
  return function() {
    if (rendering) {
      return;
    }
    var offsetEl = viewportRoot.parentNode.parentNode.parentNode;
    var mapOffset = [-parseInt(offsetEl.style.left, 10) || 0, -parseInt(offsetEl.style.top, 10) || 0];
    aMapModel.__mapOffset = mapOffset;
    coordSys.setMapOffset(mapOffset);
    viewportRoot.style.left = mapOffset[0] + "px";
    viewportRoot.style.top = mapOffset[1] + "px";
    api.dispatchAction({
      type: "amapRoam"
    });
  };
};
function extendComponentView() {
  echarts.extendComponentView({
    type: "amap",
    render: function render(aMapModel, ecModel, api) {
      var rendering = true;
      var amap = aMapModel.getAMap();
      var viewportRoot = api.getZr().painter.getViewportRoot();
      var coordSys = aMapModel.coordinateSystem;
      var moveHandler = getMoveHandler({
        aMapModel,
        api,
        coordSys,
        rendering,
        viewportRoot
      });
      var zoomEndHandler = getZoomEndHandler({
        api,
        rendering
      });
      var resizeHandler = getResizeHandler({
        _vm: this,
        api,
        moveHandler
      });
      var throttledResizeHandler = throttle(resizeHandler, 300, amap);
      removeListener({
        _vm: this,
        aMapModel,
        amap
      });
      addListener({
        aMapModel,
        amap,
        throttledResizeHandler,
        zoomEndHandler
      });
      backupListener({
        _vm: this,
        throttledResizeHandler,
        zoomEndHandler
      });
      rendering = false;
    }
  });
}
function registerAmap() {
  echarts.registerCoordinateSystem("amap", AMapCoordSys);
  extendComponentModel();
  extendComponentView();
  echarts.registerAction({
    type: "amapRoam",
    event: "amapRoam",
    update: "updateLayout"
  }, function(payload, ecModel) {
    ecModel.eachComponent("amap", function(aMapModel) {
      var amap = aMapModel.getAMap();
      var center = amap.getCenter();
      aMapModel.setCenterAndZoom([center.lng, center.lat], amap.getZoom());
    });
  });
}
var _sfc_main$f = {
  name: $prefix + "ChartAutonaviMap",
  mixins: [Core],
  data: function data() {
    return {
      iChartName: "AutonaviMapChart"
    };
  },
  mounted: function mounted() {
    registerAmap();
  },
  methods: {
    updateChart: function updateChart() {
      var _this = this;
      if (this.options && Object.keys(this.options).length) {
        this.huiChartOption = _extends$c({}, this.options, this.settings);
        if (!this.tooltipVisible) {
          this.huiChartOption.tooltip = {
            show: false
          };
        }
        if (!this.legendVisible) {
          this.huiChartOption.legend = {
            show: false
          };
        }
        return;
      }
      var echartsSettings = ["grid", "dataZoom", "visualMap", "toolbox", "title", "legend", "xAxis", "yAxis", "radar", "axisPointer", "brush", "geo", "timeline", "graphic", "backgroundColor", "textStyle"];
      this.huiChartOption = _extends$c({}, this.settings, {
        tooltip: this.tooltipVisible ? this.tooltip : {
          show: false
        },
        series: this.series
      });
      echartsSettings.forEach(function(prop) {
        if (_this[prop]) {
          _this.huiChartOption[prop] = _this[prop];
        }
      });
      if (!this.legendVisible) {
        this.huiChartOption.legend = {
          show: false
        };
      }
    }
  }
};
var _hoisted_1$e = {
  class: "hui-chart chart-box"
};
function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$e, [createElementVNode(
    "div",
    {
      ref: "chartRef",
      style: normalizeStyle({
        width: _ctx.width,
        height: _ctx.height
      })
    },
    null,
    4
    /* STYLE */
  ), renderSlot(_ctx.$slots, "default")]);
}
var AutonaviMap = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$f]]);
AutonaviMap.install = function(Vue) {
  Vue.component(AutonaviMap.name, AutonaviMap);
};

function _extends$b() {
  return _extends$b = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends$b.apply(null, arguments);
}
var _sfc_main$e = {
  name: $prefix + "ChartBaiduMap",
  mixins: [Core],
  data: function data() {
    return {
      iChartName: "BaiduMapChart"
    };
  },
  methods: {
    updateChart: function updateChart() {
      var _this = this;
      if (this.options && Object.keys(this.options).length) {
        this.huiChartOption = _extends$b({}, this.options, this.settings);
        if (!this.tooltipVisible) {
          this.huiChartOption.tooltip = {
            show: false
          };
        }
        return;
      }
      var echartsSettings = ["grid", "dataZoom", "visualMap", "toolbox", "title", "legend", "xAxis", "yAxis", "radar", "axisPointer", "brush", "geo", "timeline", "graphic", "backgroundColor", "textStyle"];
      this.huiChartOption = _extends$b({}, this.settings, {
        tooltip: this.tooltipVisible ? this.tooltip : {
          show: false
        },
        series: this.series
      });
      echartsSettings.forEach(function(prop) {
        if (_this[prop]) {
          _this.huiChartOption[prop] = _this[prop];
        }
      });
      if (!this.legendVisible) {
        this.huiChartOption.legend = {
          show: false
        };
      }
    }
  }
};
var _hoisted_1$d = {
  class: "hui-chart chart-box"
};
function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$d, [createElementVNode(
    "div",
    {
      ref: "chartRef",
      style: normalizeStyle({
        width: _ctx.width,
        height: _ctx.height
      })
    },
    null,
    4
    /* STYLE */
  ), renderSlot(_ctx.$slots, "default")]);
}
var BaiduMap = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$e]]);
BaiduMap.install = function(Vue) {
  Vue.component(BaiduMap.name, BaiduMap);
};

function _extends$a() {
  return _extends$a = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends$a.apply(null, arguments);
}
var getXAxis$1 = function getXAxis2(args) {
  var columns = args.columns, xAxisName = args.xAxisName, axisVisible = args.axisVisible, xAxisType = args.xAxisType;
  return [{
    type: xAxisType,
    nameLocation: "middle",
    nameGap: 22,
    name: xAxisName || "",
    axisTick: {
      show: true,
      lineStyle: {
        color: "#eee"
      }
    },
    data: columns,
    show: axisVisible
  }];
};
var getSeries$5 = function getSeries2(args) {
  var area = args.area, areaStyle = args.areaStyle, itemStyle = args.itemStyle, label = args.label, lineStyle = args.lineStyle, _args$outliers = args.outliers, outliers = _args$outliers === void 0 ? [] : _args$outliers, rows = args.rows;
  var _ref = {}, _ref$series = _ref.series, series = _ref$series === void 0 ? [] : _ref$series, _ref$arr = _ref.arr, arr = _ref$arr === void 0 ? ["boxplot", "scatter"] : _ref$arr;
  arr.forEach(function(item) {
    if (item === "scatter" && !outliers.length) {
      return;
    }
    var data2 = item === "boxplot" ? rows : outliers;
    var seriesItem = {
      name: "",
      type: item,
      data: data2
    };
    area && (seriesItem.areaStyle = {});
    label && (seriesItem.label = label);
    lineStyle && (seriesItem.lineStyle = lineStyle);
    itemStyle && (seriesItem.itemStyle = itemStyle);
    areaStyle && (seriesItem.areaStyle = areaStyle);
    series.push(seriesItem);
  });
  return series;
};
var factoryFmt = function factoryFmt2(_ref2) {
  var yAxisType = _ref2.yAxisType, i = _ref2.i, digit = _ref2.digit;
  return function(val) {
    return getFormatted(val, yAxisType[i], digit);
  };
};
var getYAxis$1 = function getYAxis2(args) {
  var axisVisible = args.axisVisible, digit = args.digit, max = args.max, min = args.min, scale = args.scale, yAxisName = args.yAxisName, yAxisType = args.yAxisType;
  var yAxisBase = {
    type: "value",
    axisTick: {
      show: false
    },
    show: axisVisible
  };
  var _ref3 = {}, _ref3$yAxis = _ref3.yAxis, yAxis = _ref3$yAxis === void 0 ? [] : _ref3$yAxis, _ref3$len = _ref3.len, len = _ref3$len === void 0 ? yAxisType.length >= 2 ? 2 : 1 : _ref3$len, _ref3$i = _ref3.i, i = _ref3$i === void 0 ? 0 : _ref3$i;
  for (; i < len; i++) {
    if (!yAxisType[i]) {
      yAxis[i] = _extends$a({}, yAxisBase);
    } else {
      var formatter = factoryFmt({
        yAxisType,
        i,
        digit
      });
      var yAxisAdv = {
        axisLabel: {
          formatter
        }
      };
      yAxis[i] = _extends$a({}, yAxisBase, yAxisAdv);
      var name = yAxisName[i] || "";
      Object.assign(yAxis[i], {
        name,
        scale: scale[i] || false,
        min: min[i] || null,
        max: max[i] || null
      });
    }
  }
  return yAxis;
};
var getTooltip$a = function getTooltip2() {
  return {
    trigger: "item",
    formatter: function formatter(item) {
      var tpl = [];
      var name = item.name, value = item.value, color = item.color, dataType = item.dataType;
      color && tpl.push(itemPoint(color));
      tpl.push(itemLabel("" + name, !value));
      if (dataType === "node") {
        value && tpl.push(itemContent(value) + "<br />");
      }
      return tpl.join("");
    }
  };
};
var boxplot = function boxplot2(columns, rows, settings, extra) {
  rows = Array.isArray(rows) ? rows : [];
  columns = Array.isArray(columns) ? columns : [];
  var _settings$axisSite = settings.axisSite, axisSite = _settings$axisSite === void 0 ? {} : _settings$axisSite, _settings$yAxisType = settings.yAxisType, yAxisType = _settings$yAxisType === void 0 ? ["normal"] : _settings$yAxisType, _settings$xAxisType = settings.xAxisType, xAxisType = _settings$xAxisType === void 0 ? "category" : _settings$xAxisType, _settings$yAxisName = settings.yAxisName, yAxisName = _settings$yAxisName === void 0 ? "" : _settings$yAxisName, _settings$xAxisName = settings.xAxisName, xAxisName = _settings$xAxisName === void 0 ? "" : _settings$xAxisName;
  var _settings$axisVisible = settings.axisVisible, axisVisible = _settings$axisVisible === void 0 ? true : _settings$axisVisible, area = settings.area, _settings$scale = settings.scale, scale = _settings$scale === void 0 ? [false, false] : _settings$scale, _settings$min = settings.min, min = _settings$min === void 0 ? [null, null] : _settings$min, _settings$max = settings.max, max = _settings$max === void 0 ? [null, null] : _settings$max;
  var _settings$nullAddZero = settings.nullAddZero, nullAddZero = _settings$nullAddZero === void 0 ? false : _settings$nullAddZero, _settings$digit = settings.digit, digit = _settings$digit === void 0 ? 2 : _settings$digit; settings.legendName; var _settings$labelMap = settings.labelMap, labelMap = _settings$labelMap === void 0 ? {} : _settings$labelMap, label = settings.label, itemStyle = settings.itemStyle;
  var lineStyle = settings.lineStyle, areaStyle = settings.areaStyle, _settings$tooltipLabe = settings.tooltipLabel, tooltipLabel = _settings$tooltipLabe === void 0 ? ["lower", "Q1", "median", "Q3", "upper"] : _settings$tooltipLabe;
  extra.legendVisible; var outliers = extra.outliers, tooltipFormatter = extra.tooltipFormatter, tooltipVisible = extra.tooltipVisible;
  var metrics = columns.slice();
  if (axisSite.right && axisSite.left) {
    metrics = axisSite.left.concat(axisSite.right);
  } else if (!axisSite.right && axisSite.left) {
    metrics = axisSite.left;
  } else if (settings.metrics) {
    metrics = settings.metrics;
  }
  var getParams = function getParams2() {
    return {
      tooltipFormatter,
      tooltipLabel: htmlHandler(tooltipLabel),
      digit
    };
  };
  tooltipVisible && getTooltip$a(getParams());
  var xAxis = getXAxis$1({
    columns,
    xAxisName,
    axisVisible,
    xAxisType
  });
  var yAxisParams = {
    yAxisName,
    yAxisType,
    axisVisible
  };
  Object.assign(yAxisParams, {
    scale,
    min,
    max,
    digit
  });
  var yAxis = getYAxis$1(yAxisParams);
  var seriesParams = {
    rows,
    axisSite,
    metrics,
    area,
    nullAddZero,
    labelMap,
    label
  };
  Object.assign(seriesParams, {
    itemStyle,
    lineStyle,
    areaStyle,
    xAxisType,
    outliers
  });
  getSeries$5(seriesParams);
  return {
    xAxis,
    yAxis,
    data: extra.data
  };
};
var _sfc_main$d = {
  name: $prefix + "ChartBoxplot",
  mixins: [Core],
  data: function data() {
    return {
      iChartName: "BoxplotChart"
    };
  },
  methods: {
    updateChart: function updateChart(data2) {
      var _data$columns = data2.columns, columns = _data$columns === void 0 ? [] : _data$columns, _data$rows = data2.rows, rows = _data$rows === void 0 ? [] : _data$rows;
      var extra = {
        tooltipVisible: this.tooltipVisible,
        extend: this.extend,
        data: prepareBoxplotData && Array.isArray(data2) ? data2 : null
      };
      var option = boxplot(columns, rows, this.settings, extra);
      this.huiChartOption = _extends$a({}, option);
    },
    prepareBoxplotData: function prepareBoxplotData$1(data2) {
      return prepareBoxplotData(data2);
    }
  }
};
var _hoisted_1$c = {
  class: "hui-chart chart-box"
};
function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$c, [createElementVNode(
    "div",
    {
      ref: "chartRef",
      style: normalizeStyle({
        width: _ctx.width,
        height: _ctx.height
      })
    },
    null,
    4
    /* STYLE */
  ), renderSlot(_ctx.$slots, "default")]);
}
var HuiChartsBoxplot = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$d]]);
HuiChartsBoxplot.install = function(Vue) {
  Vue.component(HuiChartsBoxplot.name, HuiChartsBoxplot);
};

var isNull = function isNull2(x) {
  return x === null || x === void 0;
};
var defaultKName = "";
var getLegend$1 = function getLegend2(args) {
  var legendVisible = args.legendVisible;
  if (!legendVisible) {
    return {
      show: false
    };
  }
  var MA = args.MA, labelMap = args.labelMap, legendName = args.legendName, showMA = args.showMA;
  var data2 = [defaultKName];
  showMA && (data2 = data2.concat(MA.map(function(v) {
    return "MA" + v;
  })));
  data2 = data2.map(function(v) {
    return {
      name: v
    };
  });
  var formatter = function formatter2(name) {
    var temp = labelMap[name];
    return isNull(legendName[name]) ? isNull(temp) ? name : temp : legendName[name];
  };
  return {
    show: true,
    data: data2,
    formatter
  };
};
var getTooltip$9 = function getTooltip2(args) {
  var dataType = args.dataType, digit = args.digit, labelMap = args.labelMap, metrics = args.metrics;
  var position = function position2(pos, params, dom, rect, size) {
    var result = {
      top: 10
    };
    var side = pos[0] < size.viewSize[0] / 2 ? "right" : "left";
    result[side] = 60;
    return result;
  };
  var formatter = function formatter2(options) {
    var tplt = [];
    tplt.push(itemContent(options[0].axisValue) + "<br>");
    options.forEach(function(opt) {
      var color = opt.color, componentSubType = opt.componentSubType, data2 = opt.data, seriesName = opt.seriesName;
      var name = isNull(labelMap[seriesName]) ? seriesName : labelMap[seriesName];
      tplt.push("" + itemPoint(color) + itemLabel(name) + ": ");
      if (componentSubType === "candlestick") {
        tplt.push("<br>");
        metrics.slice(0, 4).forEach(function(m, i) {
          var name2 = isNull(labelMap[m]) ? m : labelMap[m];
          var value2 = getFormatted(data2[i + 1], dataType, digit);
          tplt.push("" + itemLabel("- " + name2) + itemContent(value2) + "<br>");
        });
      } else if (componentSubType === "line") {
        var value = getFormatted(data2, dataType, digit);
        tplt.push(itemContent(value) + "<br>");
      } else if (componentSubType === "bar") {
        var _value = getFormatted(data2[1], dataType, digit);
        tplt.push(itemContent(_value) + "<br>");
      }
    });
    return tplt.join("");
  };
  return {
    axisPointer: {
      type: "cross"
    },
    formatter,
    position,
    trigger: "axis"
  };
};
var getData$4 = function getData2(args) {
  var rows = args.rows, dimension = args.dimension, metrics = args.metrics;
  return rows.map(function(item) {
    var _ref2;
    if (Array.isArray(item)) {
      var _ref;
      var newKeys = metrics.map(function(keyname) {
        return keyname === "vol" ? "volume" : keyname;
      });
      newKeys.unshift(dimension);
      return _ref = {}, _ref[newKeys[0]] = item[0], _ref[newKeys[1]] = item[1], _ref[newKeys[2]] = item[2], _ref[newKeys[3]] = item[3], _ref[newKeys[4]] = item[4], _ref[newKeys[5]] = item[5], _ref;
    }
    return _ref2 = {}, _ref2[dimension] = item[dimension], _ref2.open = item[metrics[0]], _ref2.close = item[metrics[1]], _ref2.lowest = item[metrics[2]], _ref2.highest = item[metrics[3]], _ref2.volume = item[metrics[4]], _ref2;
  });
};
var candle = function candle2(columns, rows, settings, extra) {
  var _settings$dimension = settings.dimension, dimension = _settings$dimension === void 0 ? columns[0] : _settings$dimension, _settings$metrics = settings.metrics, metrics = _settings$metrics === void 0 ? columns.slice(1, 6) : _settings$metrics, _settings$digit = settings.digit, digit = _settings$digit === void 0 ? 2 : _settings$digit; settings.itemStyle;
  var _settings$labelMap = settings.labelMap, labelMap = _settings$labelMap === void 0 ? {} : _settings$labelMap, _settings$legendName = settings.legendName, legendName = _settings$legendName === void 0 ? {} : _settings$legendName, _settings$MA = settings.MA, MA = _settings$MA === void 0 ? [5, 10, 20, 30] : _settings$MA, _settings$showMA = settings.showMA, showMA = _settings$showMA === void 0 ? false : _settings$showMA, _settings$showVol = settings.showVol, showVol = _settings$showVol === void 0 ? false : _settings$showVol;
  var _settings$showDataZoo = settings.showDataZoom, showDataZoom = _settings$showDataZoo === void 0 ? false : _settings$showDataZoo, _settings$downColor = settings.downColor, downColor = _settings$downColor === void 0 ? "#eb171f" : _settings$downColor, _settings$upColor = settings.upColor, upColor = _settings$upColor === void 0 ? "#00a874" : _settings$upColor;
  var _settings$start = settings.start, start = _settings$start === void 0 ? 50 : _settings$start, _settings$end = settings.end, end = _settings$end === void 0 ? 100 : _settings$end, dataType = settings.dataType;
  var tooltipVisible = extra.tooltipVisible, legendVisible = extra.legendVisible, t2 = extra.t;
  defaultKName = t2("ui.chart.kName");
  var data2 = getData$4({
    dimension,
    metrics,
    rows
  });
  var legend = getLegend$1({
    legendVisible,
    MA,
    labelMap,
    legendName,
    showMA
  });
  var ichartOption = {
    legend,
    MA: showMA ? MA : [],
    volume: showVol,
    data: data2,
    upColor,
    downColor
  };
  if (tooltipVisible) {
    ichartOption.tooltip = getTooltip$9({
      dataType,
      digit,
      labelMap,
      metrics
    });
  }
  if (showDataZoom) {
    ichartOption.dataZoom = {
      show: true,
      start,
      end
    };
  }
  return ichartOption;
};
var _sfc_main$c = {
  name: $prefix + "ChartCandle",
  mixins: [Core],
  data: function data() {
    return {
      iChartName: "CandlestickChart"
    };
  },
  methods: {
    updateChart: function updateChart(data2) {
      var _data$columns = data2.columns, columns = _data$columns === void 0 ? [] : _data$columns, _data$rows = data2.rows, rows = _data$rows === void 0 ? [] : _data$rows;
      var extra = {
        tooltipVisible: this.tooltipVisible,
        legendVisible: this.legendVisible,
        t
      };
      this.huiChartOption = candle(columns, rows, this.settings, extra);
    }
  }
};
var _hoisted_1$b = {
  class: "hui-chart chart-box"
};
function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$b, [createElementVNode(
    "div",
    {
      ref: "chartRef",
      style: normalizeStyle({
        width: _ctx.width,
        height: _ctx.height
      })
    },
    null,
    4
    /* STYLE */
  ), renderSlot(_ctx.$slots, "default")]);
}
var HuiChartsCandle = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$c]]);
HuiChartsCandle.install = function(Vue) {
  Vue.component(HuiChartsCandle.name, HuiChartsCandle);
};

var getMetrics = function getMetrics2(args) {
  var dimension = args.dimension, columns = args.columns, settings = args.settings;
  var metrics;
  if (settings.metrics) {
    metrics = settings.metrics;
  } else {
    var temp = columns.slice();
    temp.splice(columns.indexOf(dimension), 1);
    metrics = temp[0];
  }
  return metrics;
};
var getFunnelLegend = function getFunnelLegend2(args) {
  var legendVisible = args.legendVisible, data2 = args.data, legendName = args.legendName;
  if (!legendVisible) {
    return {
      show: false
    };
  }
  var show = true;
  function formatter(name) {
    if (legendName[name] === null || legendName[name] === void 0 || legendName[name] === "undefined") {
      return name;
    }
    return legendName[name];
  }
  return {
    show,
    data: data2,
    formatter
  };
};
var getFunnelTooltip = function getFunnelTooltip2(dataType, digit) {
  function formatter(item) {
    var tpl = [];
    tpl.push(itemPoint(item.color));
    tpl.push("" + itemLabel(item.name) + itemContent(getFormatted(item.data.realValue, dataType, digit)));
    return tpl.join("");
  }
  return formatter;
};
var getFunnelSeries = function getFunnelSeries2(args) {
  var selfSeries = [];
  var dimension = args.dimension, metrics = args.metrics, rows = args.rows, sequence = args.sequence, label = args.label, labelLine = args.labelLine, itemStyle = args.itemStyle, useDefaultOrder = args.useDefaultOrder, ascending = args.ascending;
  var _ref = {}, _ref$series = _ref.series, series = _ref$series === void 0 ? {
    type: "funnel"
  } : _ref$series, _ref$falseFunnel = _ref.falseFunnel, falseFunnel = _ref$falseFunnel === void 0 ? false : _ref$falseFunnel;
  series.minSize = 8;
  var innerRows = rows.sort(function(a, b) {
    return sequence.indexOf(a[dimension]) - sequence.indexOf(b[dimension]);
  });
  innerRows.some(function(row, index) {
    return index && row[metrics] > innerRows[index - 1][metrics] && (falseFunnel = true);
  });
  var step = 100 / innerRows.length;
  var total = 0;
  rows.forEach(function(row) {
    total += row[metrics];
  });
  if (falseFunnel && !useDefaultOrder) {
    var handler = function handler2(row, index) {
      return {
        name: row[dimension],
        value: (index + 1) * step,
        realValue: row[metrics]
      };
    };
    series.data = innerRows.slice().reverse().map(handler);
    series.label = {
      position: "inside",
      color: "#fff",
      formatter: function formatter(item) {
        var value = item.value;
        return Number(value / total).toFixed(2) * 100 + "%";
      }
    };
  } else {
    innerRows.sort(function(a, b) {
      return b[metrics] - a[metrics];
    });
    series.data = innerRows.map(function(row, index) {
      return {
        name: row[dimension],
        value: (innerRows.length - index) * step,
        realValue: row[metrics]
      };
    });
    series.label = {
      position: "inside",
      color: "#fff",
      formatter: function formatter(item) {
        var data2 = item.data;
        return Number(data2.realValue / total).toFixed(2) * 100 + "%";
      }
    };
  }
  ascending && (series.sort = "ascending");
  label && (series.label = label);
  labelLine && (series.labelLine = labelLine);
  itemStyle && (series.itemStyle = itemStyle);
  selfSeries.push(series);
  return selfSeries;
};
var getIChartOption$2 = function getIChartOption2(outerColumns, outerRows, settings, extra) {
  var _ref2 = {}, _ref2$columns = _ref2.columns, columns = _ref2$columns === void 0 ? outerColumns.slice() : _ref2$columns, _ref2$rows = _ref2.rows, rows = _ref2$rows === void 0 ? outerRows.slice() : _ref2$rows;
  var _settings$dataType = settings.dataType, dataType = _settings$dataType === void 0 ? "normal" : _settings$dataType, _settings$dimension = settings.dimension, dimension = _settings$dimension === void 0 ? columns[0] : _settings$dimension, _settings$sequence = settings.sequence, sequence = _settings$sequence === void 0 ? rows.map(function(row) {
    return row[dimension];
  }) : _settings$sequence;
  var _settings$digit = settings.digit, digit = _settings$digit === void 0 ? 2 : _settings$digit, ascending = settings.ascending, label = settings.label, labelLine = settings.labelLine, _settings$legendName = settings.legendName, legendName = _settings$legendName === void 0 ? {} : _settings$legendName, itemStyle = settings.itemStyle, filterZero = settings.filterZero, useDefaultOrder = settings.useDefaultOrder;
  var tooltipVisible = extra.tooltipVisible, legendVisible = extra.legendVisible;
  var metrics = getMetrics({
    dimension,
    columns,
    settings
  });
  var innerRows = rows.sort(function(a, b) {
    return sequence.indexOf(a[dimension]) - sequence.indexOf(b[dimension]);
  });
  filterZero && (innerRows = innerRows.filter(function(row) {
    return row[metrics];
  }));
  var tooltip = tooltipVisible && getFunnelTooltip(dataType, digit);
  var legend = getFunnelLegend({
    legendVisible,
    data: innerRows.map(function(row) {
      return row[dimension];
    }),
    legendName
  });
  var seriesParam = {
    dimension,
    metrics,
    rows: innerRows,
    sequence,
    label,
    labelLine,
    itemStyle,
    useDefaultOrder,
    ascending
  };
  var series = getFunnelSeries(seriesParam);
  var ichartOption = {
    legend,
    tipHtml: tooltip,
    series
  };
  return ichartOption;
};
var _sfc_main$b = {
  name: $prefix + "ChartFunnel",
  mixins: [Core],
  data: function data() {
    return {
      iChartName: "FunnelChart"
    };
  },
  methods: {
    updateChart: function updateChart() {
      var _this$data = this.data, _this$data$columns = _this$data.columns, columns = _this$data$columns === void 0 ? [] : _this$data$columns, _this$data$rows = _this$data.rows, rows = _this$data$rows === void 0 ? [] : _this$data$rows;
      var extra = {
        legendVisible: this.legendVisible,
        tooltipVisible: this.tooltipVisible
      };
      this.huiChartOption = getIChartOption$2(columns, rows, this.settings, extra);
    }
  }
};
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    "div",
    {
      class: "hui-chart chart-box",
      ref: "chartRef",
      style: normalizeStyle({
        width: _ctx.width,
        height: _ctx.height
      })
    },
    null,
    4
    /* STYLE */
  );
}
var HuiChartsFunnel = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$b]]);
HuiChartsFunnel.install = function(Vue) {
  Vue.component(HuiChartsFunnel.name, HuiChartsFunnel);
};

var _arguments = typeof arguments === "undefined" ? void 0 : arguments;
var getTooltip$8 = function getTooltip2(args) {
  var tooltipFormatter = args.tooltipFormatter, dataType = args.dataType, digit = args.digit;
  var formatter = function formatter2(options) {
    if (tooltipFormatter) {
      return tooltipFormatter.apply(void 0, _arguments);
    }
    var seriesName = options.seriesName, data2 = options.data;
    var value = data2.value, name = data2.name;
    return itemLabel(seriesName) + " " + getFormatted(value, dataType[seriesName], digit) + " " + name;
  };
  return formatter;
};
var getPoint = function getPoint2() {
  return {
    show: false,
    width: 10,
    length: 10,
    icon: "path://M511.999488 819.413462 72.8374 204.586538 951.1626 204.586538Z",
    offsetCenter: [0, "-108%"],
    itemStyle: {
      color: "auto"
    }
  };
};
function getSeries$4(args) {
  var rows = args.rows, dimension = args.dimension, metrics = args.metrics, seriesMap = args.seriesMap, dataName = args.dataName, dataType = args.dataType, digit = args.digit, labelMap = args.labelMap;
  var series = rows.map(function(row) {
    var label = row[dimension];
    var seriesItem = seriesMap[label];
    var formatter2 = function formatter22(value) {
      return getFormatted(value, dataType[label], digit);
    };
    var result = {
      type: "gauge",
      name: !isNull$1(labelMap[label]) ? labelMap[label] : label,
      data: [{
        name: dataName[label] || "",
        value: row[metrics]
      }],
      detail: {
        fontSize: 60,
        color: "#191919",
        offsetCenter: [0, 0],
        valueAnimation: true,
        formatter: !dataType ? "{value}" : function(value) {
          var res = getFormatted(value, dataType[label], digit);
          return dataType[label] === "percent" ? res.split("%")[0] + "{percent|%}" : res;
        },
        rich: {
          percent: {
            fontSize: 12,
            color: "#4e4e4e",
            padding: [0, 0, -20, 0]
          }
        }
      },
      axisLabel: {
        formatter: formatter2
      },
      itemStyle: {
        color: "#6D8FF0"
      },
      pointer: getPoint(),
      axisLine: {
        roundCap: true
      },
      progress: {
        show: true,
        roundCap: true,
        width: 8,
        color: "red"
      },
      axisTick: {
        show: false
      },
      splitLine: {
        length: 8,
        distance: 0,
        lineStyle: {
          width: 1,
          color: "rgba(25,25,25,0.10)"
        }
      },
      title: {
        show: true,
        offsetCenter: [0, "25%"],
        color: "#191919",
        fontSize: 15
      }
    };
    if (seriesItem) {
      Object.keys(seriesItem).forEach(function(key) {
        return isObject(result[key]) ? Object.assign(result[key], seriesItem[key]) : result[key] = seriesItem[key];
      });
    }
    return result;
  });
  return series;
}
var getIChartOption$1 = function getIChartOption2(columns, rows, settings, extra) {
  var _settings$dataName = settings.dataName, dataName = _settings$dataName === void 0 ? {} : _settings$dataName, _settings$dataType = settings.dataType, dataType = _settings$dataType === void 0 ? {} : _settings$dataType, _settings$digit = settings.digit, digit = _settings$digit === void 0 ? 2 : _settings$digit, _settings$labelMap = settings.labelMap, labelMap = _settings$labelMap === void 0 ? {} : _settings$labelMap;
  var _settings$dimension = settings.dimension, dimension = _settings$dimension === void 0 ? columns[0] : _settings$dimension, _settings$metrics = settings.metrics, metrics = _settings$metrics === void 0 ? columns[1] : _settings$metrics, _settings$seriesMap = settings.seriesMap, seriesMap = _settings$seriesMap === void 0 ? {} : _settings$seriesMap;
  var tooltipFormatter = extra.tooltipFormatter, tooltipVisible = extra.tooltipVisible;
  var tooltip = tooltipVisible && getTooltip$8({
    tooltipFormatter,
    dataType,
    digit
  });
  var seriesParams = {
    rows,
    dimension,
    metrics,
    seriesMap,
    dataName,
    dataType,
    digit,
    labelMap
  };
  var series = getSeries$4(seriesParams);
  var seriesName = series[0].name;
  var ichartOption = {
    tipHtml: tooltip,
    series,
    seriesName
  };
  return ichartOption;
};
var _sfc_main$a = {
  name: $prefix + "ChartGauge",
  mixins: [Core],
  data: function data() {
    return {
      iChartName: "GaugeChart"
    };
  },
  methods: {
    updateChart: function updateChart() {
      var _this$data = this.data, _this$data$columns = _this$data.columns, columns = _this$data$columns === void 0 ? [] : _this$data$columns, _this$data$rows = _this$data.rows, rows = _this$data$rows === void 0 ? [] : _this$data$rows;
      var extra = {
        legendVisible: this.legendVisible,
        tooltipVisible: this.tooltipVisible
      };
      this.huiChartOption = getIChartOption$1(columns, rows, this.settings, extra);
    }
  }
};
var _hoisted_1$a = {
  class: "hui-chart chart-box"
};
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$a, [createElementVNode(
    "div",
    {
      ref: "chartRef",
      style: normalizeStyle({
        width: _ctx.width,
        height: _ctx.height
      })
    },
    null,
    4
    /* STYLE */
  ), renderSlot(_ctx.$slots, "default")]);
}
var HuiChartsGauge = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$a]]);
HuiChartsGauge.install = function(Vue) {
  Vue.component(HuiChartsGauge.name, HuiChartsGauge);
};

function _extends$9() {
  return _extends$9 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends$9.apply(null, arguments);
}
var getTooltip$7 = function getTooltip2() {
  return {
    trigger: "item",
    formatter: function formatter(item) {
      var tpl = [];
      var name = item.name, value = item.value, color = item.color, dataType = item.dataType;
      color && tpl.push(itemPoint(color));
      tpl.push(itemLabel("" + name, !value));
      if (dataType === "node") {
        value && tpl.push(itemContent(value) + "<br />");
      }
      return tpl.join("");
    }
  };
};
var getGraphSeries = function getGraphSeries2() {
  return [{
    type: "graph",
    label: {
      textBorderWidth: 1,
      color: "#fff",
      textBorderColor: "inherit"
    }
  }];
};
var graph = function graph2(columns, rows, settings, extra) {
  var tooltipVisible = extra.tooltipVisible;
  var tooltip = tooltipVisible && getTooltip$7();
  var series = getGraphSeries();
  return {
    tooltip,
    series,
    topHtml: tooltip.formatter
  };
};
var _sfc_main$9 = {
  name: $prefix + "ChartGraph",
  mixins: [Core],
  data: function data() {
    return {
      iChartName: "GraphChart"
    };
  },
  methods: {
    updateChart: function updateChart(data2) {
      var _data$columns = data2.columns, columns = _data$columns === void 0 ? [] : _data$columns, _data$rows = data2.rows, rows = _data$rows === void 0 ? [] : _data$rows;
      var extra = {
        tooltipVisible: this.tooltipVisible,
        extend: this.extend
      };
      var option = graph(columns, rows, this.settings, extra);
      this.huiChartOption = _extends$9({}, option);
    }
  }
};
var _hoisted_1$9 = {
  class: "hui-chart chart-box"
};
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$9, [createElementVNode(
    "div",
    {
      ref: "chartRef",
      style: normalizeStyle({
        width: _ctx.width,
        height: _ctx.height
      })
    },
    null,
    4
    /* STYLE */
  ), renderSlot(_ctx.$slots, "default")]);
}
var HuiChartsGraph = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$9]]);
HuiChartsGraph.install = function(Vue) {
  Vue.component(HuiChartsGraph.name, HuiChartsGraph);
};

function _extends$8() {
  return _extends$8 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends$8.apply(null, arguments);
}
var getAxisList = function getAxisList2(rows, label) {
  var result = [];
  rows.forEach(function(row) {
    return !result.includes(row[label]) && result.push(row[label]);
  });
  return result;
};
var getData$3 = function getData2(args) {
  var extraMetrics = args.extraMetrics, innerXAxisList = args.innerXAxisList, innerYAxisList = args.innerYAxisList, metrics = args.metrics, rows = args.rows, type = args.type, xDim = args.xDim, yDim = args.yDim;
  var result = null;
  if (type !== "cartesian") {
    result = rows.map(function(row) {
      return [row[xDim], row[yDim], metrics ? row[metrics] : 1];
    });
  } else {
    result = rows.map(function(row) {
      innerYAxisList.indexOf(row[yDim]);
      innerXAxisList.indexOf(row[xDim]);
      extraMetrics.map(function(m) {
        return row[m] || "-";
      });
      metrics ? row[metrics] : 1;
      return {
        xDim: row[xDim],
        yDim: row[yDim],
        metrics: row[metrics]
      };
    });
  }
  return result;
};
var getAxis = function getAxis2(list, name, type) {
  return {
    data: list,
    name,
    nameLocation: "end",
    type: "category",
    splitArea: {
      show: false
    },
    splitLine: {
      show: true,
      lineStyle: {
        color: "#6d8ff0"
      }
    },
    axisLabel: {
      show: true,
      color: "#4E4E4E"
    },
    position: type === "y" ? 25 : 5,
    zlevel: 1
  };
};
var getVisualMap = function getVisualMap2(args) {
  var min = args.innerMin, max = args.innerMax, type = args.type, heatColor = args.heatColor, series = args.series;
  var _ref = {}, extra = _ref.extra;
  if (type === "map") {
    extra = {};
    !series[0].data.length && (extra.show = false);
  } else if (type === "bmap" || type === "amap") {
    extra = {
      show: false
    };
  } else {
    extra = {
      dimension: 2
    };
  }
  var defaultColor = type === "map" || type === "bmap" || type === "amap" ? HEAT_MAP_COLOR : ["#fff", "#6D8FF0"];
  return Object.assign(extra, {
    min,
    max,
    calculable: true,
    left: "right",
    bottom: "center",
    height: 140,
    position: {
      left: "right",
      bottom: "center"
    },
    orient: "vertical",
    align: "left",
    inverse: true,
    inRange: {
      color: heatColor || defaultColor
    }
  });
};
var getSeries$3 = function getSeries2(args) {
  var series = {
    type: "heatmap",
    data: args.chartData
  };
  return [series];
};
var getTooltip$6 = function getTooltip2(args) {
  var dataType = args.dataType, innerXAxisList = args.innerXAxisList, innerYAxisList = args.innerYAxisList, digit = args.digit; args.extraMetrics; var metrics = args.metrics;
  function formatter(_ref2) {
    var data = _ref2.data, color = _ref2.color;
    var xDim = data[0];
    var yDim = data[1];
    var value = data[2];
    var tplt = [itemContent(innerXAxisList[xDim] + " ~ " + innerYAxisList[yDim]) + "<br>"];
    tplt.push("" + itemPoint(color) + itemLabel(metrics) + itemContent(getFormatted(value, dataType, digit)) + "<br>");
    return tplt.join("");
  }
  return {
    trigger: "item",
    formatter
  };
};
var fixParam = function fixParam2(_ref3) {
  var type = _ref3.type, rows = _ref3.rows, dimension = _ref3.dimension, metrics = _ref3.metrics, extraMetrics = _ref3.extraMetrics, chartData = _ref3.chartData, innerXAxisList = _ref3.innerXAxisList, innerYAxisList = _ref3.innerYAxisList;
  var chartDataParams;
  if (type !== "cartesian") {
    chartDataParams = {
      rows,
      xDim: dimension[0],
      yDim: dimension[1]
    };
    Object.assign(chartDataParams, {
      metrics,
      type,
      extraMetrics
    });
    chartData = getData$3(chartDataParams);
  } else {
    var flag = !innerXAxisList || !innerXAxisList.length;
    flag && (innerXAxisList = getAxisList(rows, dimension[0]));
    flag = !innerYAxisList || !innerYAxisList.length;
    flag && (innerYAxisList = getAxisList(rows, dimension[1]));
    chartDataParams = {
      xDim: dimension[0],
      yDim: dimension[1],
      rows
    };
    Object.assign(chartDataParams, {
      innerXAxisList,
      innerYAxisList,
      metrics,
      type,
      extraMetrics
    });
    chartData = getData$3(chartDataParams);
  }
  return {
    chartData,
    innerXAxisList,
    innerYAxisList
  };
};
var getResult = function getResult2(args) {
  var type = args.type, options = args.options, pointSize = args.pointSize, blurSize = args.blurSize, res = args.res; args.key; args.v; args.url; args.bmap; var mapOrigin = args.mapOrigin, geo = args.geo, beforeRegisterMap = args.beforeRegisterMap, visualMap = args.visualMap;
  var _args$echarts = args.echarts, echarts$1 = _args$echarts === void 0 ? echarts : _args$echarts, specialAreas = args.specialAreas, position = args.position, positionJsonLink = args.positionJsonLink, beforeRegisterMapOnce = args.beforeRegisterMapOnce;
  var mapURLProfix = args.mapURLProfix; args.amap; var tooltip = args.tooltip, xAxis = args.xAxis, yAxis = args.yAxis;
  if (type === "bmap" || type === "amap") {
    Object.assign(options.series[0], {
      coordinateSystem: type,
      pointSize,
      blurSize
    });
    res = _extends$8({}, args);
  } else if (type === "map") {
    options.series[0].coordinateSystem = "geo";
    var jsonStr = JSON.stringify(mapOrigin);
    if (jsonStr) {
      var geoAttr = _extends$8({
        map: jsonStr
      }, geo);
      beforeRegisterMap && (jsonStr = beforeRegisterMap(mapOrigin));
      echarts$1.registerMap(jsonStr, {
        geoJSON: mapOrigin
      }, specialAreas);
      res = _extends$8({
        geo: geoAttr
      }, options);
    } else {
      var params = {
        position,
        positionJsonLink,
        beforeRegisterMapOnce,
        mapURLProfix
      };
      res = getMapJSON(params).then(function(json) {
        var geoAttr2 = _extends$8({
          map: position
        }, geo);
        beforeRegisterMap && (json = beforeRegisterMap(json));
        echarts$1.registerMap(position, {
          geoJSON: json
        }, specialAreas);
        return _extends$8({
          geo: geoAttr2
        }, options, {
          handle: visualMap
        });
      });
    }
  } else {
    res = _extends$8({
      tooltip,
      xAxis,
      yAxis
    }, options, {
      handle: visualMap
    });
  }
  return res;
};
var heatmap = function heatmap2(columns, rows, settings, extra) {
  var _settings$type = settings.type, type = _settings$type === void 0 ? "cartesian" : _settings$type;
  var _settings$dimension = settings.dimension, dimension = _settings$dimension === void 0 ? [columns[0], columns[1]] : _settings$dimension;
  var _settings$dataType = settings.dataType, dataType = _settings$dataType === void 0 ? "normal" : _settings$dataType, min = settings.min, max = settings.max, digit = settings.digit, bmap = settings.bmap, amap = settings.amap, geo = settings.geo, key = settings.key, _settings$v = settings.v, v = _settings$v === void 0 ? "2.0" : _settings$v, url = settings.url;
  var position = settings.position, mapOrigin = settings.mapOrigin, positionJsonLink = settings.positionJsonLink, beforeRegisterMap = settings.beforeRegisterMap, _settings$pointSize = settings.pointSize, pointSize = _settings$pointSize === void 0 ? 10 : _settings$pointSize, _settings$blurSize = settings.blurSize, blurSize = _settings$blurSize === void 0 ? 5 : _settings$blurSize;
  var heatColor = settings.heatColor, yAxisName = settings.yAxisName, xAxisName = settings.xAxisName, beforeRegisterMapOnce = settings.beforeRegisterMapOnce, _settings$specialArea = settings.specialAreas, specialAreas = _settings$specialArea === void 0 ? {} : _settings$specialArea;
  var _settings$metrics = settings.metrics, metrics = _settings$metrics === void 0 ? columns[2] : _settings$metrics, _settings$mapURLProfi = settings.mapURLProfix, mapURLProfix = _settings$mapURLProfi === void 0 ? "https://unpkg.com/echarts@3.6.2/map/json/" : _settings$mapURLProfi;
  var tooltipVisible = extra.tooltipVisible, echarts2 = extra.echartsLib;
  var innerXAxisList = settings.xAxisList, innerYAxisList = settings.yAxisList;
  var _ref4 = {}, _ref4$chartData = _ref4.chartData, chartData = _ref4$chartData === void 0 ? [] : _ref4$chartData, _ref4$extraMetrics = _ref4.extraMetrics, extraMetrics = _ref4$extraMetrics === void 0 ? [] : _ref4$extraMetrics, _ref4$mainColumn = _ref4.mainColumn, mainColumn = _ref4$mainColumn === void 0 ? dimension.concat([metrics]) : _ref4$mainColumn;
  columns.forEach(function(column) {
    return !~mainColumn.indexOf(column) && extraMetrics.push(column);
  });
  var ret = fixParam({
    type,
    rows,
    dimension,
    metrics,
    extraMetrics,
    chartData,
    innerXAxisList,
    innerYAxisList
  });
  chartData = ret.chartData;
  innerXAxisList = ret.innerXAxisList;
  innerYAxisList = ret.innerYAxisList;
  var metricsList = metrics ? rows.map(function(row) {
    return row[metrics];
  }) : [0, 5];
  !metricsList.length && (metricsList = [0]);
  var innerMin = min || Math.min.apply(null, metricsList);
  var innerMax = max || Math.max.apply(null, metricsList);
  var xAxis = getAxis(innerXAxisList, xAxisName, "x");
  var yAxis = getAxis(innerYAxisList, yAxisName, "y");
  var series = getSeries$3({
    chartData,
    type
  });
  var visualMap = getVisualMap({
    innerMin,
    innerMax,
    type,
    heatColor,
    series
  });
  var tooltipParams = {
    dataType,
    innerXAxisList,
    innerYAxisList,
    digit,
    extraMetrics,
    metrics
  };
  var tooltip = tooltipVisible ? getTooltip$6(tooltipParams) : {
    show: false
  };
  var options = {
    visualMap,
    series
  };
  var res;
  var args = {
    type,
    visualMap,
    series,
    options,
    pointSize,
    blurSize,
    key,
    v,
    url,
    bmap,
    mapOrigin,
    geo,
    beforeRegisterMap
  };
  Object.assign(args, {
    echarts: echarts2,
    specialAreas,
    position,
    positionJsonLink,
    beforeRegisterMapOnce
  });
  Object.assign(args, {
    mapURLProfix,
    amap,
    tooltip
  });
  if (type === "cartesian") {
    Object.assign(args, {
      xAxis,
      yAxis
    });
  }
  res = getResult(args);
  res.data = chartData;
  if (type === "cartesian") {
    res.type = "CalendarHeatMapHuiCharts";
  }
  return res;
};
var _sfc_main$8 = {
  name: $prefix + "ChartHeatmap",
  mixins: [Core],
  computed: {
    iChartName: function iChartName() {
      var type = this.settings.type;
      var mapChartList = {
        bmap: "BaiduMapChart",
        amap: "AutonaviMapChart",
        map: "RegionChart"
      };
      return (type || "").includes("map") ? mapChartList[type] : "HeatMapChart";
    }
  },
  methods: {
    updateChart: function updateChart(data) {
      var _data$columns = data.columns, columns = _data$columns === void 0 ? [] : _data$columns, _data$rows = data.rows, rows = _data$rows === void 0 ? [] : _data$rows;
      var extra = {
        tooltipVisible: this.tooltipVisible,
        legendVisible: this.legendVisible,
        extend: this.extend,
        echartsLib: this.integrateChart.echartIns
      };
      var option = heatmap(columns, rows, this.settings, extra);
      this.huiChartOption = _extends$8({}, option);
    },
    handleMousewheel: function handleMousewheel(e) {
      e = e || window.event;
      if (e.stopPropagation) {
        e.stopPropagation();
      } else {
        e.cancelBubble = true;
      }
      if (e.preventDefault) {
        e.preventDefault();
      } else {
        e.returnValue = false;
      }
      if (e.wheelDelta > 0) {
        this.zoom += 1;
        if (this.zoom > 19) {
          this.zoom = 19;
        }
      }
      if (e.wheelDelta < 0) {
        e.cancelBubble = true;
        this.zoom -= 1;
        if (this.zoom < 4) {
          this.zoom = 4;
        }
      }
    }
  }
};
var _hoisted_1$8 = {
  class: "hui-chart chart-box"
};
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$8, [createElementVNode(
    "div",
    {
      ref: "chartRef",
      style: normalizeStyle({
        width: _ctx.width,
        height: _ctx.height
      }),
      onMousewheel: _cache[0] || (_cache[0] = function() {
        return $options.handleMousewheel && $options.handleMousewheel.apply($options, arguments);
      })
    },
    null,
    36
    /* STYLE, NEED_HYDRATION */
  ), renderSlot(_ctx.$slots, "default")]);
}
var HuiChartsHeatmap = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$8]]);
HuiChartsHeatmap.install = function(Vue) {
  Vue.component(HuiChartsHeatmap.name, HuiChartsHeatmap);
};

var isArr = Array.isArray;
var getTooltip$5 = function getTooltip2(data2) {
  var tooltipFormatter = data2.tooltipFormatter, dataType = data2.dataType, digit = data2.digit;
  function formatter(options) {
    var seriesName = options.seriesName, value = options.value;
    if (!tooltipFormatter) {
      return ["" + itemLabel(seriesName), itemContent(getFormatted(value, dataType, digit))].join("");
    }
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return tooltipFormatter.apply(void 0, [options].concat(args));
  }
  return formatter;
};
var getSeries$2 = function getSeries2(args) {
  var dimension = args.dimension, metrics = args.metrics, rows = args.rows, seriesMap = args.seriesMap, wave = args.wave;
  var itemWave = wave;
  var len = isArr(seriesMap) ? seriesMap.length : 0;
  return rows.slice().map(function(item, index) {
    var _ref = {}, _ref$data = _ref.data, data2 = _ref$data === void 0 ? [] : _ref$data, _ref$result = _ref.result, result = _ref$result === void 0 ? {
      type: "liquidFill"
    } : _ref$result, _ref$name = _ref.name, name = _ref$name === void 0 ? item[dimension] : _ref$name;
    var _ref2 = {}, _ref2$val = _ref2.val, val = _ref2$val === void 0 ? Number(item[metrics]) : _ref2$val, _ref2$itemMap = _ref2.itemMap, itemMap = _ref2$itemMap === void 0 ? {} : _ref2$itemMap;
    if (isArr(seriesMap)) {
      itemMap = seriesMap[index] ? seriesMap[index] : seriesMap[len - 1];
    } else if (isObject(seriesMap[name])) {
      itemMap = seriesMap[name];
    }
    if (isArr(wave) && isArr(wave[0])) {
      itemWave = !isArr(wave[index]) ? wave[wave.length - 1] : wave[index];
    }
    data2.push({
      value: val
    });
    if (itemWave.length && itemWave) {
      data2 = data2.concat(itemWave.map(function(val2) {
        return {
          value: val2
        };
      }));
    }
    result.itemStyle = {
      shadowBlur: 0
    };
    result.label = {
      color: "#6D8FF0"
    };
    result.backgroundStyle = {
      color: "#F4F3F9"
    };
    result.outline = {
      itemStyle: {
        borderColor: "#6D8FF0",
        shadowBlur: 0
      }
    };
    !itemMap.color && (result.itemStyle = Object.assign(result.itemStyle, {
      color: "#6D8FF0"
    }));
    result = Object.assign(result, {
      data: data2,
      name
    }, itemMap);
    return result;
  });
};
var getIChartOption = function getIChartOption2(columns, rows, settings, extra) {
  var _settings$dimension = settings.dimension, dimension = _settings$dimension === void 0 ? columns[0] : _settings$dimension, _settings$metrics = settings.metrics, metrics = _settings$metrics === void 0 ? columns[1] : _settings$metrics;
  var _settings$seriesMap = settings.seriesMap, seriesMap = _settings$seriesMap === void 0 ? {} : _settings$seriesMap, _settings$dataType = settings.dataType, dataType = _settings$dataType === void 0 ? "percent" : _settings$dataType, _settings$digit = settings.digit, digit = _settings$digit === void 0 ? 2 : _settings$digit, _settings$wave = settings.wave, wave = _settings$wave === void 0 ? [] : _settings$wave;
  var tooltipVisible = extra.tooltipVisible, tooltipFormatter = extra.tooltipFormatter;
  var tooltip = tooltipVisible && getTooltip$5({
    tooltipFormatter,
    dataType,
    digit
  });
  var series = getSeries$2({
    rows,
    columns,
    dimension,
    metrics,
    seriesMap,
    wave
  });
  var ichartOption = {
    tipHtml: tooltip,
    legend: {
      show: false
    },
    series
  };
  return ichartOption;
};
var _sfc_main$7 = {
  name: $prefix + "ChartLiquidfill",
  mixins: [Core],
  data: function data() {
    return {
      iChartName: "LiquidfillChart"
    };
  },
  methods: {
    updateChart: function updateChart() {
      var _this$data = this.data, _this$data$columns = _this$data.columns, columns = _this$data$columns === void 0 ? [] : _this$data$columns, _this$data$rows = _this$data.rows, rows = _this$data$rows === void 0 ? [] : _this$data$rows;
      var extra = {
        legendVisible: this.legendVisible,
        tooltipVisible: this.tooltipVisible
      };
      this.huiChartOption = getIChartOption(columns, rows, this.settings, extra);
    }
  }
};
var _hoisted_1$7 = {
  class: "hui-chart chart-box"
};
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$7, [createElementVNode(
    "div",
    {
      ref: "chartRef",
      style: normalizeStyle({
        width: _ctx.width,
        height: _ctx.height
      })
    },
    null,
    4
    /* STYLE */
  ), renderSlot(_ctx.$slots, "default")]);
}
var HuiChartsLiquidfill = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7]]);
HuiChartsLiquidfill.install = function(Vue) {
  Vue.component(HuiChartsLiquidfill.name, HuiChartsLiquidfill);
};

function _extends$7() {
  return _extends$7 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends$7.apply(null, arguments);
}
var getLegendMap = function getLegendMap2(args, legendItemStyle) {
  var metrics = args.metrics, legendName = args.legendName, labelMap = args.labelMap;
  if (!labelMap && !legendName) {
    return {
      data: metrics
    };
  }
  var data2 = labelMap ? metrics.map(function(item) {
    return isNull$1(labelMap[item]) ? item : labelMap[item];
  }) : metrics;
  return _extends$7({}, legendItemStyle, {
    data: data2,
    formatter: function formatter(name) {
      return isNull$1(legendName[name]) ? name : legendName[name];
    }
  });
};
var getTooltip$4 = function getTooltip2(_ref) {
  var dataType = _ref.dataType, digit = _ref.digit, dataStore = _ref.dataStore, metrics = _ref.metrics, color = _ref.color, labelMap = _ref.labelMap;
  function formatter(item) {
    var tplt = [];
    if (!item.name) {
      return "";
    }
    tplt.push(itemLabel(item.name) + "<br>");
    metrics.forEach(function(label, index) {
      var title = isNull$1(labelMap[label]) ? label : labelMap[label];
      tplt.push("" + itemPoint(color[index]) + itemLabel(title));
      if (dataStore[item.name]) {
        tplt.push(itemContent(getFormatted(dataStore[item.name][label], dataType[label], digit)));
      } else {
        tplt.push(itemContent("-"));
      }
      tplt.push("<br>");
    });
    return tplt.join("");
  }
  return {
    trigger: "item",
    formatter
  };
};
var setGeoLabel = function setGeoLabel2(value, target, label) {
  if (typeof value === "object") {
    target[label] = value;
  } else if (value) {
    target[label] = {
      show: true
    };
  }
};
var getSeries$1 = function getSeries2(args) {
  var position = args.position, selectData = args.selectData, dimension = args.dimension, metrics = args.metrics, rows = args.rows, label = args.label, selectedMode = args.selectedMode, roam = args.roam, center = args.center, aspectScale = args.aspectScale, zoom = args.zoom;
  var boundingCoords = args.boundingCoords, labelMap = args.labelMap, scaleLimit = args.scaleLimit, mapGrid = args.mapGrid, _args$itemStyle = args.itemStyle, itemStyle = _args$itemStyle === void 0 ? {
    areaColor: "rgba(25,25,25,0.05)"
  } : _args$itemStyle;
  var _ref2 = {}, _ref2$result = _ref2.result, result = _ref2$result === void 0 ? [] : _ref2$result, _ref2$mapBase = _ref2.mapBase, mapBase = _ref2$mapBase === void 0 ? {
    type: "map",
    map: position
  } : _ref2$mapBase;
  var _ref3 = {}, _ref3$emphasis = _ref3.emphasis, emphasis = _ref3$emphasis === void 0 ? {
    itemStyle: {
      areaColor: "rgba(25,25,25,0.2)"
    },
    label: {
      color: "#191919"
    }
  } : _ref3$emphasis;
  metrics.forEach(function(itemName) {
    var name = !isNull$1(labelMap[itemName]) ? labelMap[itemName] : itemName;
    var data2 = [];
    var itemResult = _extends$7({
      name,
      data: data2,
      selectedMode,
      roam,
      center,
      aspectScale,
      boundingCoords,
      zoom,
      scaleLimit
    }, mapBase);
    if (mapGrid) {
      Object.keys(mapGrid).forEach(function(key) {
        return itemResult[key] = mapGrid[key];
      });
    }
    setGeoLabel(itemStyle, itemResult, "itemStyle");
    setGeoLabel(label, itemResult, "label");
    rows.forEach(function(row) {
      return itemResult.data.push({
        name: row[dimension],
        value: row[itemName],
        selected: selectData
      });
    });
    itemResult.emphasis = emphasis;
    itemResult.label = _extends$7({
      color: "#191919"
    }, itemResult.label);
    result.push(itemResult);
  });
  return result;
};
var registerMap = function registerMap2(args, mapOrigin, echarts2) {
  var _once = args._once, registerSign = args.registerSign, beforeRegisterMap = args.beforeRegisterMap, beforeRegisterMapOnce = args.beforeRegisterMapOnce;
  var registerSignOnce = args.registerSignOnce, position = args.position, specialAreas = args.specialAreas;
  if (!_once[registerSign] && beforeRegisterMap) {
    mapOrigin = beforeRegisterMap(mapOrigin);
  }
  if (!_once[registerSign] && beforeRegisterMapOnce && !_once[registerSignOnce]) {
    _once[registerSignOnce] = true;
    mapOrigin = beforeRegisterMapOnce(mapOrigin);
  }
  if (!_once[registerSign]) {
    _once[registerSign] = true;
    echarts2.registerMap(position, mapOrigin, specialAreas);
  }
};
var map = function map2(columns, rows, settings, extra) {
  var _settings$position = settings.position, position = _settings$position === void 0 ? "" : _settings$position, _settings$selectData = settings.selectData, selectData = _settings$selectData === void 0 ? false : _settings$selectData, selectedMode = settings.selectedMode, _settings$label = settings.label, label = _settings$label === void 0 ? true : _settings$label, _settings$dataType = settings.dataType, dataType = _settings$dataType === void 0 ? {} : _settings$dataType, _settings$digit = settings.digit, digit = _settings$digit === void 0 ? 2 : _settings$digit;
  var _settings$dimension = settings.dimension, dimension = _settings$dimension === void 0 ? columns[0] : _settings$dimension, roam = settings.roam, center = settings.center, aspectScale = settings.aspectScale, boundingCoords = settings.boundingCoords, zoom = settings.zoom;
  var scaleLimit = settings.scaleLimit, _settings$legendName = settings.legendName, legendName = _settings$legendName === void 0 ? {} : _settings$legendName, _settings$labelMap = settings.labelMap, labelMap = _settings$labelMap === void 0 ? {} : _settings$labelMap, mapGrid = settings.mapGrid, itemStyle = settings.itemStyle, positionJsonLink = settings.positionJsonLink, emphasis = settings.emphasis;
  var beforeRegisterMap = settings.beforeRegisterMap, beforeRegisterMapOnce = settings.beforeRegisterMapOnce, _settings$mapURLProfi = settings.mapURLProfix, mapURLProfix = _settings$mapURLProfi === void 0 ? extra.baseUrl || "" : _settings$mapURLProfi, _settings$specialArea = settings.specialAreas, specialAreas = _settings$specialArea === void 0 ? {} : _settings$specialArea;
  var mapOrigin = settings.mapOrigin;
  var metrics = columns.slice(0);
  if (!settings.metrics) {
    metrics.splice(columns.indexOf(dimension), 1);
  } else {
    metrics = settings.metrics;
  }
  var tooltipVisible = extra.tooltipVisible, legendVisible = extra.legendVisible, color = extra.color, _once = extra._once, echarts2 = extra.echarts;
  var dataStore = {};
  rows.forEach(function(row) {
    return dataStore[row[dimension]] = row;
  });
  var tooltip = tooltipVisible ? getTooltip$4({
    dataType,
    digit,
    dataStore,
    metrics,
    color,
    labelMap
  }) : {
    show: false
  };
  var legend = legendVisible ? _extends$7({
    show: true
  }, getLegendMap({
    metrics,
    legendName,
    labelMap
  })) : {
    show: false
  };
  var seriesParams = {
    position,
    selectData,
    label,
    itemStyle,
    dimension,
    metrics,
    rows,
    selectedMode,
    roam
  };
  Object.assign(seriesParams, {
    center,
    aspectScale,
    boundingCoords,
    zoom,
    labelMap,
    scaleLimit,
    mapGrid,
    emphasis
  });
  var series = getSeries$1(seriesParams);
  var registerSign = "MAP_REGISTER_" + position;
  var registerSignOnce = "ONCE_MAP_REGISTER_" + position;
  var registerOptions = {
    _once,
    beforeRegisterMap,
    beforeRegisterMapOnce,
    position
  };
  Object.assign(registerOptions, {
    specialAreas,
    registerSign,
    registerSignOnce
  });
  if (mapOrigin) {
    registerMap(registerOptions, mapOrigin, echarts2);
    return {
      series,
      tooltip,
      legend,
      tipHtml: tooltip.formatter
    };
  }
  var param = {
    position,
    positionJsonLink,
    beforeRegisterMapOnce,
    mapURLProfix
  };
  return getMapJSON(param).then(function(json) {
    registerMap(registerOptions, json, echarts2);
    return {
      series,
      tooltip,
      legend,
      tipHtml: tooltip.formatter
    };
  });
};
var _sfc_main$6 = {
  name: $prefix + "ChartMap",
  mixins: [Core],
  data: function data() {
    return {
      iChartName: "RegionChart"
    };
  },
  methods: {
    updateChart: function updateChart() {
      var _this$data = this.data, _this$data$columns = _this$data.columns, columns = _this$data$columns === void 0 ? [] : _this$data$columns, _this$data$rows = _this$data.rows, rows = _this$data$rows === void 0 ? [] : _this$data$rows;
      var extra = {
        tooltipVisible: this.tooltipVisible,
        legendVisible: this.legendVisible,
        extend: this.extend,
        echarts,
        color: ["#2070F3", "#55CCD9", "#715AF8", "#8AC8F3"],
        _once: {
          onresize: true
        }
      };
      var option = map(columns, rows, this.settings, extra);
      this.huiChartOption = _extends$7({}, option);
    }
  }
};
var _hoisted_1$6 = {
  class: "hui-chart chart-box"
};
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$6, [createElementVNode(
    "div",
    {
      ref: "chartRef",
      style: normalizeStyle({
        width: _ctx.width,
        height: _ctx.height
      })
    },
    null,
    4
    /* STYLE */
  ), renderSlot(_ctx.$slots, "default")]);
}
var HuiChartsMap = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6]]);
HuiChartsMap.install = function(Vue) {
  Vue.component(HuiChartsMap.name, HuiChartsMap);
};

function _extends$6() {
  return _extends$6 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends$6.apply(null, arguments);
}
var getTooltip$3 = function getTooltip2(args) {
  var digit = args.digit, itemDataType = args.itemDataType, linksDataType = args.linksDataType;
  var formatter = function formatter2(item) {
    var name = item.name, data2 = item.data, value = item.value, color = item.color;
    var tplt = [];
    color && tplt.push(itemPoint(color));
    tplt.push(itemLabel("" + name));
    if (!data2 || !data2.source) {
      tplt.push(itemContent(getFormatted(value, itemDataType, digit)) + "<br />");
    } else {
      tplt.push(itemContent(getFormatted(value, linksDataType, digit)) + "<br />");
    }
    return tplt.join("");
  };
  return {
    trigger: "item",
    formatter
  };
};
var getSeries = function getSeries2(args) {
  var dimension = args.dimension; args.itemStyle; args.label; args.lineStyle; var links = args.links, metrics = args.metrics, rows = args.rows, useDataValue = args.useDataValue, valueFull = args.valueFull;
  var dataMap = {};
  var seriesData = rows.map(function(row) {
    dataMap[row[dimension]] = row[metrics];
    return {
      name: row[dimension],
      value: row[metrics]
    };
  });
  var _ref = {}, _ref$innerLinks = _ref.innerLinks, innerLinks = _ref$innerLinks === void 0 ? links : _ref$innerLinks, _ref$mapHandler = _ref.mapHandler, mapHandler = _ref$mapHandler === void 0 ? null : _ref$mapHandler;
  if (useDataValue) {
    mapHandler = function mapHandler2(link) {
      return _extends$6({}, link, {
        value: dataMap[link.target]
      });
    };
  } else if (!valueFull) {
    mapHandler = function mapHandler2(link) {
      return isNull$1(link.value) ? _extends$6({}, link, {
        value: dataMap[link.target]
      }) : link;
    };
  }
  if (mapHandler) {
    innerLinks = links.map(mapHandler);
  }
  var result = {
    type: "sankey",
    data: seriesData,
    links: innerLinks
  };
  var total = 0;
  seriesData.forEach(function(item) {
    var isExist = innerLinks.some(function(data2) {
      return data2.target === item.name;
    });
    if (!isExist) {
      total += item.value;
    }
  });
  return [result];
};
var sankey = function sankey2(columns, rows, settings) {
  var _settings$dataType = settings.dataType, dataType = _settings$dataType === void 0 ? ["normal", "normal"] : _settings$dataType, _settings$dimension = settings.dimension, dimension = _settings$dimension === void 0 ? columns[0] : _settings$dimension, _settings$digit = settings.digit, digit = _settings$digit === void 0 ? 2 : _settings$digit, label = settings.label;
  var links = settings.links, lineStyle = settings.lineStyle, itemStyle = settings.itemStyle, _settings$metrics = settings.metrics, metrics = _settings$metrics === void 0 ? columns[1] : _settings$metrics, _settings$useDataValu = settings.useDataValue, useDataValue = _settings$useDataValu === void 0 ? false : _settings$useDataValu, _settings$valueFull = settings.valueFull, valueFull = _settings$valueFull === void 0 ? false : _settings$valueFull;
  if (!links) {
    return;
  }
  var _ref2 = {}, _ref2$itemDataType = _ref2.itemDataType, itemDataType = _ref2$itemDataType === void 0 ? dataType[0] : _ref2$itemDataType, _ref2$linksDataType = _ref2.linksDataType, linksDataType = _ref2$linksDataType === void 0 ? dataType[1] : _ref2$linksDataType;
  var tooltip = getTooltip$3({
    itemDataType,
    linksDataType,
    digit
  });
  var seriesParams = {
    rows,
    dimension,
    metrics,
    links,
    valueFull,
    useDataValue,
    label,
    itemStyle,
    lineStyle
  };
  var series = getSeries(seriesParams);
  var data2 = {
    nodes: series[0].data,
    links: series[0].links
  };
  series[0].tooltip = {};
  series[0].tooltip.valueFormatter = tooltip.valueFormatter;
  return {
    data: data2,
    tooltip,
    series,
    tipHtml: tooltip.formatter,
    label,
    itemStyle,
    lineStyle
  };
};
var _sfc_main$5 = {
  name: $prefix + "ChartSankey",
  mixins: [Core],
  data: function data() {
    return {
      iChartName: "SankeyChart"
    };
  },
  methods: {
    updateChart: function updateChart() {
      var _this$data = this.data, _this$data$columns = _this$data.columns, columns = _this$data$columns === void 0 ? [] : _this$data$columns, _this$data$rows = _this$data.rows, rows = _this$data$rows === void 0 ? [] : _this$data$rows;
      ({
        legendVisible: this.legendVisible,
        tooltipVisible: this.tooltipVisible
      });
      var option = sankey(columns, rows, this.settings);
      this.huiChartOption = _extends$6({}, option);
    }
  }
};
var _hoisted_1$5 = {
  class: "hui-chart chart-box"
};
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$5, [createElementVNode(
    "div",
    {
      ref: "chartRef",
      style: normalizeStyle({
        width: _ctx.width,
        height: _ctx.height
      })
    },
    null,
    4
    /* STYLE */
  ), renderSlot(_ctx.$slots, "default")]);
}
var HuiChartsSankey = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5]]);
HuiChartsSankey.install = function(Vue) {
  Vue.component(HuiChartsSankey.name, HuiChartsSankey);
};

function _extends$5() {
  return _extends$5 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends$5.apply(null, arguments);
}
var getLegend = function getLegend2(args) {
  var legendVisible = args.legendVisible, legendName = args.legendName;
  var formatter = function formatter2(name) {
    return isDefined(legendName[name]) ? legendName[name] : name;
  };
  return {
    show: legendVisible,
    formatter
  };
};
var getXAxis = function getXAxis2(args) {
  var xAxisName = args.xAxisName, xAxisType = args.xAxisType;
  return {
    name: xAxisName,
    type: xAxisType
  };
};
var getYAxis = function getYAxis2(args) {
  var min = args.min, max = args.max, scale = args.scale, yAxisName = args.yAxisName, dataType = args.dataType, metrics = args.metrics, digit = args.digit;
  function formatter(val) {
    return getFormatted(val, dataType[metrics[0]], digit);
  }
  return {
    name: yAxisName,
    type: "value",
    scale,
    min,
    max,
    axisTick: {
      show: false
    },
    axisLabel: {
      show: true,
      formatter
    }
  };
};
var getDataFromArray = function getDataFromArray2(args) {
  var dimension = args.dimension, metrics = args.metrics, columns = args.columns, rows = args.rows, symbolSize = args.symbolSize, symbolSizeMax = args.symbolSizeMax;
  var extraMetrics = columns.filter(function(col) {
    return col !== dimension && metrics.findIndex(function(m) {
      return m === col;
    }) < 0;
  });
  var newMetrics = [].concat(metrics, extraMetrics);
  var result = {};
  var numbers = {};
  newMetrics.forEach(function(keyname) {
    result[keyname] = [];
    numbers[keyname] = 0;
  });
  rows.forEach(function(item) {
    newMetrics.forEach(function(keyname) {
      if (numbers[keyname] < item[keyname]) {
        numbers[keyname] = item[keyname];
      }
      result[keyname].push([item[dimension], item[keyname], symbolSize, keyname, keyname]);
    });
  });
  if (!symbolSize) {
    newMetrics.forEach(function(keyname) {
      result[keyname].forEach(function(item) {
        item[2] = Math.ceil(item[1] / numbers[keyname] * symbolSizeMax);
      });
    });
  }
  return result;
};
var getData$2 = function getData2(args) {
  var dimension = args.dimension, metrics = args.metrics, columns = args.columns, rows = args.rows, symbolSize = args.symbolSize, symbolSizeMax = args.symbolSizeMax;
  var extraMetrics = columns.filter(function(col) {
    return col !== dimension && metrics.findIndex(function(m) {
      return m === col;
    }) < 0;
  });
  var newColumns = [dimension, metrics[0], "size", "name", "group", metrics[1]].concat(extraMetrics);
  var result = {};
  var maxNumber = 0;
  var _loop = function _loop2() {
    var _Object$entries$_i = _Object$entries[_i], key = _Object$entries$_i[0], value = _Object$entries$_i[1];
    result[key] = [];
    value.forEach(function(item, index) {
      if (maxNumber < item[metrics[1]]) {
        maxNumber = item[metrics[1]];
      }
      var itemArr = [];
      newColumns.forEach(function(col, colIdx) {
        if (colIdx === 2) {
          itemArr.push(symbolSize);
        } else if (colIdx === 3) {
          itemArr.push(metrics[0]);
        } else if (colIdx === 4) {
          itemArr.push(key);
        } else {
          itemArr.push(item[col]);
        }
      });
      result[key][index] = itemArr;
    });
  };
  for (var _i = 0, _Object$entries = Object.entries(rows); _i < _Object$entries.length; _i++) {
    _loop();
  }
  if (!symbolSize) {
    Object.values(result).forEach(function(group) {
      group.forEach(function(item) {
        item[2] = Math.ceil(item[5] / maxNumber * symbolSizeMax);
      });
    });
  }
  return result;
};
var getTooltip$2 = function getTooltip2(args) {
  var tooltipTrigger = args.tooltipTrigger;
  var labelMap = args.labelMap, columns = args.columns, dataType = args.dataType, digit = args.digit;
  var getTipContent = function getTipContent2(item) {
    var color = item.color, seriesName = item.seriesName, data2 = item.data;
    var template = [];
    template.push(itemPoint(color) + " " + seriesName + "<br>");
    var tipData = [].concat(data2);
    tipData.splice(2, 3);
    tipData.forEach(function(d, i) {
      var name = labelMap[columns[i]] || columns[i];
      var num = isNaN(d) ? d : getFormatted(d, dataType[columns[i]], digit);
      template.push("" + itemLabel(name) + itemContent(num) + "<br>");
    });
    return template.join("");
  };
  var formatter = function formatter2(params) {
    return Array.isArray(params) ? params.map(function(i) {
      return getTipContent(i);
    }).join("") : getTipContent(params);
  };
  return {
    trigger: tooltipTrigger,
    formatter
  };
};
var scatter = function scatter2(columns, rows, settings, extra) {
  var _settings$dimension = settings.dimension, dimension = _settings$dimension === void 0 ? columns[0] : _settings$dimension, _settings$metrics = settings.metrics, metrics = _settings$metrics === void 0 ? [columns[1], columns[2]] : _settings$metrics, _settings$dataType = settings.dataType, dataType = _settings$dataType === void 0 ? {} : _settings$dataType;
  var _settings$xAxisType = settings.xAxisType, xAxisType = _settings$xAxisType === void 0 ? "category" : _settings$xAxisType, xAxisName = settings.xAxisName, yAxisName = settings.yAxisName, _settings$digit = settings.digit, digit = _settings$digit === void 0 ? 2 : _settings$digit, _settings$legendName = settings.legendName, legendName = _settings$legendName === void 0 ? {} : _settings$legendName;
  var _settings$labelMap = settings.labelMap, labelMap = _settings$labelMap === void 0 ? {} : _settings$labelMap, _settings$tooltipTrig = settings.tooltipTrigger, tooltipTrigger = _settings$tooltipTrig === void 0 ? "item" : _settings$tooltipTrig, _settings$axisVisible = settings.axisVisible, axisVisible = _settings$axisVisible === void 0 ? true : _settings$axisVisible, _settings$symbolSizeM = settings.symbolSizeMax, symbolSizeMax = _settings$symbolSizeM === void 0 ? 50 : _settings$symbolSizeM, symbol = settings.symbol;
  var symbolSize = settings.symbolSize, symbolRotate = settings.symbolRotate, symbolOffset = settings.symbolOffset, cursor = settings.cursor, min = settings.min, max = settings.max, scale = settings.scale, label = settings.label, itemStyle = settings.itemStyle;
  var tooltipVisible = extra.tooltipVisible, legendVisible = extra.legendVisible; extra.color;
  var baseObj = {
    dimension,
    metrics,
    columns,
    rows,
    symbolSize,
    symbolSizeMax
  };
  var data2 = [];
  if (Array.isArray(rows)) {
    data2 = getDataFromArray(baseObj);
  } else {
    data2 = getData$2(baseObj);
  }
  var legend = getLegend({
    legendVisible,
    legendName
  });
  var ichartOption = {
    data: data2,
    bubbleSize: [10, symbolSizeMax],
    emphasis: {
      label: {
        show: false
      }
    },
    legend,
    xAxisType,
    symbol,
    symbolRotate,
    symbolOffset,
    cursor,
    label,
    itemStyle
  };
  if (tooltipVisible) {
    ichartOption.tooltip = getTooltip$2({
      tooltipTrigger,
      labelMap,
      columns,
      dataType,
      digit
    });
  } else {
    ichartOption.tooltip = {
      show: false
    };
  }
  if (axisVisible) {
    var xAxis = getXAxis({
      xAxisName,
      axisVisible,
      xAxisType,
      dimension,
      rows
    });
    var yAxis = getYAxis({
      min,
      max,
      scale,
      yAxisName,
      dataType,
      metrics,
      digit
    });
    Object.assign(ichartOption, {
      xAxis,
      yAxis
    });
  } else {
    Object.assign(ichartOption, {
      xAxis: {
        show: false
      },
      yAxis: {
        show: false
      }
    });
  }
  return ichartOption;
};
var _sfc_main$4 = {
  name: $prefix + "ChartScatter",
  mixins: [Core],
  data: function data() {
    return {
      iChartName: "BubbleChart"
    };
  },
  methods: {
    updateChart: function updateChart() {
      var _this$data = this.data, _this$data$columns = _this$data.columns, columns = _this$data$columns === void 0 ? [] : _this$data$columns, _this$data$rows = _this$data.rows, rows = _this$data$rows === void 0 ? [] : _this$data$rows;
      var extra = {
        legendVisible: this.legendVisible,
        tooltipVisible: this.tooltipVisible
      };
      var option = scatter(columns, rows, this.settings, extra);
      this.huiChartOption = _extends$5({}, option);
    }
  }
};
var _hoisted_1$4 = {
  class: "hui-chart chart-box"
};
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$4, [createElementVNode(
    "div",
    {
      ref: "chartRef",
      style: normalizeStyle({
        width: _ctx.width,
        height: _ctx.height
      })
    },
    null,
    4
    /* STYLE */
  ), renderSlot(_ctx.$slots, "default")]);
}
var HuiChartsScatter = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4]]);
HuiChartsScatter.install = function(Vue) {
  Vue.component(HuiChartsScatter.name, HuiChartsScatter);
};

function _extends$4() {
  return _extends$4 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends$4.apply(null, arguments);
}
var getTooltip$1 = function getTooltip2() {
  return {
    trigger: "item",
    formatter: function formatter(item) {
      var tpl = [];
      var name = item.name, value = item.value, color = item.color;
      if (name) {
        color && tpl.push(itemPoint(color));
        tpl.push("" + itemLabel("label") + itemContent(name));
        tpl.push("<br>");
      }
      color && tpl.push(itemPoint(color));
      tpl.push("" + itemLabel("sum") + itemContent(value));
      return tpl.join("");
    }
  };
};
var sunburst = function sunburst2(columns, rows, settings, extra) {
  var defaultItemStyle = {
    borderWidth: 2
  };
  var series = {
    type: "sunburst",
    itemStyle: defaultItemStyle
  };
  var tooltipVisible = extra.tooltipVisible;
  var tooltip = tooltipVisible && getTooltip$1();
  var options = {
    series,
    tooltip,
    topHtml: tooltip.formatter
  };
  return options;
};
var _sfc_main$3 = {
  name: $prefix + "ChartSunburst",
  mixins: [Core],
  data: function data() {
    return {
      iChartName: "SunburstChart"
    };
  },
  methods: {
    updateChart: function updateChart(data2) {
      var _data$columns = data2.columns, columns = _data$columns === void 0 ? [] : _data$columns, _data$rows = data2.rows, rows = _data$rows === void 0 ? [] : _data$rows;
      var extra = {
        tooltipVisible: this.tooltipVisible,
        extend: this.extend
      };
      var option = sunburst(columns, rows, this.settings, extra);
      this.huiChartOption = _extends$4({}, option);
    }
  }
};
var _hoisted_1$3 = {
  class: "hui-chart chart-box"
};
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$3, [createElementVNode(
    "div",
    {
      ref: "chartRef",
      style: normalizeStyle({
        width: _ctx.width,
        height: _ctx.height
      })
    },
    null,
    4
    /* STYLE */
  ), renderSlot(_ctx.$slots, "default")]);
}
var HuiChartsSunburst = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]);
HuiChartsSunburst.install = function(Vue) {
  Vue.component(HuiChartsSunburst.name, HuiChartsSunburst);
};

function _extends$3() {
  return _extends$3 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends$3.apply(null, arguments);
}
var getTreeLegend = function getTreeLegend2(args) {
  var dimension = args.dimension, rows = args.rows;
  var result = rows.map(function(row) {
    return row[dimension];
  });
  return {
    data: result
  };
};
var getTreeTooltip = function getTreeTooltip2(opts) {
  var tooltipFormatter = opts.tooltipFormatter;
  return {
    trigger: "item",
    triggerOn: "mousemove",
    formatter: function formatter(item) {
      if (tooltipFormatter) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        return tooltipFormatter.apply(void 0, [item].concat(args));
      }
      var template = [];
      var treeAncestors = item.treeAncestors, value = item.value;
      var names = [];
      treeAncestors.forEach(function(ancestor, idx) {
        idx && names.push(ancestor.name);
      });
      template.push("" + itemLabel(names.join(".")));
      template.push("" + itemContent(value));
      return template.join("");
    }
  };
};
var getTreeSeries = function getTreeSeries2(args) {
  var dimension = args.dimension, metrics = args.metrics, rows = args.rows, seriesMap = args.seriesMap;
  var series = [];
  rows.forEach(function(row) {
    var seriesItem = seriesMap[row[dimension]];
    var result = {
      type: "tree",
      name: row[dimension],
      data: row[metrics]
    };
    if (seriesItem) {
      Object.keys(seriesItem).forEach(function(key) {
        if (!isObject(result[key])) {
          result[key] = seriesItem[key];
        } else {
          Object.assign(result[key], seriesItem[key]);
        }
      });
    }
    series.push(result);
  });
  return series;
};
var tree = function tree2(columns, rows, settings, extra) {
  var _settings$dimension = settings.dimension, dimension = _settings$dimension === void 0 ? columns[0] : _settings$dimension, _settings$metrics = settings.metrics, metrics = _settings$metrics === void 0 ? columns[1] : _settings$metrics, _settings$seriesMap = settings.seriesMap, seriesMap = _settings$seriesMap === void 0 ? {} : _settings$seriesMap;
  var legendVisible = extra.legendVisible, tooltipFormatter = extra.tooltipFormatter, tooltipVisible = extra.tooltipVisible;
  var seriesParam = {
    dimension,
    metrics,
    rows,
    seriesMap
  };
  var series = getTreeSeries(seriesParam);
  var legendParam = {
    dimension,
    rows
  };
  var legend = legendVisible && rows.length > 1 && getTreeLegend(legendParam);
  var tooltip = tooltipVisible && getTreeTooltip({
    tooltipFormatter
  });
  var data2 = rows.map(function(item) {
    return {
      name: item.name,
      data: item.value
    };
  });
  return {
    data: data2,
    series,
    legend,
    tooltip,
    tipHtml: tooltip.formatter,
    type: "LineTreeHuiCharts",
    initialTreeDepth: 3
  };
};
var _sfc_main$2 = {
  name: $prefix + "ChartTree",
  mixins: [Core],
  data: function data() {
    return {
      iChartName: "TreeChart"
    };
  },
  methods: {
    updateChart: function updateChart() {
      var _this$data = this.data, _this$data$columns = _this$data.columns, columns = _this$data$columns === void 0 ? [] : _this$data$columns, _this$data$rows = _this$data.rows, rows = _this$data$rows === void 0 ? [] : _this$data$rows;
      var extra = {
        tooltipVisible: this.tooltipVisible,
        legendVisible: this.legendVisible,
        tooltipFormatter: this.tooltipFormatter
      };
      var option = tree(columns, rows, this.settings, extra);
      this.huiChartOption = _extends$3({}, option);
    }
  }
};
var _hoisted_1$2 = {
  class: "hui-chart chart-box"
};
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$2, [createElementVNode(
    "div",
    {
      ref: "chartRef",
      style: normalizeStyle({
        width: _ctx.width,
        height: _ctx.height
      })
    },
    null,
    4
    /* STYLE */
  ), renderSlot(_ctx.$slots, "default")]);
}
var HuiChartsTree = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2]]);
HuiChartsTree.install = function(Vue) {
  Vue.component(HuiChartsTree.name, HuiChartsTree);
};

function _extends$2() {
  return _extends$2 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t2 = arguments[e];
      for (var r in t2)
        ({}).hasOwnProperty.call(t2, r) && (n[r] = t2[r]);
    }
    return n;
  }, _extends$2.apply(null, arguments);
}
var getWaterfallTooltip = function getWaterfallTooltip2(dataType, digit) {
  var formatter = function formatter2(items) {
    var item = items[0];
    return itemContent(item.name) + "<br/>\n    " + itemLabel(item.seriesName) + " " + itemContent(getFormatted(item.value, dataType, digit));
  };
  return formatter;
};
var getWaterfallXAxis = function getWaterfallXAxis2(args) {
  var axisVisible = args.axisVisible, labelMap = args.labelMap, xAxisName = args.xAxisName;
  var name = labelMap && labelMap[xAxisName] || xAxisName;
  return {
    data: name,
    show: axisVisible
  };
};
var getWaterfallYAxis = function getWaterfallYAxis2(args) {
  var axisVisible = args.axisVisible, labelMap = args.labelMap, yAxisName = args.yAxisName;
  var isNull = function isNull2(x) {
    return x === null || x === void 0;
  };
  var name = !isNull(labelMap[yAxisName]) ? labelMap[yAxisName] : yAxisName;
  return {
    name,
    show: axisVisible
  };
};
var getData$1 = function getData2(args) {
  var rows = args.rows, totalNum = args.totalNum, remainName = args.remainName, dataSum = args.dataSum, remainStatus = args.remainStatus, dimension = args.dimension, metrics = args.metrics, digit = args.digit;
  var data2 = [].concat(rows);
  if (remainStatus === "have-remain") {
    var _data$push;
    data2.push((_data$push = {}, _data$push[dimension] = remainName, _data$push[metrics] = parseFloat(totalNum - dataSum).toFixed(digit), _data$push));
  }
  return data2;
};
var waterfall = function waterfall2(columns, rows, settings, extra) {
  var tooltipVisible = extra.tooltipVisible, t2 = extra.t;
  var _settings$axisVisible = settings.axisVisible, axisVisible = _settings$axisVisible === void 0 ? true : _settings$axisVisible, _settings$dataType = settings.dataType, dataType = _settings$dataType === void 0 ? "normal" : _settings$dataType, _settings$dimension = settings.dimension, dimension = _settings$dimension === void 0 ? columns[0] : _settings$dimension;
  var _settings$remainName = settings.remainName, remainName = _settings$remainName === void 0 ? t2("ui.chart.other") : _settings$remainName, _settings$totalName = settings.totalName, totalName = _settings$totalName === void 0 ? t2("ui.chart.total") : _settings$totalName;
  var totalNum = settings.totalNum, _settings$xAxisName = settings.xAxisName, xAxisName = _settings$xAxisName === void 0 ? dimension : _settings$xAxisName, _settings$digit = settings.digit, digit = _settings$digit === void 0 ? 2 : _settings$digit, _settings$labelMap = settings.labelMap, labelMap = _settings$labelMap === void 0 ? {} : _settings$labelMap;
  var metrics = settings.metrics;
  if (metrics === void 0) {
    var metricsTemp = columns.slice().filter(function(val) {
      return val !== dimension;
    });
    metrics = metricsTemp[0];
  }
  var yAxisName = metrics;
  var dataSum = parseFloat(rows.reduce(function(pre, cur) {
    return pre + Number(cur[metrics]);
  }, 0).toFixed(digit));
  var remainStatus = totalNum ? totalNum > dataSum ? "have-remain" : "none-remain" : "not-total";
  var xAxis = getWaterfallXAxis({
    axisVisible,
    labelMap,
    xAxisName
  });
  var yAxis = getWaterfallYAxis({
    axisVisible,
    labelMap,
    yAxisName
  });
  var seriesParams = {
    dataType,
    rows,
    dimension,
    metrics
  };
  Object.assign(seriesParams, {
    totalNum,
    remainStatus,
    dataSum,
    digit
  });
  var data2 = getData$1({
    rows,
    totalNum,
    totalName,
    remainName,
    dataSum,
    remainStatus,
    dimension,
    metrics
  });
  var ichartOption = {
    type: "water-fall",
    xAxis,
    yAxis,
    data: data2,
    totalName,
    totalPosition: "start",
    label: {
      show: true,
      position: "top",
      formatter: function formatter(item) {
        return getFormatted(item.value, dataType, digit);
      }
    },
    legend: {
      show: false
    }
  };
  if (tooltipVisible) {
    ichartOption.tipHtml = getWaterfallTooltip(dataType, digit);
  } else {
    ichartOption.tooltip = {
      show: false
    };
  }
  return ichartOption;
};
var _sfc_main$1 = {
  name: $prefix + "ChartWaterfall",
  mixins: [Core],
  data: function data() {
    return {
      iChartName: "BarChart"
    };
  },
  methods: {
    updateChart: function updateChart(data2) {
      var _data$columns = data2.columns, columns = _data$columns === void 0 ? [] : _data$columns, _data$rows = data2.rows, rows = _data$rows === void 0 ? [] : _data$rows;
      var extra = {
        tooltipVisible: this.tooltipVisible,
        legendVisible: this.legendVisible,
        t
      };
      var option = waterfall(columns, rows, this.settings, extra);
      this.huiChartOption = _extends$2({}, option);
    }
  }
};
var _hoisted_1$1 = {
  class: "hui-chart chart-box"
};
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$1, [createElementVNode(
    "div",
    {
      ref: "chartRef",
      style: normalizeStyle({
        width: _ctx.width,
        height: _ctx.height
      })
    },
    null,
    4
    /* STYLE */
  ), renderSlot(_ctx.$slots, "default")]);
}
var HuiChartsWaterfall = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
HuiChartsWaterfall.install = function(Vue) {
  Vue.component(HuiChartsWaterfall.name, HuiChartsWaterfall);
};

function _extends$1() {
  return _extends$1 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends$1.apply(null, arguments);
}
var getTooltip = function getTooltip2(args) {
  var tooltipFormatter = args.tooltipFormatter;
  function formatter(params) {
    var data2 = params.data;
    var name = data2.name, value = data2.value;
    if (tooltipFormatter) {
      return tooltipFormatter.apply(void 0, params);
    }
    return "" + itemLabel(name) + itemContent(value);
  }
  return formatter;
};
var shapeSquare = function shapeSquare2(theta) {
  return Math.min(1 / Math.abs(Math.cos(theta)), 1 / Math.abs(Math.sin(theta)));
};
var getData = function getData2(args) {
  var dimension = args.dimension, metrics = args.metrics, rows = args.rows;
  return rows.slice().map(function(row) {
    return {
      name: row[dimension],
      value: row[metrics]
    };
  });
};
var getWordColor = function getWordColor2(args) {
  var color = args.color, colors = args.colors;
  var tempColor = color || colors;
  if (Array.isArray(tempColor) && tempColor.length) {
    var textColor = function textColor2(word) {
      return tempColor[word.dataIndex % tempColor.length];
    };
    return {
      textColor
    };
  }
  if (!Array.isArray(tempColor) && Boolean(tempColor)) {
    return {
      color: tempColor
    };
  }
  return "rgb(" + Math.round(Math.random() * 160) + "," + Math.round(Math.random() * 160) + "," + Math.round(Math.random() * 160) + ")";
};
var wordcloud = function wordcloud2(columns, rows, settings, extra) {
  var _settings$dimension = settings.dimension, dimension = _settings$dimension === void 0 ? columns[0] : _settings$dimension, _settings$metrics = settings.metrics, metrics = _settings$metrics === void 0 ? columns[1] : _settings$metrics;
  var _settings$sizeMax = settings.sizeMax, sizeMax = _settings$sizeMax === void 0 ? 60 : _settings$sizeMax, _settings$sizeMin = settings.sizeMin, sizeMin = _settings$sizeMin === void 0 ? 12 : _settings$sizeMin, shape = settings.shape, _settings$color = settings.color, color = _settings$color === void 0 ? "" : _settings$color;
  var tooltipVisible = extra.tooltipVisible, tooltipFormatter = extra.tooltipFormatter, colors = extra.color;
  var data2 = getData({
    dimension,
    metrics,
    rows
  });
  var wordColors = getWordColor({
    color,
    colors
  });
  var ichartOptions = _extends$1({
    sizeRange: [sizeMin, sizeMax],
    shape: shape || shapeSquare,
    data: data2
  }, wordColors);
  if (tooltipVisible) {
    ichartOptions.tipHtml = getTooltip({
      tooltipFormatter
    });
  }
  return ichartOptions;
};
var _sfc_main = {
  name: $prefix + "ChartWordcloud",
  mixins: [Core],
  data: function data() {
    return {
      iChartName: "WordCloudChart"
    };
  },
  methods: {
    updateChart: function updateChart() {
      var _this$data = this.data, _this$data$columns = _this$data.columns, columns = _this$data$columns === void 0 ? [] : _this$data$columns, _this$data$rows = _this$data.rows, rows = _this$data$rows === void 0 ? [] : _this$data$rows;
      var extra = {
        tooltipVisible: this.tooltipVisible
      };
      var option = wordcloud(columns, rows, this.settings, extra);
      this.huiChartOption = _extends$1({}, option);
    }
  }
};
var _hoisted_1 = {
  class: "hui-chart chart-box"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1, [createElementVNode(
    "div",
    {
      ref: "chartRef",
      style: normalizeStyle({
        width: _ctx.width,
        height: _ctx.height
      })
    },
    null,
    4
    /* STYLE */
  ), renderSlot(_ctx.$slots, "default")]);
}
var HuiChartsWordcloud = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
HuiChartsWordcloud.install = function(Vue) {
  Vue.component(HuiChartsWordcloud.name, HuiChartsWordcloud);
};

function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
var HuiCharts = defineComponent({
  name: $prefix + "HuiCharts",
  props: _extends({}, Core.props, {
    type: {
      type: String
    }
  }),
  data: function data() {
    this.chartLib = {
      bar: HuiChartsBar,
      histogram: HuiChartsHistogram,
      line: HuiChartsLine,
      pie: HuiChartsPie,
      ring: HuiChartsRing,
      radar: HuiChartsRadar,
      autonaviMap: AutonaviMap,
      baiduMap: BaiduMap,
      boxplot: HuiChartsBoxplot,
      candle: HuiChartsCandle,
      funnel: HuiChartsFunnel,
      gauge: HuiChartsGauge,
      graph: HuiChartsGraph,
      heatmap: HuiChartsHeatmap,
      liquidfill: HuiChartsLiquidfill,
      map: HuiChartsMap,
      sankey: HuiChartsSankey,
      scatter: HuiChartsScatter,
      sunburst: HuiChartsSunburst,
      tree: HuiChartsTree,
      waterfall: HuiChartsWaterfall,
      wordcloud: HuiChartsWordcloud
    };
    return {};
  },
  methods: _extends({
    ready: function ready(val) {
      this.$emit("ready", val);
    },
    readyOnce: function readyOnce(val) {
      this.$emit("readyOnce", val);
    },
    handleColor: function handleColor(val) {
      this.$emit("handle-color", val);
    }
  }, Core.methods),
  render: function render() {
    return h("div", {
      style: {
        width: this.width,
        height: this.height,
        position: "relative"
      }
    }, [
      h(this.chartLib[this.settings.type || this.type], {
        props: _extends({}, this.$props),
        on: {
          ready: this.ready,
          readyOnce: this.readyOnce,
          handleColor: this.handleColor
        }
      }),
      // eslint-disable-next-line vue/require-slots-as-functions
      this.$slots.default
    ]);
  }
});
var version = "3.20.0";
HuiCharts.install = function(Vue) {
  Vue.component(HuiCharts.name, HuiCharts);
};
HuiCharts.version = version;

export { HuiCharts as default };
